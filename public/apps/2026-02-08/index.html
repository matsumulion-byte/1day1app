<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b1020" />
  <title>ãƒã‚­ãƒ³ãƒ¬ãƒ¼ã‚¹ï¼ˆæœ¬å½“ã«ï¼‰ï½œ2/8</title>
  <style>
    :root{
      --bg:#0b1020;
      --ink:#f3f6ff;
      --muted:rgba(243,246,255,.72);
      --line:rgba(255,255,255,.14);
      --good:#34d399;
      --bad:#fb7185;
      --r:18px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%; background:var(--bg); color:var(--ink); overflow:hidden}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      user-select:none;
    }
    .wrap{
      height:100svh;
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      padding:
        max(10px, env(safe-area-inset-top))
        10px
        max(10px, env(safe-area-inset-bottom))
        10px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
      border-radius: var(--r);
      box-shadow: var(--shadow);
      min-height: 54px;
    }
    .title{
      font-weight:900;
      letter-spacing:.02em;
      font-size:13px;
      line-height:1.1;
      white-space:nowrap;
    }
    .right{display:flex; align-items:center; gap:8px; flex-shrink:0}
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background:rgba(255,255,255,.10);
      color:var(--ink);
      padding:8px 10px;
      border-radius: 12px;
      font-weight:800;
      font-size:12px;
      cursor:pointer;
    }
    .btn:active{transform: translateY(1px)}
    .stage{
      position:relative;
      border:1px solid var(--line);
      border-radius: var(--r);
      overflow:hidden;
      box-shadow: var(--shadow);
      background:
        radial-gradient(900px 700px at 50% 20%, rgba(96,165,250,.16), rgba(11,16,32,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    }
    canvas{width:100%; height:100%; display:block}
    .hud{
      position:absolute;
      inset:10px 10px auto 10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .hud .box{
      padding:8px 10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.28);
      backdrop-filter: blur(8px);
      border-radius: 12px;
    }
    .hud .big{font-size:18px; font-weight:900; letter-spacing:.02em}
    .hud .small{font-size:10px; color:var(--muted); margin-top:3px}
    .toast{
      position:absolute;
      left:50%;
      top: 50%;
      transform:translate(-50%,-50%);
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.35);
      border-radius:999px;
      font-weight:900;
      font-size:13px;
      opacity:0;
      transition: opacity .15s ease;
      pointer-events:none;
      white-space:nowrap;
    }
    .toast.show{opacity:1}
    footer{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius: 22px;
      box-shadow: var(--shadow);
      min-height: 92px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      font-weight:1000;
      letter-spacing:.03em;
      cursor:pointer;
      user-select:none;
      padding:14px 14px;
    }
    footer .hint{
      display:block;
      font-size:12px;
      font-weight:800;
      color:var(--muted);
      letter-spacing:0;
      margin-top:6px
    }
    footer:active{transform: translateY(1px)}
    .overlay{
      position:absolute; inset:0;
      display:grid;
      place-items:center;
      background:rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
    }
    .overlay.show{opacity:1; pointer-events:auto}
    .modal{
      width:min(520px, 92%);
      border:1px solid var(--line);
      background:rgba(11,16,32,.92);
      border-radius: 22px;
      padding:16px;
      box-shadow: var(--shadow);
    }
    .modal h2{font-size:16px; margin-bottom:6px}
    .modal p{font-size:13px; color:var(--muted); line-height:1.6}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px}
    .modal .row .btn{flex:1}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--ink);
      display:inline-block;
      margin:0 3px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">ãƒã‚­ãƒ³ãƒ¬ãƒ¼ã‚¹ï¼ˆæœ¬å½“ã«ï¼‰</div>
      <div class="right">
        <button class="btn" id="muteBtn" type="button">SOUND: ON</button>
        <button class="btn" id="resetBtn" type="button">RESET</button>
      </div>
    </header>

    <div class="stage" id="stage">
      <canvas id="c"></canvas>

      <div class="hud">
        <div class="box">
          <div class="big" id="meter">0.0m</div>
          <div class="small">ä»Šã®ä½ç½®</div>
        </div>
        <div class="box" style="text-align:right">
          <div class="big" id="maxMeter">0.0m</div>
          <div class="small">ä»Šå›MAX</div>
        </div>
      </div>

      <div class="toast" id="toast">ãƒã‚­ã£ã¦ãªã„ï¼Ÿ</div>

      <div class="overlay show" id="overlay">
        <div class="modal">
          <h2>ç¸¦ãƒã‚­ãƒ³ãƒ¬ãƒ¼ã‚¹ï¼ˆæœ¬å½“ã«ï¼‰</h2>
          <p>
            <b>æ“ä½œï¼š</b>ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’<b>æŠ¼ã—ç¶šã‘ã‚‹</b>ã¨ä¸Šã¸å‰é€²ã€‚<b>é›¢ã™</b>ã¨ä¸‹ã¸å¾Œé€€ã€‚<br/>
            <b>ç›®çš„ï¼š</b>ä¸Šã®å´–ï¼ˆèµ¤ç·šï¼‰ã®æ‰‹å‰ã‚®ãƒªã¾ã§ã€‚è¶ŠãˆãŸã‚‰è½ä¸‹ã€‚<br/>
            PCã¯ <span class="kbd">Space</span> æŠ¼ã—ã£ã±ã§ã‚‚OKã€‚
          </p>
          <div class="row">
            <button class="btn" id="startBtn" type="button">START</button>
            <button class="btn" type="button">éŸ³ã¯å³ä¸Š</button>
          </div>
        </div>
      </div>
    </div>

    <footer id="pad">
      HOLD TO GO
      <span class="hint">é›¢ã™ã¨å¾Œé€€ï¼ˆ=ãƒã‚­ã‚‹ï¼‰ï¼å´–è¶Šãˆã§è½ä¸‹</span>
    </footer>
  </div>

<script type="module">
  // Vercelç”¨ã®ãƒ‘ã‚¹è§£æ±ºãƒ˜ãƒ«ãƒ‘ãƒ¼
  const DATE_SEGMENT = (location.pathname.match(/\d{4}-\d{2}-\d{2}/) || [""])[0];
  const DATE_BASE = DATE_SEGMENT ? `/${DATE_SEGMENT}/` : "/";
  const asset = (p) => {
    const clean = String(p || "").replace(/^\.?\//, "");
    return `${DATE_BASE}${clean}`;
  };

  const USE_IMAGE = true;
  const img = new Image();
  img.src = asset("./assets/chicken-matsumura.png");

  // ç”»åƒèª­ã¿è¾¼ã¿å‰ã«æç”»ãŒèµ°ã£ã¦ã‚‚OKã«ã™ã‚‹ï¼ˆèª­ã¿è¾¼ã‚ãŸã‚‰å†æç”»ï¼‰
  img.onload = () => { draw(); };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const stage = document.getElementById("stage");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");
  const muteBtn = document.getElementById("muteBtn");
  const meterEl = document.getElementById("meter");
  const maxMeterEl = document.getElementById("maxMeter");
  const toast = document.getElementById("toast");
  const pad = document.getElementById("pad");

  // ---- ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆç°¡æ˜“ WebAudioï¼‰ ----
  let audioCtx = null;
  let muted = false;
  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function beep(freq=440, dur=0.05, type="sine", gain=0.06){
    if (muted) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }
  function setMuted(v){
    muted = v;
    muteBtn.textContent = `SOUND: ${muted ? "OFF" : "ON"}`;
  }

  function resize(){
    const r = stage.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  // ---- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ï¼ˆç¸¦é€²è¡Œï¼‰ ----
  let running = false;
  let holding = false;
  let dead = false;

  // p: 0..1ï¼ˆä¸‹â†’ä¸Šã¸é€²ã‚€ï¼‰
  let p = 0.10;
  let vp = 0;
  let maxP = p;

  // å´–ï¼šä¸Šã®æ–¹ã«ç½®ãï¼ˆpãŒã“ã®å€¤ã‚’è¶Šãˆã‚‹ã¨å±é™ºï¼‰
  const cliffP = 0.90;
  const fallP  = 0.975;
  const backLimit = 0.04;

  let toastTimer = 0;
  let lastT = performance.now();
  let animStartTime = performance.now();

  function updateHUD(){
    const nowM = p * 100;
    const maxM = maxP * 100;
    meterEl.textContent = `${nowM.toFixed(1)}m`;
    maxMeterEl.textContent = `${maxM.toFixed(1)}m`;
  }

  function resetGame(showOverlay=true){
    running = false;
    holding = false;
    dead = false;
    p = 0.10;
    vp = 0;
    maxP = p;
    toastTimer = 0;
    animStartTime = performance.now(); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
    updateHUD();
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
    const title = overlay.querySelector("h2");
    const desc = overlay.querySelector("p");
    title.textContent = "ç¸¦ãƒã‚­ãƒ³ãƒ¬ãƒ¼ã‚¹ï¼ˆæœ¬å½“ã«ï¼‰";
    desc.innerHTML =
      `<b>æ“ä½œï¼š</b>ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’<b>æŠ¼ã—ç¶šã‘ã‚‹</b>ã¨ä¸Šã¸å‰é€²ã€‚<b>é›¢ã™</b>ã¨ä¸‹ã¸å¾Œé€€ã€‚<br/>` +
      `<b>ç›®çš„ï¼š</b>ä¸Šã®å´–ï¼ˆèµ¤ç·šï¼‰ã®æ‰‹å‰ã‚®ãƒªã¾ã§ã€‚è¶ŠãˆãŸã‚‰è½ä¸‹ã€‚<br/>` +
      `PCã¯ <span class="kbd">Space</span> æŠ¼ã—ã£ã±ã§ã‚‚OKã€‚`;
    startBtn.textContent = "START";
    
    if (showOverlay) overlay.classList.add("show");
    draw();
  }

  function startGame(){
    ensureAudio();
    running = true;
    dead = false;
    // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ä½ç½®ã¨æœ€é«˜åˆ°é”ã‚’ãƒªã‚»ãƒƒãƒˆ
    p = 0.10;
    vp = 0;
    maxP = p;
    animStartTime = performance.now(); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹æ™‚åˆ»ã‚’ãƒªã‚»ãƒƒãƒˆ
    updateHUD();
    overlay.classList.remove("show");
    beep(660, 0.06, "square", 0.07);
    lastT = performance.now();
    requestAnimationFrame(loop);
  }

  function showRecordModal(){
    running = false;
    const title = overlay.querySelector("h2");
    const desc = overlay.querySelector("p");
    const recordM = maxP * 100;
    title.textContent = "ãƒã‚­ã£ãŸ";
    
    if (recordM >= 95){
      desc.innerHTML =
        `è¨˜éŒ²ï¼š<b>${recordM.toFixed(1)}m</b><br/><br/>` +
        `ã‚„ã°ã„ï¼95mè¶…ãˆãŸï¼ãƒã‚­ãƒ³ç¥ï¼`;
    } else if (recordM >= 90){
      desc.innerHTML =
        `è¨˜éŒ²ï¼š<b>${recordM.toFixed(1)}m</b><br/><br/>` +
        `ã™ã”ã„ï¼90mè¶…ãˆãŸï¼ãƒã‚­ãƒ³ã®å‰²ã«ã„ã„ãƒãƒ„ã—ã¦ã‚‹ï¼`;
    } else {
      desc.innerHTML =
        `è¨˜éŒ²ï¼š<b>${recordM.toFixed(1)}m</b>`;
    }
    
    startBtn.textContent = "RETRY";
    overlay.classList.add("show");
    beep(220, 0.06, "sawtooth", 0.05);
  }

  function setHolding(v){
    if (holding === v) return;
    holding = v;
    if (holding){
      beep(520, 0.03, "triangle", 0.05);
    }else{
      if (running && !dead){
        // ãƒã‚­ã£ãŸæ™‚ã«å°‘ã—ä½™éŸ»ã‚’ç½®ã„ã¦ã‹ã‚‰ãƒ¢ãƒ¼ãƒ€ãƒ«ã§è¨˜éŒ²ã‚’è¡¨ç¤º
        running = false;
        setTimeout(() => {
          showRecordModal();
        }, 400);
      }
    }
  }

  // pointer
  const down = (e) => { e.preventDefault(); if (overlay.classList.contains("show")) startGame(); setHolding(true); };
  const up   = (e) => { e.preventDefault(); setHolding(false); };
  pad.addEventListener("pointerdown", down, {passive:false});
  pad.addEventListener("pointerup", up, {passive:false});
  pad.addEventListener("pointercancel", up, {passive:false});
  pad.addEventListener("pointerleave", up, {passive:false});

  // keyboard
  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space"){
      e.preventDefault();
      if (!running && overlay.classList.contains("show")) startGame();
      setHolding(true);
    }
  }, {passive:false});
  window.addEventListener("keyup", (e)=>{
    if (e.code === "Space"){
      e.preventDefault();
      setHolding(false);
    }
  }, {passive:false});

  // buttons
  startBtn.addEventListener("click", startGame);
  resetBtn.addEventListener("click", ()=>resetGame(true));
  muteBtn.addEventListener("click", ()=>{
    setMuted(!muted);
    if (!muted) beep(880, 0.05, "square", 0.06);
  });

  function loop(t){
    if (!running) return;
    const dt = Math.min(0.033, Math.max(0.001, (t - lastT) / 1000));
    lastT = t;

    step(dt);
    draw();
    if (running) requestAnimationFrame(loop);
  }

  function step(dt){
    if (dead) return;

    // æŠ¼ã—ã£ã±ã§ä¸Šã¸ï¼ˆpå¢—åŠ ï¼‰ã€é›¢ã™ã¨ä¸‹ã¸ï¼ˆpæ¸›å°‘ï¼‰
    const accel = holding ? 1.55 : -1.10;
    const drag  = holding ? 0.985 : 0.965;

    vp += accel * dt;
    vp *= Math.pow(drag, dt * 60);

    const vmax = holding ? 0.75 : 0.65;
    vp = Math.max(-0.9, Math.min(vmax, vp));

    p += vp * dt;

    if (p < backLimit){
      p = backLimit;
      vp = Math.max(0, vp);
    }

    // æœ€é«˜åˆ°é”ã‚’æ›´æ–°ï¼ˆè½ä¸‹ãƒ©ã‚¤ãƒ³ã‚’è¶Šãˆã‚‹å‰ã¾ã§ï¼‰
    if (p > maxP && p < fallP) maxP = p;

    // è½ä¸‹
    if (p >= fallP){
      dead = true;
      running = false;
      setHolding(false);
      deathAnim();
      return;
    }

    // å´–ã«è¿‘ã¥ãã»ã©ãƒ–ãƒ¬
    const danger = clamp((p - (cliffP - 0.12)) / 0.12, 0, 1);
    if (danger > 0){
      p += (Math.random() - 0.5) * 0.0018 * danger;
    }

    // ãƒˆãƒ¼ã‚¹ãƒˆ
    if (toastTimer > 0){
      toastTimer -= dt;
      if (toastTimer <= 0) toast.classList.remove("show");
    }

    if (p >= (cliffP - 0.03) && p < cliffP){
      toast.textContent = "ã‚®ãƒªâ€¦ã‚®ãƒªâ€¦ï¼";
      toast.classList.add("show");
      toastTimer = 0.22;
    } else if (p >= cliffP && p < fallP){
      toast.textContent = "è¶Šãˆã¦ã‚‹è¶Šãˆã¦ã‚‹ï¼";
      toast.classList.add("show");
      toastTimer = 0.28;
    }

    updateHUD();
  }

  function deathAnim(){
    const title = overlay.querySelector("h2");
    const desc = overlay.querySelector("p");
    title.textContent = "è½ä¸‹ã€‚";
    desc.innerHTML =
      `å´–ã®èµ¤ç·šã®æ‰‹å‰ã‚®ãƒªã‚’ç‹™ãˆã€‚`;

    overlay.classList.add("show");

    beep(120, 0.08, "sawtooth", 0.08);
    setTimeout(()=>beep(90, 0.12, "sine", 0.07), 70);
    setTimeout(()=>beep(70, 0.18, "triangle", 0.06), 160);
    startBtn.textContent = "RETRY";
  }

  function draw(){
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    ctx.clearRect(0,0,w,h);

    // ç¸¦ãƒˆãƒ©ãƒƒã‚¯ï¼ˆä¸­å¤®ã«ç¸¦ãƒ¬ãƒ¼ãƒ³ï¼‰
    const laneW = Math.min(260, Math.floor(w * 0.62));
    const laneX = Math.floor((w - laneW) / 2);
    const laneY = 12;
    const laneH = h - 24;

    // ãƒ¬ãƒ¼ãƒ³æœ¬ä½“
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    roundRect(ctx, laneX, laneY, laneW, laneH, 18);
    ctx.fill();

    // ç›®ç››ã‚Šï¼ˆæ¨ªç·šï¼‰
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    const ticks = 10;
    for (let i=0;i<=ticks;i++){
      const yy = laneY + laneH * (i/ticks);
      ctx.beginPath();
      ctx.moveTo(laneX + 18, yy);
      ctx.lineTo(laneX + laneW - 18, yy);
      ctx.stroke();
    }
    ctx.restore();

    // å´–ãƒ©ã‚¤ãƒ³ï¼ˆä¸Šã®æ–¹ï¼‰
    const cliffY = laneY + laneH * (1 - cliffP);
    const fallY  = laneY + laneH * (1 - fallP);

    // è½ä¸‹ãƒ©ã‚¤ãƒ³ï¼ˆç‚¹ç·šï¼‰
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(laneX, fallY);
    ctx.lineTo(laneX + laneW, fallY);
    ctx.stroke();
    ctx.restore();

    // å´–ãƒ©ã‚¤ãƒ³ï¼ˆèµ¤ï¼‰ï¼‹å±é™ºã‚¾ãƒ¼ãƒ³ï¼ˆä¸Šå´ï¼‰
    ctx.save();
    ctx.strokeStyle = "rgba(251,113,133,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(laneX, cliffY);
    ctx.lineTo(laneX + laneW, cliffY);
    ctx.stroke();

    ctx.fillStyle = "rgba(251,113,133,0.16)";
    ctx.fillRect(laneX, laneY, laneW, cliffY - laneY); // ä¸Šå´ã‚’å±é™ºã¨ã—ã¦å¡—ã‚‹
    ctx.restore();

    // MAXãƒãƒ¼ã‚«ãƒ¼
    const maxY = laneY + laneH * (1 - maxP);
    ctx.save();
    ctx.strokeStyle = "rgba(52,211,153,0.65)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(laneX + 10, maxY);
    ctx.lineTo(laneX + 36, maxY);
    ctx.stroke();
    ctx.fillStyle = "rgba(52,211,153,0.9)";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    ctx.fillText("MAX", laneX + 40, maxY + 4);
    ctx.restore();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®
    const py = laneY + laneH * (1 - p);
    const px = Math.floor(w/2);

    const danger = clamp((p - (cliffP - 0.12)) / 0.12, 0, 1);

    // å½±
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(px, py + 28, 34, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // æœ¬ä½“
    ctx.save();
    const animTime = (performance.now() - animStartTime) / 120;
    const bob = Math.sin(animTime) * (holding ? 1.5 : 0.8);
    const rot = (holding ? -0.05 : 0.03) * (0.3 + danger);
    ctx.translate(px, py + bob);
    ctx.rotate(rot);

    // æœ¬ä½“ï¼ˆå…¨èº«PNGã‚’"è¶³å…ƒåŸºæº–"ã§é…ç½®ï¼‰
    if (USE_IMAGE && img.complete && img.naturalWidth) {
      // ãƒ¬ãƒ¼ãƒ³å¹…ã«åˆã‚ã›ã¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆå¤§ãã™ããªã„ã‚ˆã†åˆ¶é™ï¼‰
      const laneW = Math.min(260, Math.floor(w * 0.62)); // draw() å†…ã§ä½¿ã£ã¦ã‚‹å€¤ã¨åŒã˜æƒ³å®š
      const targetH = clamp(laneW * 0.62, 120, 220);      // é«˜ã•åŸºæº–ï¼ˆèª¿æ•´ã—ã‚„ã™ã„ï¼‰

      const scale = targetH / img.naturalHeight;
      const dw = img.naturalWidth * scale;
      const dh = img.naturalHeight * scale;

      // "è¶³å…ƒ"ã‚’ py + 28 ã«åˆã‚ã›ã‚‹ï¼ˆå½±ã¨æ•´åˆï¼‰
      const footY = 28;
      const dx = -dw / 2;
      const dy = -dh + footY;

      // ã»ã‚“ã®ã‚Šç¸å–ã‚Šï¼ˆèƒŒæ™¯ã«ãªã˜ã¾ã›ã‚‹ï¼‰
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.filter = "blur(1px)";
      ctx.drawImage(img, dx, dy, dw, dh);
      ctx.restore();

      ctx.drawImage(img, dx, dy, dw, dh);

    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆçµµæ–‡å­—ï¼‰
      ctx.font = "56px system-ui, Apple Color Emoji, Segoe UI Emoji";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ”", 0, -4);

      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(243,246,255,0.85)";
      ctx.fillText("æ¾æ‘", 0, 34);
    }

    // æ±—
    if (danger > 0.15){
      ctx.globalAlpha = 0.75 * danger;
      ctx.fillStyle = "rgba(96,165,250,0.9)";
      for (let i=0;i<3;i++){
        const dx = -18 + i*14;
        const dy = -28 + (i%2)*6;
        drop(dx, dy, 4 + i*0.6);
      }
    }
    ctx.restore();

    // çŠ¶æ…‹è¡¨ç¤ºï¼ˆå°ã•ã‚ï¼‰
    ctx.save();
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(243,246,255,0.65)";
    ctx.textAlign = "center";
    ctx.fillText(holding ? "æŠ¼ã—ã¦ã‚‹ï¼šä¸Šã¸" : "é›¢ã—ãŸï¼šä¸‹ã¸ï¼ˆãƒã‚­ã‚Šï¼‰", w/2, laneY + laneH + 2);
    ctx.restore();

    function drop(x,y,r){
      ctx.beginPath();
      ctx.moveTo(x, y-r);
      ctx.quadraticCurveTo(x+r, y, x, y+r);
      ctx.quadraticCurveTo(x-r, y, x, y-r);
      ctx.fill();
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // iOSï¼šãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ æŠ‘æ­¢ï¼ˆä¿é™ºï¼‰
  let lastTouch = 0;
  window.addEventListener("touchend", (e)=>{
    const now = Date.now();
    if (now - lastTouch <= 250) e.preventDefault();
    lastTouch = now;
  }, {passive:false});

  setMuted(false);
  updateHUD();
  draw();
  resetGame(true);
</script>
</body>
</html>
