<!doctype html>
<html lang="ja">
<head>
  <!-- OGP AUTO-GENERATED START (do not edit by hand) -->
  <meta property="og:title" content="ゲームウォッチ松村">
  <meta name="twitter:title" content="ゲームウォッチ松村">
  <meta property="og:description" content="G&amp;W DROP READY 操作： LEFT / RIGHT （← → / A D / 画面左右タップ） 落下物を避ける（3ミスで終了） LEFT RIGHT START / RESTART SOUND: ON SPEED: 1x">
  <meta name="twitter:description" content="G&amp;W DROP READY 操作： LEFT / RIGHT （← → / A D / 画面左右タップ） 落下物を避ける（3ミスで終了） LEFT RIGHT START / RESTART SOUND: ON SPEED: 1x">
  <meta property="og:image" content="/2026-01-15/assets/matsumura.png">
  <meta name="twitter:image" content="/2026-01-15/assets/matsumura.png">
  <meta property="og:url" content="/2026-01-15/">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <!-- OGP AUTO-GENERATED END -->

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#cfd9b7" />
  <title>ゲームウォッチ松村</title>
  <style>
    :root{
      --lcd:#cfd9b7;
      --lcd2:#b9c49e;
      --ink:#0e1b12;
      --r:18px;
      --shadow:0 18px 50px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%; background:#0b1020; overflow:hidden}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      color:#eaf0ff;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .wrap{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: max(14px, env(safe-area-inset-top)) 14px max(14px, env(safe-area-inset-bottom));
      gap:14px;
      flex-direction:column;
    }
    .cab{
      width:min(720px, 96vw);
      border-radius: calc(var(--r) + 10px);
      background: linear-gradient(180deg, #2b2f27, #12160f);
      box-shadow: var(--shadow);
      border:1px solid rgba(255,255,255,.08);
      padding:14px;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:6px 6px 10px;
      color:rgba(255,255,255,.8);
      font-size:12px; letter-spacing:.08em; text-transform:uppercase;
      user-select:none;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .lcd{
      background:
        radial-gradient(120% 160% at 20% 10%, rgba(255,255,255,.35), transparent 45%),
        linear-gradient(180deg, var(--lcd), var(--lcd2));
      border-radius: calc(var(--r) + 6px);
      border: 2px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.18), inset 0 22px 60px rgba(0,0,0,.18);
      padding:14px;
      position:relative;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      image-rendering: pixelated; /* ゲーム側はドット感 */
      border-radius: calc(var(--r) + 4px);
      background: transparent;
    }
    .hint{
      margin-top:10px;
      display:flex; gap:10px;
      align-items:center; justify-content:space-between;
      flex-wrap:wrap;
      color:rgba(255,255,255,.75);
      font-size:12px;
      user-select:none;
    }
    .controls{
      width:min(720px, 96vw);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .btn{
      border:none;
      border-radius: 16px;
      padding:16px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.10);
      color:#eaf0ff;
      font-weight:700;
      letter-spacing:.08em;
      text-transform:uppercase;
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
      user-select:none;
      touch-action: manipulation;
    }
    .btn:active{ transform: translateY(1px); }
    .row{
      width:min(720px, 96vw);
      display:flex; gap:10px;
      align-items:center; justify-content:space-between;
      flex-wrap:wrap;
    }
    .smallbtn{
      border:none;
      border-radius: 999px;
      padding:10px 12px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.9);
      font-weight:700;
      letter-spacing:.06em;
      user-select:none;
      touch-action: manipulation;
    }
    .smallbtn:active{ transform: translateY(1px); }

    @media (min-width: 860px){
      .wrap{ flex-direction:row; align-items:flex-start; }
      .cab{ width:min(560px, 52vw); }
      .right{ width:min(360px, 40vw); display:flex; flex-direction:column; gap:12px; }
      .controls{ width:100%; }
      .row{ width:100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="cab">
      <div class="topbar">
        <div class="pill">G&W DROP</div>
        <div class="pill" id="status">READY</div>
      </div>

      <div class="lcd">
        <canvas id="c" width="240" height="200" aria-label="game"></canvas>
      </div>

      <div class="hint">
        <div>操作：<b>LEFT / RIGHT</b>（← → / A D / 画面左右タップ）</div>
        <div>落下物を避ける（3ミスで終了）</div>
      </div>
    </div>

    <div class="right">
      <div class="controls">
        <button class="btn" id="leftBtn">LEFT</button>
        <button class="btn" id="rightBtn">RIGHT</button>
      </div>

      <div class="row">
        <button class="smallbtn" id="startBtn">START / RESTART</button>
        <button class="smallbtn" id="soundBtn">SOUND: ON</button>
        <button class="smallbtn" id="speedBtn">SPEED: 1x</button>
      </div>

      <div class="hint" style="width:100%; margin-top:0">

      </div>
    </div>
  </div>

  <script type="module">
    // 1日1アプリ規約：動的アセット用ヘルパ（Vercelルーティング対応）
    const DATE_SEGMENT = (location.pathname.match(/\d{4}-\d{2}-\d{2}/) || [""])[0];
    const DATE_BASE = DATE_SEGMENT ? `/${DATE_SEGMENT}/` : "/";
    const asset = (p) => {
      const clean = String(p || "").replace(/^\.?\//, "");
      return `${DATE_BASE}${clean}`;
    };

    const cvs = document.getElementById('c');
    const ctx = cvs.getContext('2d', { alpha:true });
    ctx.imageSmoothingEnabled = false; // ゲーム側

    const statusEl = document.getElementById('status');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const startBtn = document.getElementById('startBtn');
    const soundBtn = document.getElementById('soundBtn');
    const speedBtn = document.getElementById('speedBtn');

    // ===== AUDIO (beeps only) =====
    let audioOK = true;
    let ac = null;
    function ensureAudio(){
      if(!audioOK) return;
      if(!ac) ac = new (window.AudioContext || window.webkitAudioContext)();
      if(ac.state === "suspended") ac.resume().catch(()=>{});
    }
    function beep(freq=880, dur=0.05, type="square", gain=0.04){
      if(!audioOK) return;
      ensureAudio();
      if(!ac) return;
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(ac.destination);
      o.start();
      o.stop(ac.currentTime + dur);
    }
    const sMove = ()=>beep(980, 0.035, "square", 0.035);
    const sTick = ()=>beep(520, 0.018, "square", 0.020);
    const sBad  = ()=>beep(160, 0.12, "square", 0.05);
    const sStart= ()=>beep(720, 0.06, "square", 0.04);

    // ===== GAME =====
    const W=240,H=200;
    const INK="#0e1b12";

    const LANES = 4;
    const LANE_X = [34, 74, 114, 154];
    const FLOOR_Y = 160;

    const SPEEDS=[1.0, 1.35, 1.75];
    let speedIdx=0;
    const BASE_TICK_MS=125;

    const objs = []; // {lane, y, kind}
    let spawnCounter = 0;

    let running=false, over=false;
    let score=0, miss=0;
    let lane=1;

    // ===== Matsumura (plain photo, no effects) =====
    const mImg = new Image();
    mImg.src = asset("./assets/matsumura.png");
    let mReady=false;
    mImg.onload = ()=>{ mReady=true; draw(); };
    mImg.onerror = ()=>{ mReady=false; draw(); };

    function reset(){
      objs.length=0;
      spawnCounter=0;
      score=0; miss=0;
      lane=1;
    }

    function setStatus(){
      statusEl.textContent = over ? "GAME OVER" : (running ? "PLAY" : "READY");
    }

    let timer=null;
    function restartTimer(){
      stopTimer();
      const ms = Math.round(BASE_TICK_MS / SPEEDS[speedIdx]);
      timer = setInterval(tick, ms);
    }
    function stopTimer(){
      if(timer){ clearInterval(timer); timer=null; }
    }

    function start(){
      ensureAudio();
      reset();
      running=true; over=false;
      setStatus();
      sStart();
      draw();
      restartTimer();
    }

    function end(){
      running=false; over=true;
      setStatus();
      draw();
      stopTimer();
      sBad();
    }

    function spawn(){
      const baseGap = 6;
      const minGap  = 2;
      const gap = Math.max(minGap, baseGap - Math.floor(score/22));
      if(spawnCounter % gap !== 0) return;

      const last = objs.length ? objs[objs.length-1].lane : -1;
      let ln = (Math.random()*LANES)|0;
      if(ln === last && Math.random()<0.65) ln = (ln+1+((Math.random()*2)|0))%LANES;

      const kind = (Math.random()<0.25) ? 1 : 0;
      // 少し上から落ち始めるようにオフセットを下げる
      objs.push({ lane: ln, y: 32, kind });
    }

    function collide(obj){
      // player box（描画に合わせて縦長 / 中央基準）
      const pw = 24, ph = 36;
      const px = LANE_X[lane] - pw/2;
      const py = FLOOR_Y - ph;

      const ox = LANE_X[obj.lane] + 3;
      const oy = obj.y;
      const ow = 18, oh = 18;

      return !(px+pw < ox || ox+ow < px || py+ph < oy || oy+oh < py);
    }

    function tick(){
      if(!running) return;

      spawnCounter++;
      spawn();

      const fall = 10;
      for(const ob of objs) ob.y += fall;

      for(let i=objs.length-1;i>=0;i--){
        const ob = objs[i];

        if(ob.lane === lane && collide(ob)){
          miss++;
          objs.splice(i,1);
          sBad();
          if(miss>=3){ end(); return; }
          continue;
        }

        if(ob.y > FLOOR_Y+6){
          objs.splice(i,1);
          score++;
          sTick();
        }
      }

      draw();
    }

    function move(dir){
      if(!running || over) return;
      const nl = Math.max(0, Math.min(LANES-1, lane+dir));
      if(nl===lane) return;
      lane = nl;
      sMove();
      draw();
    }

    // ===== DRAW =====
    function clear(){ ctx.clearRect(0,0,W,H); }
    function pix(x,y,w,h){ ctx.fillRect(x|0,y|0,w|0,h|0); }
    function textLCD(s,x,y,scale=1){
      ctx.save();
      ctx.fillStyle=INK;
      ctx.font = `${10*scale}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
      ctx.fillText(s,x,y);
      ctx.restore();
    }

    function drawHUD(){
      textLCD(`SCORE ${String(score).padStart(4,"0")}`, 10, 18, 1.1);
      textLCD(`MISS ${miss}`, 178, 18, 1.1);

      if(!running && !over){
        textLCD("PRESS START", 70, 78, 1.2);
      }
      if(over){
        textLCD("GAME OVER", 78, 78, 1.4);
        textLCD("START TO RETRY", 58, 100, 1.0);
      }
      if(running){
        textLCD("AVOID!", 106, 44, 1.0);
      }
    }

    function drawLaneMarks(){
      ctx.fillStyle=INK;
      pix(0, FLOOR_Y, W, 2);
      for(let i=0;i<LANES;i++){
        const x = LANE_X[i] + 6;
        pix(x, FLOOR_Y+4, 10, 2);
        pix(x+4, FLOOR_Y+7, 2, 2);
      }
    }

    function drawFalling(){
      ctx.fillStyle=INK;
      for(const ob of objs){
        const x = LANE_X[ob.lane] + 2;
        const y = ob.y|0;

        if(ob.kind===0){
          pix(x, y, 18, 18);
          pix(x+6, y+6, 6, 6);
        }else{
          pix(x, y, 18, 18);
          pix(x+2, y-4, 14, 4);
          pix(x+6, y-8, 6, 4);
        }
      }
    }

    // 松村：完全にそのまま（枠/反射/クリアなど一切なし）
    function drawMatsumura(){
      const baseX = LANE_X[lane];
      const baseY = FLOOR_Y; // 足元を床ラインに合わせる

      if(mReady){
        // 写真だけは通常描画（スムージングON）
        ctx.save();
        ctx.imageSmoothingEnabled = true;

        const sw = mImg.width, sh = mImg.height;
        const dw = 24;
        const dh = 36; // 表示枠（縦長）

        // アスペクト比を保ったまま「全身」が収まるようにフィット
        const scale = Math.min(dw / sw, dh / sh);
        const rw = sw * scale;
        const rh = sh * scale;

        // 底辺を床に合わせつつ、左右中央寄せ
        const dx = baseX - rw / 2;
        const dy = baseY - rh;

        ctx.drawImage(mImg, 0, 0, sw, sh, dx, dy, rw, rh);
        ctx.restore();
      }else{
        // fallback（同じ基準位置に縦長ダミー）
        ctx.fillStyle = INK;
        const dw = 24;
        const dh = 36;
        const dx = baseX - dw / 2;
        const dy = baseY - dh;
        pix(dx, dy, dw, dh);
        textLCD("M", dx+8, dy+20, 1.2);
      }
    }

    function draw(){
      clear();
      ctx.fillStyle=INK;
      drawHUD();
      drawLaneMarks();
      drawFalling();
      drawMatsumura();
    }

    // ===== INPUT =====
    leftBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); move(-1); });
    rightBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); move(1); });

    cvs.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const r=cvs.getBoundingClientRect();
      const x=e.clientX-r.left;
      move(x<r.width/2 ? -1 : 1);
    });

    startBtn.addEventListener('click', ()=>start());

    soundBtn.addEventListener('click', ()=>{
      audioOK=!audioOK;
      soundBtn.textContent=`SOUND: ${audioOK?"ON":"OFF"}`;
      if(audioOK) ensureAudio();
    });

    speedBtn.addEventListener('click', ()=>{
      speedIdx=(speedIdx+1)%SPEEDS.length;
      speedBtn.textContent = `SPEED: ${speedIdx===0?"1x":(speedIdx===1?"1.35x":"1.75x")}`;
      if(running) restartTimer();
    });

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==="arrowleft"||k==="a"){ e.preventDefault(); move(-1); }
      if(k==="arrowright"||k==="d"){ e.preventDefault(); move(1); }
      if(k===" "||k==="enter"){ e.preventDefault(); start(); }
    }, {passive:false});

    // iOS double-tap zoom mitigation
    let lastTouch=0;
    document.addEventListener('touchend', (e)=>{
      const now=Date.now();
      if(now-lastTouch<=280) e.preventDefault();
      lastTouch=now;
    }, {passive:false});

    setStatus();
    draw();
  </script>
</body>
</html>
