<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ãƒãƒ„ãƒ ãƒ©ãƒ³</title>
<style>
:root{--bg:#0e0f12;--fg:#f6f7fb;--acc:#38bdf8;--muted:#9aa0a6;--safe-bottom: env(safe-area-inset-bottom, 0px);}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{
  height:100%;margin:0;background:var(--bg);color:var(--fg);
  font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
  overflow:hidden; overscroll-behavior:none;
}
canvas{image-rendering:pixelated;image-rendering:crisp-edges; touch-action:none;}
.wrap{display:flex;flex-direction:column;height:calc(var(--vh, 1vh) * 100);padding-bottom:var(--safe-bottom)}
header{padding:10px 12px;display:flex;gap:10px;align-items:center;position:relative;z-index:10}
.btn{
  border:1px solid #2a2d35;background:#171a1f;color:var(--fg);
  padding:10px 14px;border-radius:14px;cursor:pointer;font-weight:700; touch-action:manipulation;
}
.btn:active{transform:translateY(1px)}
.meta{margin-left:auto;display:flex;gap:12px;align-items:center;font-size:12px;color:var(--muted)}
.canvas-wrap{position:relative;flex:1;min-height:420px}
canvas{position:absolute;inset:0;width:100%;height:100%}
.overlay{position:absolute;inset:0;display:grid;place-items:center;
background:linear-gradient(180deg,#0b0d1188,#0b0d11dd);backdrop-filter:blur(1.5px)}
.hidden{display:none}
.big{text-align:center}
.big h1{font-size:clamp(28px,6vw,64px);margin:0 0 6px;text-shadow:0 6px 30px #0008}
.sub{font-size:clamp(13px,2.2vw,18px);opacity:.9}
.hud{position:absolute;right:10px;top:10px;font-size:14px;opacity:.9;background:#0b0d1299;padding:6px 10px;border-radius:10px}
.hint{position:absolute;left:50%;bottom:calc(var(--safe-bottom, 0px) + 14px);translate:-50% 0;font-size:12px;opacity:.9;background:#0b0d1299;padding:6px 10px;border-radius:10px}

/* ã‚¹ãƒãƒ›å‘ã‘æ‹¡å¤§ */
@media (max-width: 768px){
  header{padding:12px}
  .btn{padding:12px 16px; font-size:16px; border-radius:16px}
  .hud{font-size:15px}
  .hint{font-size:13px}
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <button id="startBtn" class="btn">â–¶ï¸ ã‚¹ã‚¿ãƒ¼ãƒˆ / ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button id="muteBtn" class="btn">ğŸ”ˆ ã‚µã‚¦ãƒ³ãƒ‰ON</button>
    <div class="meta">
      <span id="meters">0 m</span>
    </div>
  </header>

  <div class="canvas-wrap" id="stage">
    <canvas id="game"></canvas>

    <div id="startOverlay" class="overlay">
      <div class="big">
        <h1>ä¸Šã‚’å‘ã„ã¦æ­©ã“ã†ãƒ©ãƒ³</h1>
        <div class="sub">ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã§ã‚¸ãƒ£ãƒ³ãƒ—ã€‚ã©ã“ã¾ã§è¡Œã‘ã‚‹ã‹ç«¶ãŠã†ã€‚</div>
      </div>
    </div>
    <div id="deadOverlay" class="overlay hidden">
      <div class="big">
        <h1 style="color:#fca5a5">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1>
        <div class="sub">ã¶ã¤ã‹ã£ã¡ã‚ƒã£ãŸâ€¦ï¼ˆå†æŒ‘æˆ¦ã¯ä¸Šã®ãƒœã‚¿ãƒ³ï¼‰</div>
      </div>
    </div>

    <div id="orientOverlay" class="overlay hidden">
      <div class="big">
        <h1>æ¨ªå‘ãå°‚ç”¨</h1>
        <div class="sub">ã‚¹ãƒãƒ›ã¯æ¨ªã«å›è»¢ã—ã¦ãƒ—ãƒ¬ã‚¤ã—ã¦ãã ã•ã„ã€‚</div>
      </div>
    </div>

    <div class="hud" id="hud">è·é›¢: 0m / ãƒ™ã‚¹ãƒˆ: 0m</div>
    <div class="hint">ç”»é¢ã©ã“ã§ã‚‚ã‚¿ãƒƒãƒ—ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆé•·æŠ¼ã—ã§é«˜ãï¼‰<br>â€»Dã‚­ãƒ¼ã§å½“ãŸã‚Šåˆ¤å®šè¡¨ç¤ºON/OFF</div>
  </div>
</div>

<script>
(() => {
  const cvs=document.getElementById('game');
  const ctx=cvs.getContext('2d');
  const wrap=document.getElementById('stage');
  const startBtn=document.getElementById('startBtn');
  const muteBtn=document.getElementById('muteBtn');
  const metersEl=document.getElementById('meters');
  const hudEl=document.getElementById('hud');
  const startOv=document.getElementById('startOverlay');
  const deadOv=document.getElementById('deadOverlay');
  const orientOv=document.getElementById('orientOverlay');

  // ===== ç”»é¢ã‚µã‚¤ã‚º =====
  let W=0,H=0,DPR=1;
  function isMobile(){ return /iPhone|Android.+Mobile|Windows Phone|webOS|BlackBerry/i.test(navigator.userAgent); }
  function updateVh(){
    const usableH = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
    const vh = usableH * 0.01;
    document.documentElement.style.setProperty('--vh', vh + 'px');
  }
  // ===== ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå‰æ–¹å®£è¨€ï¼ˆresizeã‚ˆã‚Šå‰ã«å®£è¨€ã—ã¦TDZå›é¿ï¼‰ =====
  let spriteReady=false;
  let FRAME_W=32,FRAME_H=48,FRAMES=4,SCALE=3;
  function recomputeScale(){
    const isLandscape = (window.innerWidth >= window.innerHeight);
    const baseFrameH = FRAME_H || 48;
    const targetH = (isMobile() && isLandscape)
      ? Math.max(14, Math.min(Math.floor(H*0.05), Math.round(PLAYER_BOX.h*0.85)))
      : Math.round(PLAYER_BOX.h*1.2);
    let s = targetH / baseFrameH;
    if (isMobile() && isLandscape) {
      s = Math.max(0.4, Math.min(0.9, s));
    } else {
      s = Math.max(1.0, Math.min(3.0, s));
    }
    SCALE = s;
  }
  function resize(){
    updateVh();
    const cap = isMobile() ? 1.5 : 2;
    DPR=Math.min(cap,window.devicePixelRatio||1);
    // Fallback to viewport size if client size is temporarily 0 (e.g., during orientation changes)
    const vwW = window.innerWidth || 1;
    const vvH = (window.visualViewport && window.visualViewport.height) || window.innerHeight || 1;
    const cw = wrap.clientWidth || vwW;
    const ch = wrap.clientHeight || vvH;
    W=cw; H=ch;
    // Ground height: make the ground band taller on mobile landscape to reduce sky area
    const landscape = (window.innerWidth >= window.innerHeight);
    GND_H = (isMobile() && landscape) ? Math.max(GND_BASE, Math.floor(H * 0.18)) : GND_BASE;
    cvs.width=Math.floor(W*DPR); cvs.height=Math.floor(H*DPR);
    cvs.style.width=W+'px'; cvs.style.height=H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    updateOrientation();
    recomputeScale();
  }
  addEventListener('resize',resize,{passive:true});
  addEventListener('orientationchange',()=>{ setTimeout(resize, 0); },{passive:true});
  // åˆæœŸvhè¨­å®š
  updateVh();

  let orientationBlocked=false;
  function updateOrientation(){
    const isLandscape = (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) || (window.innerWidth >= window.innerHeight);
    orientationBlocked = isMobile() && !isLandscape;
    orientOv.classList.toggle('hidden', !orientationBlocked);
    // ãƒœã‚¿ãƒ³ã¯å¸¸ã«æŠ¼ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼ˆãƒãƒ¼ãƒˆãƒ¬ãƒ¼ãƒˆæ™‚ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã§æ¡ˆå†…ï¼‰
    startBtn.disabled = false;
  }
  // åˆæœŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåæ˜ ã¯ã€PLAYER_BOX å®šç¾©å¾Œã«å®Ÿè¡Œï¼ˆTDZå›é¿ï¼‰

  // ===== ã‚µã‚¦ãƒ³ãƒ‰ =====
  const seGoal=new Audio();
  seGoal.src='data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAA';
  let muted=false;
  // é…ä¿¡ç’°å¢ƒã§ç¢ºå®Ÿã«è§£æ±ºã§ãã‚‹ã‚ˆã†ã‚¢ã‚»ãƒƒãƒˆåŸºæº–ãƒ‘ã‚¹ã‚’çµ±ä¸€
  const ASSET_BASE = '/apps/2025-10-15/';
  // BGMï¼ˆåŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã« bgm.mp3 ã‚’é…ç½®ã—ã¦ãã ã•ã„ï¼‰
  const bgm = new Audio(ASSET_BASE + 'bgm.mp3');
  bgm.loop = true;
  bgm.volume = 0.35;
  bgm.preload = 'auto';
  bgm.addEventListener('error', ()=>{
    console.error('[BGM] Failed to load', bgm.currentSrc || bgm.src);
  });
  muteBtn.onclick=()=>{muted=!muted;muteBtn.textContent=muted?'ğŸ”‡ ã‚µã‚¦ãƒ³ãƒ‰OFF':'ğŸ”ˆ ã‚µã‚¦ãƒ³ãƒ‰ON';
    if(muted){ try{ bgm.pause(); }catch(_){} } else { if(state==='playing') { bgm.play().catch(()=>{}); } }
  };

  // ===== ç‰©ç†å®šæ•° =====
  const G=2000;
  const RUN_BASE=230;
  const RUN_BOOST=90;
  const JUMP_VY=-720;
  const HOLD_BONUS=-260;
  const GND_BASE=72;
  let GND_H=GND_BASE;

  // éšœå®³ç‰©ç”Ÿæˆç¯„å›²
  const OBSTACLE_BASE_INTERVAL=150;
  const OBSTACLE_VAR_INTERVAL=120;
  const SPAWN_NEAR= W => Math.max(80, W*0.20);
  const SPAWN_FAR = W => Math.max(420, W*0.85);

  // å½“ãŸã‚Šåˆ¤å®šï¼ˆç”˜ã‚ï¼‰
  const PLAYER_BOX = { w: 28, h: 40, offsetX: -2, offsetY: 6 };
  let BEST_DIST=Number(localStorage.getItem("bestDist")||0);
  // åˆæœŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåæ˜ ï¼ˆå¿…è¦ãªä¾å­˜ãŒæƒã£ãŸå¾Œã«å®Ÿè¡Œï¼‰
  resize();

  // ===== ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ =====
  const sprite=new Image();
  sprite.src=ASSET_BASE + 'sprite.png';
  // spriteReady / FRAME_* / recomputeScale are declared above to avoid TDZ
  sprite.onload=()=>{
    spriteReady=true;
    FRAME_W=Math.floor(sprite.width/FRAMES);
    FRAME_H=sprite.height;
    recomputeScale();
  };
  sprite.onerror=()=>{
    console.error('[Sprite] Failed to load', sprite.currentSrc || sprite.src);
  };

  // ===== éšœå®³ç‰©ç”»åƒï¼ˆob1.pngã€œob4.pngï¼‰èª­ã¿è¾¼ã¿ =====
  const obstacleImgs = [];
  for(let i=1;i<=4;i++){
    const img = new Image();
    img.src = ASSET_BASE + `ob${i}.png`;
    obstacleImgs.push(img);
  }
  ctx.imageSmoothingEnabled=false;
  let animTime=0;
  let DEBUG_HITBOX=false; // â† ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰

  // ===== RNG =====
  let seed=20251015;
  const rnd=()=> (seed=(seed*16807)%2147483647)/2147483647;

  // ===== ãƒ¯ãƒ¼ãƒ«ãƒ‰ =====
  let state='idle';
  const world={ camX:0, dist:0, obs:[], spawnX:0 };
  const ply={ x:isMobile()?W*0.25:84, y:H-GND_H-PLAYER_BOX.h, vy:0, onG:true };
  let stars=[];

  // èƒŒæ™¯
  function initScenery(){
    stars=[];
    const count=Math.floor((W*H)/9000);
    for(let i=0;i<count;i++){
      stars.push({x:rnd()*100000,y:Math.floor(rnd()*Math.max(80,H*0.45)),s:(rnd()<0.85?1:2)});
    }
  }

  function reset(){
    resize();
    seed=Date.now()%1e9;
    state='playing';
    world.camX=0; world.dist=0; world.obs.length=0; world.spawnX=0;
    ply.x=isMobile()?W*0.25:84; ply.y=H-GND_H-PLAYER_BOX.h; ply.vy=0; ply.onG=true;
    startOv.classList.add('hidden'); deadOv.classList.add('hidden');
    initScenery();
    spawnMoreObstacles(1,true);
    tPrev=performance.now();
  }

  // ===== éšœå®³ç‰©ç”Ÿæˆ =====
  function spawnMoreObstacles(diff=1, forceKick=false){
    const near = world.camX + SPAWN_NEAR(W);
    const far  = world.camX + SPAWN_FAR(W);
    if (world.spawnX < near || forceKick) world.spawnX = near - 40;
    const untilX = far;
    const lerp = (a,b,t)=> a + (b-a)*t;
    const OB_KIND_COUNT = 4;
    while (world.spawnX < untilX) {
      const baseInterval = OBSTACLE_BASE_INTERVAL + rnd()*OBSTACLE_VAR_INTERVAL;
      const interval = Math.max(40, baseInterval / diff);
      world.spawnX += interval;
      let ox = world.spawnX + (rnd()*140 - 70);
      const doBias = rnd() < (isMobile() ? 0.3 : 0.5);
      if (doBias) {
        const centerX = world.camX + ply.x;
        const bias = isMobile() ? 0.25 : 0.45;
        ox = lerp(ox, centerX, bias) + (rnd()*60 - 30);
      }
      const minX = world.camX + 24;
      const maxX = world.camX + W - 24;
      ox = Math.min(maxX, Math.max(minX, ox));
      const size = 22 + Math.floor(rnd()*44);
      // ãƒ¢ãƒã‚¤ãƒ«æ¨ªå‘ãã§ã¯å°‘ã—å°ã•ã‚ã«ã—ã¦è¦–èªæ€§ã‚’ç¢ºä¿
      const sizeAdj = (isMobile() && (window.innerWidth >= window.innerHeight)) ? 0.85 : 1.0;
      const finalSize = Math.max(12, Math.floor(size * sizeAdj));
      const fall = (140 + rnd()*220) * diff;
      const y0 = -140 + (-rnd()*260);
      // ã‚µã‚¤ã‚ºå¸¯ã«å¿œã˜ã¦ç”»åƒç¨®åˆ¥ã‚’é¸æŠï¼ˆ0:å°, 1:ä¸­, 2:å¤§, 3:ç‰¹å¤§ï¼‰
      const kind = (finalSize <= 28) ? 0 : (finalSize <= 40) ? 1 : (finalSize <= 56) ? 2 : 3;
      world.obs.push({
        x: ox, y: y0, w: finalSize, h: finalSize, vy: fall, k: kind,
        c: pick(['#93c5fd','#fca5a5','#fcd34d','#86efac','#fbbf24'])
      });
    }
    function pick(arr){ return arr[Math.floor(rnd()*arr.length)]; }
  }

  // ===== å…¥åŠ› =====
  let holding=false,holdT=0;
  const jumpStart=()=>{ if(state!=='playing')return; if(ply.onG){ ply.vy=JUMP_VY; ply.onG=false; holding=true; holdT=0; } };
  const jumpEnd=()=> holding=false;

  wrap.addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});
  wrap.addEventListener('pointerdown', e=>{ if(e.target===startBtn) return; e.preventDefault(); jumpStart(); }, {passive:false});
  wrap.addEventListener('pointerup', e=>{ if(e.target===startBtn) return; e.preventDefault(); jumpEnd(); }, {passive:false});
  addEventListener('keydown', e=>{
    if(e.code==='Space'||e.code==='ArrowUp') jumpStart();
    if(e.code==='KeyM'){ muted=!muted; muteBtn.textContent = muted ? 'ğŸ”‡ ã‚µã‚¦ãƒ³ãƒ‰OFF' : 'ğŸ”ˆ ã‚µã‚¦ãƒ³ãƒ‰ON'; }
    if(e.code==='KeyD'){ DEBUG_HITBOX=!DEBUG_HITBOX; console.log("Debug:",DEBUG_HITBOX); }
  });
  addEventListener('keyup', e=>{ if(e.code==='Space'||e.code==='ArrowUp') jumpEnd(); });

  // ===== ãƒ«ãƒ¼ãƒ— =====
  let tPrev=0;
  function loop(tNow){
    const dt=Math.min(0.032,(tNow-tPrev)/1000||0.016); tPrev=tNow;
    if(state==='playing') update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt){
    if(orientationBlocked){ orientOv.classList.remove('hidden'); return; }
    const dist=world.dist;
    const diffFactor=1+Math.min(1.5, dist/10000);
    const runSpeed=(RUN_BASE+RUN_BOOST*0.6)*diffFactor;
    world.dist += runSpeed*dt;
    const camOffset = isMobile() ? W * 0.22 : 120;
    world.camX = world.dist - camOffset;
    spawnMoreObstacles(diffFactor);

    if(!ply.onG){
      if(holding && holdT<0.12){ ply.vy += HOLD_BONUS*dt*6; holdT += dt; }
      ply.vy += G * dt * diffFactor;
    }
    ply.y += ply.vy*dt;
    const groundY = H - GND_H - PLAYER_BOX.h;
    if(ply.y>=groundY){ ply.y=groundY; ply.vy=0; ply.onG=true; }

    for(const o of world.obs){
      o.y += o.vy * dt * diffFactor;
      if(intersect(ply.x, ply.y, PLAYER_BOX.w, PLAYER_BOX.h, o.x - world.camX, o.y, o.w, o.h)){
        state='dead';
        deadOv.classList.remove('hidden');
        const thisDist = Math.floor(world.dist);
        if(thisDist > BEST_DIST){ BEST_DIST = thisDist; localStorage.setItem("bestDist", BEST_DIST); }
        deadOv.innerHTML = `
          <div class="big">
            <h1 style="color:#fca5a5">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1>
            <div class="sub" style="font-size:18px; margin-top:8px;">
              ä»Šå›ã®è·é›¢ï¼š<b style="font-size:22px; color:#fcd34d;">${thisDist}m</b><br>
              ãƒ™ã‚¹ãƒˆè·é›¢ï¼š<b style="color:#38bdf8;">${BEST_DIST}m</b>
            </div>
            <div class="sub" style="margin-top:10px;">ä¸Šã®ãƒœã‚¿ãƒ³ã§å†æŒ‘æˆ¦</div>
          </div>`;
        if(!muted){ seGoal.currentTime=0; seGoal.play().catch(()=>{}); }
        break;
      }
    }
    metersEl.textContent = Math.floor(world.dist) + " m";
    hudEl.textContent = `è·é›¢: ${Math.floor(world.dist)}m / ãƒ™ã‚¹ãƒˆ: ${BEST_DIST}m`;
    animTime += dt * (ply.onG?8:6);
  }

  function intersect(ax, ay, aw, ah, bx, by, bw, bh){
  // ax,ay ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è«–ç†åº§æ¨™ï¼ˆå·¦ä¸Šï¼‰ã€‚ã¾ãšå®Ÿãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—
  const hb = getPlayerHitbox(ax, ay);
  return (
    hb.x < bx + bw &&
    hb.x + hb.w > bx &&
    hb.y < by + bh &&
    hb.y + hb.h > by
  );
}


// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”»çŸ©å½¢ -> å½“ãŸã‚ŠçŸ©å½¢ã‚’å°å‡º
function getPlayerHitbox(px, py){
  // 0-1ã«åã‚ã‚‹å°é“å…·
  const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
  const lerp  = (a,b,t)=> a + (b-a)*t;

  // æç”»ã¨åŒã˜å€¤
  const dw = spriteReady ? FRAME_W * SCALE : PLAYER_BOX.w;
  const dh = spriteReady ? FRAME_H * SCALE : PLAYER_BOX.h;
  const drawX = px - (dw - PLAYER_BOX.w) / 2;
  const drawY = py + PLAYER_BOX.h - dh;

  // é›£æ˜“åº¦ã®é€²è¡Œï¼šè·é›¢4,000mã§å¾ã€…ã«ãƒãƒ¼ãƒãƒ«ã¸ï¼ˆå¥½ã¿ã§è·é›¢å¤‰æ›´OKï¼‰
  const t = clamp(world.dist / 4000, 0, 1);

  // ä½™ç™½ç‡ï¼ˆåºç›¤ã¯ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’ã‹ãªã‚Šå°ã•ãã€é€²ã‚€ã»ã©å°‘ã—å¤§ããï¼‰
  //           E A S Y             â†’           N O R M A L
  const mx       = lerp(dw * 0.44,               dw * 0.36,               t); // å·¦å³ãƒãƒ¼ã‚¸ãƒ³ï¼ˆå°ã•ã‚å½“ãŸã‚Šï¼‰
  const myTop    = lerp(dh * 0.40,               dh * 0.30,               t); // ä¸Šãƒãƒ¼ã‚¸ãƒ³ï¼ˆå°ã•ã‚å½“ãŸã‚Šï¼‰
  const myBottom = lerp(dh * 0.26,               dh * 0.18,               t); // ä¸‹ãƒãƒ¼ã‚¸ãƒ³ï¼ˆå°ã•ã‚å½“ãŸã‚Šï¼‰

  const x = drawX + mx;
  const w = Math.max(2, dw - mx*2);
  const baseH = Math.max(2, dh - myTop - myBottom);
  const h = Math.max(2, Math.floor(baseH * 0.6));
  const y = drawY + myTop + Math.floor((baseH - h) / 2); // ä¸­å¤®å¯„ã›
  return { x, y, w, h };
}

  // ===== æç”» =====
  function render(){
    ctx.clearRect(0,0,W,H);
    drawAutumnNight();

    // éšœå®³ç‰©
    for(const o of world.obs){
      const sx=o.x-world.camX; if(sx<-120||sx>W+120) continue;
      const k = o.k || 0;
      const obImg = obstacleImgs[k];
      if (obImg && obImg.complete && obImg.naturalWidth > 0) {
        // å„ªå…ˆï¼šå€‹åˆ¥ç”»åƒã§æç”»
        ctx.imageSmoothingEnabled=false;
        ctx.drawImage(obImg, sx, o.y, o.w, o.h);
        ctx.imageSmoothingEnabled=true;
      } else if (spriteReady) {
        // æ¬¡ç‚¹ï¼šã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ãƒ•ãƒ¬ãƒ¼ãƒ  0-3 ã‚’ä½¿ç”¨
        const sX = (k % 4) * FRAME_W;
        ctx.imageSmoothingEnabled=false;
        ctx.drawImage(sprite, sX, 0, FRAME_W, FRAME_H, sx, o.y, o.w, o.h);
        ctx.imageSmoothingEnabled=true;
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šè‰²çŸ©å½¢
        ctx.fillStyle=o.c; ctx.fillRect(sx,o.y,o.w,o.h);
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    const px=ply.x, py=ply.y;
    ctx.globalAlpha=0.22;
    ctx.beginPath(); ctx.ellipse(px+PLAYER_BOX.w/2, H-GND_H+6, 24,6,0,0,Math.PI*2);
    ctx.fillStyle='#000'; ctx.fill(); ctx.globalAlpha=1;

    if(spriteReady){
      ctx.imageSmoothingEnabled=false;
      const frame=Math.floor(animTime)%FRAMES;
      const sx=frame*FRAME_W, sy=0;
      const dw=FRAME_W*SCALE, dh=FRAME_H*SCALE;
      const drawX=px-(dw-PLAYER_BOX.w)/2;
      const drawY=py+PLAYER_BOX.h-dh;
      ctx.drawImage(sprite, sx, sy, FRAME_W, FRAME_H, drawX, drawY, dw, dh);
      ctx.imageSmoothingEnabled=true;
    } else {
      ctx.fillStyle='#38bdf8'; ctx.fillRect(px,py,PLAYER_BOX.w,PLAYER_BOX.h);
    }

    // ===== ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹å¯è¦–åŒ– =====
    if (DEBUG_HITBOX) {
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆèµ¤ï¼‰
  const hb = getPlayerHitbox(px, py);
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 1;
  ctx.strokeRect(hb.x, hb.y, hb.w, hb.h);

  // éšœå®³ç‰©ï¼ˆç·‘ï¼‰
  ctx.strokeStyle = '#00ff00';
  for (const o of world.obs) {
    const sx = o.x - world.camX;
    if (sx < -120 || sx > W + 120) continue;
    ctx.strokeRect(sx, o.y, o.w, o.h);
  }
}


  }

  // ===== èƒŒæ™¯æç”» =====
  function drawAutumnNight(){
    if (W <= 0 || H <= 0) return;
    const sky=ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#0a0e26'); sky.addColorStop(0.6,'#0b1020'); sky.addColorStop(1,'#0a0d14');
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#e5e7eb';
    for(const st of stars){
      const sx=st.x-world.camX*0.2;
      const px=((sx%100000)+100000)%W;
      if(px<-2||px>W+2) continue;
      ctx.fillRect(Math.floor(px),st.y,st.s,st.s);
    }
    const moonX=Math.floor(W*0.78), moonY=Math.floor(H*0.18);
    ctx.fillStyle='#fde68a'; ctx.beginPath(); ctx.arc(moonX,moonY,10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#0a0e26'; ctx.beginPath(); ctx.arc(moonX+4,moonY-2,10,0,Math.PI*2); ctx.fill();
    const baseY1=Math.floor(H*0.62);
    ctx.fillStyle='#0c1326';
    for(let x=-((world.camX*0.35)%120);x<W;x+=120){
      const h=12+Math.floor(Math.sin((x+world.camX*0.1)/90)*8);
      ctx.fillRect(x,baseY1-h,80,h);
    }
    const baseY2=H-GND_H-10;
    for(let x=-((world.camX*0.6)%90);x<W;x+=90){
      ctx.fillStyle='#1f2937'; ctx.fillRect(x+40,baseY2-22,4,22);
      const leafCol=['#f59e0b','#ef4444','#d97706'][((x/90)&3)%3];
      ctx.fillStyle=leafCol;
      ctx.fillRect(x+34,baseY2-30,4,4);
      ctx.fillRect(x+38,baseY2-26,6,5);
      ctx.fillRect(x+46,baseY2-30,5,5);
      ctx.fillRect(x+42,baseY2-33,4,4);
    }
    for(let x=-((world.camX)%220);x<W;x+=220){
      const poleX=x+20;
      ctx.fillStyle='#20252e'; ctx.fillRect(poleX,H-GND_H-50,3,50);
      ctx.fillStyle='#fcd34d'; ctx.fillRect(poleX-3,H-GND_H-52,9,6);
      ctx.globalAlpha=0.15;
      ctx.beginPath(); ctx.ellipse(poleX+1, H-GND_H-48, 26,10,0,0,Math.PI*2);
      ctx.fillStyle='#fcd34d'; ctx.fill(); ctx.globalAlpha=1;
    }
    ctx.fillStyle='#11161d'; ctx.fillRect(0,H-GND_H,W,GND_H);
    ctx.fillStyle='#fbbf24';
    for(let x=-((world.camX)%50);x<W;x+=50){ ctx.fillRect(x,H-GND_H+22,22,3); }
  }

  const onStart = (e)=>{
    e && e.preventDefault();
    startBtn.textContent = 'â³ æº–å‚™ä¸­...';
    setTimeout(()=>{ startBtn.textContent='â–¶ï¸ ã‚¹ã‚¿ãƒ¼ãƒˆ / ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ'; }, 200);
    reset();
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã«ç´ã¥ã‘ã¦BGMã‚’é–‹å§‹ï¼ˆè‡ªå‹•å†ç”Ÿå¯¾ç­–ï¼‰
    if(!muted){
      try{ bgm.currentTime = 0; }catch(_){}
      // ã™ãã«å†ç”Ÿã§ããªã„å ´åˆã¯ load -> play ã®é †ã§å†è©¦è¡Œ
      bgm.play().catch(()=>{ try{ bgm.load(); bgm.play().catch(()=>{}); }catch(_){} });
    }
  };
  startBtn.addEventListener('click', onStart, {passive:false});
  startBtn.addEventListener('pointerdown', onStart, {passive:false});
  // åˆæœŸåŒ–ï¼šå¸¸ã«ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ï¼ˆæç”»ã®ã¿å…ˆè¡Œã€stateã§æ›´æ–°åˆ¶å¾¡ï¼‰
  requestAnimationFrame(loop);
  drawAutumnNight();
})();
</script>
</body>
</html>
