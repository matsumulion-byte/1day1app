<!doctype html>
<html lang="ja">
<head>
  <!-- OGP AUTO-GENERATED START (do not edit by hand) -->
  <meta property="og:title" content="ASTERO-MATSUMURA（レトロ）">
  <meta name="twitter:title" content="ASTERO-MATSUMURA（レトロ）">
  <meta property="og:description" content="SCORE 0 LIVES 3 WAVE 1 BGM: OFF PAUSE RESTART 回転＋推進 SHOT tap ASTERO-MATSUMURA 隕石は matsumura.png をクリップして貼る版。 SP： 左下スティック＝回転＋推進 / 右側タップ＝発射 PC：">
  <meta name="twitter:description" content="SCORE 0 LIVES 3 WAVE 1 BGM: OFF PAUSE RESTART 回転＋推進 SHOT tap ASTERO-MATSUMURA 隕石は matsumura.png をクリップして貼る版。 SP： 左下スティック＝回転＋推進 / 右側タップ＝発射 PC：">
  <meta property="og:image" content="/2026-01-10/assets/matsumura.png">
  <meta name="twitter:image" content="/2026-01-10/assets/matsumura.png">
  <meta property="og:url" content="/2026-01-10/">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <!-- OGP AUTO-GENERATED END -->

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#070a14" />
  <title>ASTERO-MATSUMURA（レトロ）</title>
  <style>
    :root{
      --bg:#070a14;
      --ink:#eaf0ff;
      --muted:rgba(234,240,255,.72);
      --line:rgba(234,240,255,.16);
      --accent:#60a5fa;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);
      --r:18px;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    html,body{
      height:100%; overflow:hidden; background:var(--bg); color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
      touch-action:none; -ms-touch-action:none;
    }
    button{font:inherit;color:inherit}
    .app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr;}
    .top{
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      padding:10px 10px calc(10px + env(safe-area-inset-top));
      border-bottom:1px solid var(--line);
      background:linear-gradient(to bottom, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .hud{
      display:flex;gap:8px;align-items:baseline;flex-wrap:wrap;
      font-variant-numeric:tabular-nums;
      letter-spacing:.04em;
    }
    .pill{
      padding:5px 9px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.05);
      font-size:12px;
    }
    .pill b{font-weight:900}
    .actions{display:flex;gap:6px;align-items:center;}
    .btn{
      padding:9px 10px;border-radius:12px;border:1px solid var(--line);
      background:linear-gradient(180deg,var(--panel2),var(--panel));
      box-shadow:0 10px 28px rgba(0,0,0,.35);
      cursor:pointer;
      white-space:nowrap;
      font-size:12px;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{
      border-color:rgba(96,165,250,.45);
      background:linear-gradient(180deg, rgba(96,165,250,.22), rgba(255,255,255,.06));
    }

    .mid{position:relative;min-height:0; touch-action:none;}
    canvas{position:absolute;inset:0;width:100%;height:100%; touch-action:none;}

    /* overlay */
    .overlay{position:absolute;inset:0;display:grid;place-items:center;padding:18px;pointer-events:none;}
    .card{
      width:min(560px,92vw);
      border:1px solid var(--line);border-radius:var(--r);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      padding:16px 16px 14px;
    }
    .title{font-size:18px;font-weight:900;letter-spacing:.06em}
    .desc{margin-top:8px;color:var(--muted);line-height:1.6;font-size:13px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .chip{
      font-size:12px;color:var(--muted);
      border:1px solid var(--line);border-radius:999px;padding:7px 10px;background:rgba(0,0,0,.18);
    }
    .chip b{color:var(--ink)}
    .row2{display:flex;gap:10px;justify-content:flex-end;margin-top:14px}
    .row2 .btn{pointer-events:auto}

    .toast{
      position:absolute;right:10px;bottom:calc(10px + env(safe-area-inset-bottom));
      font-size:11px;color:rgba(234,240,255,.65);
      pointer-events:none;
      opacity:0;
      transition:opacity .12s ease;
    }

    /* Controls: left virtual stick (rotate + thrust), right shoot zone (tap anywhere) */
    .controls{position:absolute;inset:0;pointer-events:none;touch-action:none;}
    .shootZone{
      position:absolute;top:0;bottom:0;right:0;width:44%;
      pointer-events:auto;touch-action:none;
    }
    .shootBadge{
      position:absolute;right:12px;bottom:12px;
      width:86px;height:86px;border-radius:999px;
      border:1px solid rgba(96,165,250,.45);
      background:radial-gradient(circle at 30% 30%, rgba(96,165,250,.28), rgba(255,255,255,.06));
      box-shadow:0 18px 50px rgba(0,0,0,.55);
      display:grid;place-items:center;
      font-weight:900;letter-spacing:.06em;
      pointer-events:none;
      opacity:.92;
    }
    .shootBadge small{display:block;font-weight:700;color:rgba(234,240,255,.75);letter-spacing:.04em;margin-top:4px;font-size:11px}

    .stickWrap{
      position:absolute;left:12px;bottom:12px;
      width:150px;height:150px;
      pointer-events:auto;touch-action:none;
      opacity:.95;
    }
    .stickBase{
      position:absolute;inset:0;border-radius:999px;
      border:1px solid rgba(234,240,255,.18);
      background:rgba(255,255,255,.04);
      box-shadow:0 18px 50px rgba(0,0,0,.45);
    }
    .stickKnob{
      position:absolute;left:50%;top:50%;
      width:62px;height:62px;border-radius:999px;
      transform:translate(-50%,-50%);
      border:1px solid rgba(234,240,255,.22);
      background:rgba(255,255,255,.08);
      box-shadow:0 10px 26px rgba(0,0,0,.35);
    }
    .stickLabel{
      position:absolute;left:50%;top:-26px;transform:translateX(-50%);
      font-size:11px;color:rgba(234,240,255,.62);letter-spacing:.04em;
      white-space:nowrap;
      pointer-events:none;
    }

    @media (min-width: 860px){
      .btn{font-size:13px;padding:10px 12px}
      .pill{font-size:13px}
      .controls{display:none}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="hud">
        <span class="pill">SCORE <b id="score">0</b></span>
        <span class="pill">LIVES <b id="lives">3</b></span>
        <span class="pill">WAVE <b id="wave">1</b></span>
      </div>
      <div class="actions">
        <button class="btn primary" id="btnBgm" type="button">BGM: OFF</button>
        <button class="btn" id="btnPause" type="button">PAUSE</button>
        <button class="btn" id="btnRestart" type="button">RESTART</button>
      </div>
    </div>

    <div class="mid" id="stage">
      <canvas id="cv"></canvas>

      <div class="controls" id="controls">
        <div class="stickWrap" id="stick">
          <div class="stickLabel">回転＋推進</div>
          <div class="stickBase"></div>
          <div class="stickKnob" id="knob"></div>
        </div>

        <div class="shootZone" id="shootZone" aria-label="shoot zone"></div>
        <div class="shootBadge">SHOT<small>tap</small></div>
      </div>

      <div class="toast" id="toast"></div>

      <div class="overlay" id="overlay">
        <div class="card" id="card">
          <div class="title">ASTERO-MATSUMURA</div>
          <div class="desc">
            隕石は <b>matsumura.png</b> をクリップして貼る版。<br/>
            <span style="color:var(--ink)">SP：</span> 左下スティック＝回転＋推進 / 右側タップ＝発射<br/>
            <span style="color:var(--ink)">PC：</span> ←→ 回転 / ↑ 推進 / Space 発射
          </div>
          <div class="row">
            <span class="chip"><b>弾</b> 最大6発</span>
            <span class="chip"><b>割れる</b> 大→中→小</span>
            <span class="chip"><b>無敵</b> 被弾後1.2秒</span>
          </div>
          <div class="row2">
            <button class="btn primary" id="btnStartBgmOn" type="button">BGM ONでSTART</button>
            <button class="btn" id="btnStartBgmOff" type="button">BGM OFFでSTART</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // Vercel用のパス解決ヘルパー
    const DATE_SEGMENT = (location.pathname.match(/\d{4}-\d{2}-\d{2}/) || [""])[0];
    const DATE_BASE = DATE_SEGMENT ? `/${DATE_SEGMENT}/` : "/";
    const asset = (p) => {
      const clean = String(p || "").replace(/^\.?\//, "");
      return `${DATE_BASE}${clean}`;
    };

    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');

    const $ = (id)=>document.getElementById(id);
    const uiScore = $('score');
    const uiLives = $('lives');
    const uiWave = $('wave');
    const toast = $('toast');
    const overlay = $('overlay');

    const btnPause = $('btnPause');
    const btnRestart = $('btnRestart');
    const btnBgm = $('btnBgm');

    const btnStartBgmOn = $('btnStartBgmOn');
    const btnStartBgmOff = $('btnStartBgmOff');

    // ====== 重要：ダブルタップ拡大を潰す（iOS Safari対策） ======
    // 1) dblclick
    document.addEventListener('dblclick', (e)=>e.preventDefault(), {passive:false});
    // 2) touchend double-tap
    let _lastTouchEnd = 0;
    document.addEventListener('touchend', (e)=>{
      const now = Date.now();
      if (now - _lastTouchEnd <= 280){
        e.preventDefault();
      }
      _lastTouchEnd = now;
    }, {passive:false});

    // ===== BGM =====
    const BGM_SRC = asset('./assets/bgm.mp3'); // あなたのBGM名に合わせて変更
    const bgm = new Audio();
    bgm.src = BGM_SRC;
    bgm.loop = true;
    bgm.preload = 'auto';

    const bgmState = { enabled:false, unlocked:false, targetVol:0.65, fading:null };

    function setBgmButton(){
      btnBgm.textContent = `BGM: ${bgmState.enabled ? 'ON' : 'OFF'}`;
      btnBgm.classList.toggle('primary', bgmState.enabled);
    }

    async function unlockAudioOnce(){
      if (bgmState.unlocked) return true;
      try{
        bgm.volume = 0.001;
        await bgm.play();
        bgm.pause();
        bgm.currentTime = 0;
        bgmState.unlocked = true;
        return true;
      }catch(e){ return false; }
    }

    function fadeTo(vol, ms=380){
      if (bgmState.fading) cancelAnimationFrame(bgmState.fading);
      const start = isFinite(bgm.volume) ? bgm.volume : 0;
      const t0 = performance.now();
      const tick = (t)=>{
        const k = Math.min(1, (t - t0)/ms);
        bgm.volume = Math.max(0, Math.min(1, start + (vol - start)*k));
        if (k < 1) bgmState.fading = requestAnimationFrame(tick);
        else{
          bgmState.fading = null;
          if (vol <= 0.0001) bgm.pause();
        }
      };
      bgmState.fading = requestAnimationFrame(tick);
    }

    async function ensureBgmPlaying(){
      if (!bgmState.enabled) return;
      const ok = await unlockAudioOnce();
      if (!ok) return;
      try{
        if (bgm.paused){
          bgm.volume = 0.001;
          await bgm.play();
        }
        fadeTo(bgmState.targetVol, 380);
      }catch(e){}
    }

    function stopBgmSoft(){
      if (!bgmState.unlocked) return;
      fadeTo(0, 200);
    }

    btnBgm.addEventListener('click', async ()=>{
      bgmState.enabled = !bgmState.enabled;
      setBgmButton();
      if (bgmState.enabled) await ensureBgmPlaying();
      else stopBgmSoft();
    });

    // ===== Matsumura texture (matsumura.png) =====
    // ユーザーの言い方が matumura.png になってたけど、ここは matsumura.png で読みに行く
    // ファイル名が本当に matumura.png なら、↓を './assets/matumura.png' に変えて。
    const tex = { img:new Image(), ready:false };
    tex.img.decoding = 'async';
    tex.img.onload = ()=>{ tex.ready = true; };
    tex.img.onerror = ()=>{ tex.ready = false; };
    tex.img.src = asset('./assets/matsumura.png');

    // --- utilities
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a+Math.random()*(b-a);
    const TAU = Math.PI*2;

    function wrapPos(p, w, h){
      if (p.x < 0) p.x += w;
      if (p.x >= w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y >= h) p.y -= h;
    }

    // --- game state
    const state = {
      w:0,h:0,dpr:1,
      running:false, paused:false,
      t:0, score:0, lives:3, wave:1,
      invuln:0, shake:0,
      ship:null, bullets:[], rocks:[], particles:[],
      keys:{ left:false, right:false, up:false, shoot:false },
      lastShot:0,
    };

    function resize(){
      const rect = cv.getBoundingClientRect();
      state.dpr = Math.min(2.25, window.devicePixelRatio || 1);
      state.w = Math.max(320, Math.floor(rect.width));
      state.h = Math.max(420, Math.floor(rect.height));
      cv.width = Math.floor(state.w * state.dpr);
      cv.height = Math.floor(state.h * state.dpr);
      ctx.setTransform(state.dpr,0,0,state.dpr,0,0);
    }
    window.addEventListener('resize', resize, {passive:true});

    function newShip(){
      return { x:state.w/2, y:state.h/2, vx:0, vy:0, a:-Math.PI/2, r:11 };
    }

    function spawnWave(nBig){
      state.rocks.length = 0;
      const minDist = Math.min(state.w, state.h) * 0.22;
      for(let i=0;i<nBig;i++){
        let x,y;
        for(let tries=0;tries<50;tries++){
          x = rand(0,state.w); y = rand(0,state.h);
          const dx = x - state.ship.x, dy = y - state.ship.y;
          if (dx*dx+dy*dy > minDist*minDist) break;
        }
        state.rocks.push(makeRock(x,y,3));
      }
    }

    function makeRock(x,y,size){
      const baseR = size===3? 44 : size===2? 26 : 16;
      const speed = size===3? rand(22,52) : size===2? rand(38,78) : rand(60,110);
      const ang = rand(0,TAU);
      const rot = rand(-1.3,1.3);
      const verts = [];
      const points = size===3? 12 : size===2? 10 : 8;
      for(let i=0;i<points;i++){
        const t = (i/points)*TAU;
        verts.push({ t, m: rand(0.72,1.18) });
      }
      return { x,y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, a:rand(0,TAU), va:rot, size, r:baseR, verts };
    }

    function popToast(msg){
      toast.textContent = msg;
      toast.style.opacity = '1';
      clearTimeout(popToast._t);
      popToast._t = setTimeout(()=>toast.style.opacity='0', 160);
    }

    function boom(x,y,amt){
      for(let i=0;i<amt;i++){
        const a = rand(0,TAU), sp = rand(40,220);
        state.particles.push({ x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.25,0.75), w:rand(1,2.2) });
      }
    }

    function fire(){
      const now = state.t;
      if (now - state.lastShot < 0.11) return;
      if (state.bullets.length >= 6) return;
      state.lastShot = now;

      const s = state.ship, spd = 360;
      state.bullets.push({
        x: s.x + Math.cos(s.a)*16,
        y: s.y + Math.sin(s.a)*16,
        vx: s.vx + Math.cos(s.a)*spd,
        vy: s.vy + Math.sin(s.a)*spd,
        life: 0.95
      });
      popToast('pew');
    }

    function splitRock(rock){
      const {x,y,size} = rock;
      if (size === 3){
        state.score += 20;
        state.rocks.push(makeRock(x,y,2), makeRock(x,y,2));
        boom(x,y,22);
      } else if (size === 2){
        state.score += 50;
        state.rocks.push(makeRock(x,y,1), makeRock(x,y,1));
        boom(x,y,18);
      } else {
        state.score += 100;
        boom(x,y,14);
      }
      uiScore.textContent = String(state.score);
      state.shake = Math.max(state.shake, 0.08);
    }

    function resetAll(){
      state.running = false; state.paused = false;
      state.t = 0; state.score = 0; state.lives = 3; state.wave = 1;
      state.invuln = 0; state.shake = 0;
      state.ship = newShip();
      state.bullets = []; state.rocks = []; state.particles = [];
      state.lastShot = -999;

      uiScore.textContent = String(state.score);
      uiLives.textContent = String(state.lives);
      uiWave.textContent = String(state.wave);

      overlay.style.display = 'grid';
      btnPause.textContent = 'PAUSE';

      resize();
      spawnWave(4);
      draw(0);
      stopBgmSoft();
    }

    async function startGame(){
      state.running = true; state.paused = false;
      overlay.style.display = 'none';
      btnPause.textContent = 'PAUSE';
      if (bgmState.enabled) await ensureBgmPlaying();
    }

    function gameOver(){
      state.running = false;
      overlay.style.display = 'grid';
      $('card').querySelector('.title').textContent = 'GAME OVER';
      $('card').querySelector('.desc').innerHTML =
        `SCORE: <b style="color:var(--ink)">${state.score}</b><br/>RESTARTで最初から。`;
      popToast('rip');
      stopBgmSoft();
    }

    function nextWave(){
      state.wave++;
      uiWave.textContent = String(state.wave);
      state.score += 200;
      uiScore.textContent = String(state.score);
      spawnWave(clamp(3 + state.wave, 4, 10));
      popToast('wave ' + state.wave);
    }

    function hitShip(){
      if (state.invuln > 0) return;
      state.lives--;
      uiLives.textContent = String(state.lives);
      state.invuln = 1.2;
      state.shake = 0.25;
      boom(state.ship.x, state.ship.y, 36);
      popToast('hit');

      state.ship.x = state.w/2; state.ship.y = state.h/2;
      state.ship.vx = 0; state.ship.vy = 0;
      state.ship.a = -Math.PI/2;

      if (state.lives <= 0) gameOver();
    }

    // ===== Mobile UI: virtual stick =====
    const stick = $('stick');
    const knob = $('knob');
    const shootZone = $('shootZone');

    const stickState = { active:false, id:null, cx:0, cy:0, dx:0, dy:0, max:52 };

    function setKnob(dx, dy){
      const m = stickState.max;
      const x = clamp(dx, -m, m);
      const y = clamp(dy, -m, m);
      knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
    }

    function stickDown(e){
      stickState.active = true;
      stickState.id = e.pointerId;
      const r = stick.getBoundingClientRect();
      stickState.cx = r.left + r.width/2;
      stickState.cy = r.top + r.height/2;
      stick.setPointerCapture(e.pointerId);
      stickMove(e);
      e.preventDefault();
    }
    function stickMove(e){
      if (!stickState.active || e.pointerId !== stickState.id) return;
      stickState.dx = e.clientX - stickState.cx;
      stickState.dy = e.clientY - stickState.cy;

      const dist = Math.hypot(stickState.dx, stickState.dy);
      const m = stickState.max;
      if (dist > m){
        const k = m / dist;
        stickState.dx *= k; stickState.dy *= k;
      }
      setKnob(stickState.dx, stickState.dy);

      // mapping:
      //  - rotate: dx (左右で回転)
      //  - thrust: 上方向に倒したら推進（dyがマイナス）
      state.keys.left = stickState.dx < -8;
      state.keys.right = stickState.dx > 8;
      state.keys.up = stickState.dy < -10;

      e.preventDefault();
    }
    function stickUp(e){
      if (e.pointerId !== stickState.id) return;
      stickState.active = false;
      stickState.id = null;
      stickState.dx = stickState.dy = 0;
      setKnob(0,0);
      state.keys.left = state.keys.right = state.keys.up = false;
    }

    stick.addEventListener('pointerdown', stickDown, {passive:false});
    stick.addEventListener('pointermove', stickMove, {passive:false});
    stick.addEventListener('pointerup', stickUp, {passive:true});
    stick.addEventListener('pointercancel', stickUp, {passive:true});

    // shoot: tap anywhere on right zone
    shootZone.addEventListener('pointerdown', (e)=>{
      state.keys.shoot = true;
      if (state.running && !state.paused) fire();
      e.preventDefault();
    }, {passive:false});
    window.addEventListener('pointerup', ()=>state.keys.shoot=false, {passive:true});
    window.addEventListener('pointercancel', ()=>state.keys.shoot=false, {passive:true});

    // ===== Desktop keyboard =====
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowLeft') state.keys.left = true;
      if (e.key === 'ArrowRight') state.keys.right = true;
      if (e.key === 'ArrowUp') state.keys.up = true;
      if (e.key === ' ') { state.keys.shoot = true; e.preventDefault(); }
      if (e.key.toLowerCase() === 'p') togglePause();
    }, {passive:false});
    window.addEventListener('keyup', (e)=>{
      if (e.key === 'ArrowLeft') state.keys.left = false;
      if (e.key === 'ArrowRight') state.keys.right = false;
      if (e.key === 'ArrowUp') state.keys.up = false;
      if (e.key === ' ') { state.keys.shoot = false; e.preventDefault(); }
    }, {passive:false});

    // ===== Start with BGM confirm =====
    async function startWithBgm(flag){
      bgmState.enabled = flag;
      setBgmButton();
      await unlockAudioOnce();

      // カードのタイトルと説明を復元
      $('card').querySelector('.title').textContent = 'ASTERO-MATSUMURA';
      $('card').querySelector('.desc').innerHTML =
        `1画面レトロ。慣性＋端ワープ。隕石（線）を撃って割れ。<br/>
         <span class="k">操作：</span> 左=回転 / 中=推進 / 右=SHOT（スマホ）<br/>
         <span class="k">PC：</span> ←→ 回転 / ↑ 推進 / Space 発射`;

      // ゲームオーバー後も含めて、全部リセットしてから開始
      resetAll();
      await startGame();
    }
    btnStartBgmOn.addEventListener('click', ()=>startWithBgm(true));
    btnStartBgmOff.addEventListener('click', ()=>startWithBgm(false));

    function togglePause(){
      if (!state.running) return;
      state.paused = !state.paused;
      btnPause.textContent = state.paused ? 'RESUME' : 'PAUSE';
      popToast(state.paused ? 'pause' : 'go');
      if (bgmState.enabled && bgmState.unlocked){
        if (state.paused) fadeTo(0.18, 160);
        else fadeTo(bgmState.targetVol, 220);
      }
    }
    btnPause.addEventListener('click', togglePause);

    btnRestart.addEventListener('click', async ()=>{
      resetAll();
      overlay.style.display = 'none';
      state.running = true;
      state.paused = false;
      if (bgmState.enabled) await ensureBgmPlaying();
    });

    // --- main loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      if (state.running && !state.paused) update(dt);
      draw(dt);
      requestAnimationFrame(loop);
    }

    function update(dt){
      state.t += dt;
      state.invuln = Math.max(0, state.invuln - dt);
      state.shake = Math.max(0, state.shake - dt);

      const s = state.ship;

      const rotSpd = 3.6;
      if (state.keys.left) s.a -= rotSpd * dt;
      if (state.keys.right) s.a += rotSpd * dt;

      if (state.keys.up){
        const acc = 260;
        s.vx += Math.cos(s.a) * acc * dt;
        s.vy += Math.sin(s.a) * acc * dt;
        if (Math.random() < 0.35){
          const ex = s.x - Math.cos(s.a)*10;
          const ey = s.y - Math.sin(s.a)*10;
          state.particles.push({
            x: ex, y: ey,
            vx: s.vx - Math.cos(s.a)*rand(40,160),
            vy: s.vy - Math.sin(s.a)*rand(40,160),
            life: rand(0.12,0.22),
            w: rand(1.2,2.6)
          });
        }
      }

      const drag = 0.994;
      s.vx *= Math.pow(drag, dt*60);
      s.vy *= Math.pow(drag, dt*60);

      const vmax = 340;
      const sp2 = s.vx*s.vx + s.vy*s.vy;
      if (sp2 > vmax*vmax){
        const k = vmax / Math.sqrt(sp2);
        s.vx *= k; s.vy *= k;
      }

      s.x += s.vx * dt;
      s.y += s.vy * dt;
      wrapPos(s, state.w, state.h);

      if (state.keys.shoot) fire();

      for(let i=state.bullets.length-1;i>=0;i--){
        const b = state.bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;
        wrapPos(b, state.w, state.h);
        if (b.life <= 0) state.bullets.splice(i,1);
      }

      for (const r of state.rocks){
        r.a += r.va * dt;
        r.x += r.vx * dt;
        r.y += r.vy * dt;
        wrapPos(r, state.w, state.h);
      }

      for(let i=state.particles.length-1;i>=0;i--){
        const p = state.particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        wrapPos(p, state.w, state.h);
        if (p.life <= 0) state.particles.splice(i,1);
      }

      if (state.invuln <= 0){
        for (const r of state.rocks){
          const dx = r.x - s.x;
          const dy = r.y - s.y;
          const rr = r.r*0.72 + s.r;
          if (dx*dx + dy*dy < rr*rr){
            hitShip();
            break;
          }
        }
      }

      for (let bi=state.bullets.length-1; bi>=0; bi--){
        const b = state.bullets[bi];
        let hitIdx = -1;
        for (let ri=0; ri<state.rocks.length; ri++){
          const r = state.rocks[ri];
          const dx = r.x - b.x;
          const dy = r.y - b.y;
          const rr = r.r*0.80;
          if (dx*dx + dy*dy < rr*rr){ hitIdx = ri; break; }
        }
        if (hitIdx >= 0){
          const r = state.rocks[hitIdx];
          state.bullets.splice(bi,1);
          state.rocks.splice(hitIdx,1);
          splitRock(r);
        }
      }

      if (state.rocks.length === 0) nextWave();

      if (Math.random() < dt * 0.8){
        state.score += 1;
        uiScore.textContent = String(state.score);
      }
    }

    function draw(dt){
      const w = state.w, h = state.h;

      let sx = 0, sy = 0;
      if (state.shake > 0){
        const m = state.shake * 10;
        sx = rand(-m, m);
        sy = rand(-m, m);
      }

      ctx.save();
      ctx.translate(sx, sy);

      ctx.clearRect(-sx, -sy, w, h);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
      ctx.fillRect(-sx, -sy, w, h);

      // stars
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = '#fff';
      const starN = 70;
      const tt = Math.floor(state.t*10);
      for(let i=0;i<starN;i++){
        const x = (Math.sin((i+1)*999 + tt*0.2)*0.5+0.5)*w;
        const y = (Math.sin((i+1)*555 + tt*0.17)*0.5+0.5)*h;
        ctx.fillRect(x, y, 1, 1);
      }
      ctx.globalAlpha = 1;

      // rocks: outline + matsumura.png clipped inside
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(234,240,255,.72)';
      for (const r of state.rocks){
        ctx.save();
        ctx.translate(r.x, r.y);
        ctx.rotate(r.a);

        // rock path
        const verts = r.verts;
        ctx.beginPath();
        for(let i=0;i<verts.length;i++){
          const v = verts[i];
          const rr = r.r * v.m;
          const px = Math.cos(v.t)*rr;
          const py = Math.sin(v.t)*rr;
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();

        if (tex.ready){
          ctx.save();
          ctx.clip();

          const img = tex.img;
          const iw = img.naturalWidth || img.width;
          const ih = img.naturalHeight || img.height;

          const cover = r.r * 2.25; // 顔の大きさ（好みで 2.0〜2.6）
          const s = cover / Math.min(iw, ih);
          const dw = iw * s;
          const dh = ih * s;

          const jitter = r.size===3 ? 10 : r.size===2 ? 8 : 6;
          const ox = (Math.sin(r.x*0.03 + r.y*0.02) * 0.5) * jitter;
          const oy = (Math.cos(r.x*0.02 + r.y*0.03) * 0.5) * jitter;

          ctx.globalAlpha = 0.92;
          ctx.drawImage(img, -dw/2 + ox, -dh/2 + oy, dw, dh);

          // 馴染ませ暗幕
          ctx.globalAlpha = 0.30;
          ctx.fillStyle = 'rgba(0,0,0,.35)';
          ctx.fillRect(-r.r*1.4, -r.r*1.4, r.r*2.8, r.r*2.8);

          ctx.restore();
        }

        // outline on top
        ctx.globalAlpha = 1;
        ctx.stroke();
        ctx.restore();
      }

      // bullets
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(96,165,250,.95)';
      for (const b of state.bullets){
        ctx.beginPath();
        ctx.arc(b.x, b.y, 2.2, 0, TAU);
        ctx.stroke();
      }

      // ship
      const s = state.ship;
      const inv = state.invuln > 0;
      const blink = inv ? (Math.sin(state.t*24) > 0) : true;
      if (blink){
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.a);

        ctx.lineWidth = 2;
        ctx.strokeStyle = inv ? 'rgba(251,113,133,.95)' : 'rgba(234,240,255,.92)';
        ctx.beginPath();
        ctx.moveTo(14, 0);
        ctx.lineTo(-10, -9);
        ctx.lineTo(-6, 0);
        ctx.lineTo(-10, 9);
        ctx.closePath();
        ctx.stroke();

        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(6,0);
        ctx.lineTo(-4,0);
        ctx.stroke();
        ctx.globalAlpha = 1;

        ctx.restore();
      }

      // particles
      ctx.strokeStyle = 'rgba(234,240,255,.75)';
      for (const p of state.particles){
        ctx.globalAlpha = clamp(p.life*1.6, 0, 1);
        ctx.lineWidth = p.w;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // vignette
      const g = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.2, w/2, h/2, Math.max(w,h)*0.72);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,.55)');
      ctx.fillStyle = g;
      ctx.fillRect(-sx, -sy, w, h);

      ctx.restore();
    }

    btnRestart.addEventListener('click', async ()=>{
      resetAll();
      overlay.style.display = 'none';
      state.running = true;
      state.paused = false;
      if (bgmState.enabled) await ensureBgmPlaying();
    });

    // init
    function init(){
      setBgmButton();
      resize();
      state.ship = newShip();
      resetAll();
      requestAnimationFrame(loop);
    }
    init();
  </script>
</body>
</html>
