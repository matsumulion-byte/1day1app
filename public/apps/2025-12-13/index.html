<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>ビタミンカプセル・ドロップ（60秒）</title>
  <style>
    :root{
      --bg:#070a12;
      --panel:#0b1222;
      --ink:#f4f7ff;
      --muted:#a6b0d6;
      --accent:#7dd3fc;
      --danger:#fb7185;
      --ok:#34d399;
      --radius:18px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      background:
        radial-gradient(1200px 700px at 50% -10%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(1000px 600px at 20% 110%, rgba(52,211,153,.14), transparent 60%),
        linear-gradient(180deg, #050712 0%, #070a12 45%, #050712 100%);
      color:var(--ink);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{
      height:100%;
      padding: max(12px, env(safe-area-inset-top)) 12px max(12px, env(safe-area-inset-bottom));
      display:flex;
      justify-content:center;
      align-items:stretch;
    }
    .app{
      width:min(560px, 100%);
      height:100%;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .hud{
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .top{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
    }
    .top h1{
      font-size: 16px;
      font-weight: 900;
      letter-spacing:.02em;
    }
    .top .sub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .pill b{color:var(--ink); font-variant-numeric: tabular-nums}
    .btns{display:flex; gap:8px; align-items:center}
    button{
      appearance:none;
      border:none;
      cursor:pointer;
      color:var(--ink);
      border-radius:14px;
      padding:10px 12px;
      font-weight:900;
      letter-spacing:.02em;
      background: rgba(125,211,252,.16);
      border:1px solid rgba(125,211,252,.35);
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }
    button.secondary{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:var(--muted);
      font-weight:800;
    }
    button:active{transform: translateY(1px)}

    .boardWrap{
      flex: 1;
      min-height: 0;
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    canvas{
      width:100%;
      flex:1;
      min-height:0;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(14,23,48,.55), rgba(11,18,34,.40));
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12);
      touch-action:none;
    }
    .footer{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      padding: 10px;
    }
    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .controls{display:flex; gap:8px}
    .ctl{
      width: 56px;
      height: 44px;
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color: var(--ink);
      font-weight:900;
      font-size: 18px;
    }

    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      z-index:10;
    }
    .overlay.on{display:flex;}
    .modal{
      width:min(520px, 100%);
      padding:16px;
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
    }
    .modal h2{font-size:18px; margin-bottom:6px}
    .modal p{font-size:13px; color:var(--muted); line-height:1.6; margin-bottom:12px}
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      margin-bottom:12px;
    }
    .stat{
      border-radius: 16px;
      padding: 10px 10px;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.10);
      font-size: 12px;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .stat b{color:var(--ink); font-variant-numeric: tabular-nums}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <div class="card hud">
        <div class="top">
          <h1>ビタミンカプセル・ドロップ</h1>
          <div class="sub">60秒で“不健康(ウイルス)”を消せ</div>
        </div>
        <div class="row">
          <div class="pill">残り <b id="time">60.0</b>s</div>
          <div class="pill">ウイルス <b id="virus">0</b></div>
          <div class="pill">スコア <b id="score">0</b></div>
          <div class="btns">
            <button id="btnStart">▶ START</button>
            <button class="secondary" id="btnHow">？</button>
          </div>
        </div>
      </div>

      <div class="card boardWrap">
        <canvas id="cv"></canvas>
        <div class="footer">
          <div class="hint">
            ルール：<b>同色が縦/横に4つ以上</b>つながると消える（ウイルスも対象）<br/>
            操作：左右/下（PC←→↓）・回転（PC↑/Space/タップ）・下スワイプで落下
          </div>
          <div class="controls">
            <button class="ctl" id="leftBtn">◀</button>
            <button class="ctl" id="rotBtn">⟳</button>
            <button class="ctl" id="rightBtn">▶</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="ov">
    <div class="modal">
      <h2 id="resTitle">結果</h2>
      <p id="resMsg">—</p>
      <div class="grid2">
        <div class="stat">スコア <b id="resScore">0</b></div>
        <div class="stat">残ウイルス <b id="resVirus">0</b></div>
      </div>
      <div class="btns" style="justify-content:flex-end">
        <button class="secondary" id="btnClose">閉じる</button>
        <button id="btnRetry">▶ もう一回</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="how">
    <div class="modal">
      <h2>遊び方</h2>
      <p>
        上から落ちる<b>2マスのカプセル</b>を左右に動かし、タップ/↑で回転。<br/>
        <b>同じ色が縦/横に4つ以上</b>つながると消えます（ウイルスも消える）。<br/>
        60秒以内にウイルスを0にできたら勝ち。タイムアップ時は残ウイルスが少ないほど良いです。
      </p>
      <div class="btns" style="justify-content:flex-end">
        <button id="btnHowClose">OK</button>
      </div>
    </div>
  </div>

  <script type="module">
    // 1日1アプリ：動的アセットヘルパー（今回は未使用だが規約として入れておく）
    const asset = (p) => new URL(p, import.meta.url).toString();

    // ===== 設定 =====
    const COLS = 8;
    const ROWS = 16;

    // 色は「ビタミン」扱い。3色でドクマリ感を出す（5色にすると難易度が跳ねる）
    const COLORS = [
      { name:"A", fill:"#fb923c" }, // orange
      { name:"C", fill:"#34d399" }, // green
      { name:"D", fill:"#60a5fa" }, // blue
    ];

    const START_TIME = 60.0;
    const VIRUS_COUNT = 16;          // 初期ウイルス数（調整ポイント）
    const FALL_CPS = 3.2;            // cells per second（通常落下）
    const SOFT_MULT = 9.0;           // 下押し中の加速倍率
    const LOCK_DELAY = 0.2;         // 着地後ロック猶予
    const SPAWN_X = Math.floor(COLS/2) - 1;
    const SPAWN_Y = -1;

    // スコア（ざっくり）
    const SCORE_VIRUS = 200;
    const SCORE_CAP = 30;
    const SCORE_CHAIN_BONUS = 120;

    // ===== DOM =====
    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d");

    const timeEl = document.getElementById("time");
    const virusEl = document.getElementById("virus");
    const scoreEl = document.getElementById("score");
    const btnStart = document.getElementById("btnStart");
    const btnHow = document.getElementById("btnHow");
    const how = document.getElementById("how");
    const btnHowClose = document.getElementById("btnHowClose");

    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");
    const rotBtn = document.getElementById("rotBtn");

    const ov = document.getElementById("ov");
    const resTitle = document.getElementById("resTitle");
    const resMsg = document.getElementById("resMsg");
    const resScore = document.getElementById("resScore");
    const resVirus = document.getElementById("resVirus");
    const btnRetry = document.getElementById("btnRetry");
    const btnClose = document.getElementById("btnClose");

    // ===== 状態 =====
    let grid;              // [r][c] = null or { kind:'virus'|'cap', ci:number }
    let piece = null;      // 落下中の2セル
    let timeLeft = START_TIME;
    let score = 0;
    let virusCount = 0;
    let running = false;

    let lastT = 0;
    let fallAcc = 0;       // 落下の累積
    let lockAcc = 0;

    let softDrop = false;

    // 入力（連打防止）
    let keyLeft=false, keyRight=false, keyDown=false;

    // ===== ユーティリティ =====
    function randInt(n){ return Math.floor(Math.random()*n); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function resize(){
      const rect = cv.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", resize);

    function emptyGrid(){
      return Array.from({length:ROWS}, ()=> Array(COLS).fill(null));
    }

    function countViruses(){
      let n=0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const cell = grid[r][c];
          if(cell && cell.kind==="virus") n++;
        }
      }
      return n;
    }

    // ===== ピース（2セル） =====
    // pivot (x,y) を左(または上)側セルとして扱い、orientationで相方の相対位置を決める
    // o=0: horizontal [pivot][other right]
    // o=1: vertical   [pivot][other down]
    // o=2: horizontal [pivot][other left]
    // o=3: vertical   [pivot][other up]
    function newPiece(){
      const a = randInt(COLORS.length);
      const b = randInt(COLORS.length);
      return { x: SPAWN_X, y: SPAWN_Y, o: 0, a, b };
    }

    function cellsOf(p){
      const {x,y,o,a,b} = p;
      let ox=1, oy=0;
      if(o===0){ ox=1; oy=0; }
      if(o===1){ ox=0; oy=1; }
      if(o===2){ ox=-1; oy=0; }
      if(o===3){ ox=0; oy=-1; }
      return [
        { x,     y,     ci: a, isPivot:true },
        { x:x+ox,y:y+oy,ci: b, isPivot:false },
      ];
    }

    function inBounds(r,c){
      return r>=0 && r<ROWS && c>=0 && c<COLS;
    }

    function canPlaceCells(cells){
      for(const s of cells){
        // 上側は画面外OK（スポーン中）
        if(s.y < 0){
          if(s.x < 0 || s.x >= COLS) return false;
          continue;
        }
        if(!inBounds(s.y, s.x)) return false;
        if(grid[s.y][s.x] != null) return false;
      }
      return true;
    }

    function tryMove(dx,dy){
      if(!piece) return false;
      const np = { ...piece, x: piece.x + dx, y: piece.y + dy };
      if(canPlaceCells(cellsOf(np))){
        piece = np;
        return true;
      }
      return false;
    }

    function tryRotate(dir=1){
      // dir=+1 clockwise
      if(!piece) return false;
      const no = (piece.o + dir + 4) % 4;
      const base = { ...piece, o: no };

      // 壁キック（簡易）：まずその場、次に左右、上
      const kicks = [
        {dx:0, dy:0},
        {dx:-1, dy:0},
        {dx:1, dy:0},
        {dx:0, dy:-1},
        {dx:-2, dy:0},
        {dx:2, dy:0},
      ];

      for(const k of kicks){
        const cand = { ...base, x: base.x + k.dx, y: base.y + k.dy };
        if(canPlaceCells(cellsOf(cand))){
          piece = cand;
          return true;
        }
      }
      return false;
    }

    function hardDrop(){
      if(!piece) return;
      while(tryMove(0,1)){}
      // 即ロック
      lockAcc = LOCK_DELAY;
    }

    // ===== ウイルス配置 =====
    function seedViruses(){
      // 下寄りに配置（それっぽい）
      let placed = 0;
      let guard = 5000;
      while(placed < VIRUS_COUNT && guard-- > 0){
        const r = randInt(ROWS);
        const c = randInt(COLS);
        if(r < Math.floor(ROWS*0.35)) continue; // 上は空ける
        if(grid[r][c] != null) continue;
        // 近接同色が多すぎると単純すぎるので、同色隣接が2以上なら避ける
        const ci = randInt(COLORS.length);
        let sameAdj = 0;
        const nb = [[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dr,dc] of nb){
          const rr=r+dr, cc=c+dc;
          if(inBounds(rr,cc) && grid[rr][cc] && grid[rr][cc].ci===ci) sameAdj++;
        }
        if(sameAdj >= 2) continue;

        grid[r][c] = { kind:"virus", ci };
        placed++;
      }
      virusCount = countViruses();
      virusEl.textContent = String(virusCount);
    }

    // ===== マッチ解決（縦横4以上） =====
    function findClears(){
      const mark = Array.from({length:ROWS}, ()=> Array(COLS).fill(false));

      // 横
      for(let r=0;r<ROWS;r++){
        let runCi = null, runStart = 0, runLen = 0;
        for(let c=0;c<=COLS;c++){
          const cell = (c<COLS) ? grid[r][c] : null;
          const ci = cell ? cell.ci : null;
          if(ci!==null && ci===runCi){
            runLen++;
          }else{
            if(runCi!==null && runLen>=4){
              for(let k=0;k<runLen;k++){
                mark[r][runStart+k] = true;
              }
            }
            runCi = ci;
            runStart = c;
            runLen = (ci!==null) ? 1 : 0;
          }
        }
      }

      // 縦
      for(let c=0;c<COLS;c++){
        let runCi = null, runStart = 0, runLen = 0;
        for(let r=0;r<=ROWS;r++){
          const cell = (r<ROWS) ? grid[r][c] : null;
          const ci = cell ? cell.ci : null;
          if(ci!==null && ci===runCi){
            runLen++;
          }else{
            if(runCi!==null && runLen>=4){
              for(let k=0;k<runLen;k++){
                mark[runStart+k][c] = true;
              }
            }
            runCi = ci;
            runStart = r;
            runLen = (ci!==null) ? 1 : 0;
          }
        }
      }

      // まとめて座標に
      const cells = [];
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(mark[r][c]) cells.push({r,c});
        }
      }
      return cells;
    }
    function breakLinksAround(r,c){
  const dirs = {
    L:[0,-1], R:[0,1], U:[-1,0], D:[1,0]
  };
  const back = { L:"R", R:"L", U:"D", D:"U" };

  for(const k in dirs){
    const [dr,dc] = dirs[k];
    const rr = r+dr, cc = c+dc;
    if(!inBounds(rr,cc)) continue;
    const nb = grid[rr][cc];
    if(nb && nb.kind==="cap" && nb.link){
      const [bdr,bdc] = dirs[nb.link];
      const pr = rr+bdr, pc = cc+bdc;
      if(!inBounds(pr,pc) || !grid[pr][pc]){
        nb.link = null;
      } else {
        const partner = grid[pr][pc];
        if(partner.link !== back[nb.link]) nb.link = null;
      }
    }
  }
}

    function applyGravity(){
  let moved;
  do {
    moved = false;

    // 下から上へ
    for(let r=ROWS-2; r>=0; r--){
      for(let c=0; c<COLS; c++){
        const cell = grid[r][c];
        if(!cell || cell.kind!=="cap") continue;

        // 単体カプセル
        if(!cell.link){
          if(grid[r+1][c]==null){
            grid[r+1][c] = cell;
            grid[r][c] = null;
            moved = true;
          }
          continue;
        }

        // 縦ペア（上側だけ処理）
        if(cell.link==="D"){
          const bottom = grid[r+1][c];
          if(!bottom || bottom.link!=="U") {
            cell.link = null;
            continue;
          }
          if(r+2<ROWS && grid[r+2][c]==null){
            grid[r+2][c] = bottom;
            grid[r+1][c] = cell;
            grid[r][c] = null;
            moved = true;
          }
          continue;
        }

        // 横ペア（左側だけ処理）
        if(cell.link==="R"){
          const right = grid[r][c+1];
          if(!right || right.link!=="L"){
            cell.link = null;
            continue;
          }
          if(
            r+1<ROWS &&
            grid[r+1][c]==null &&
            grid[r+1][c+1]==null
          ){
            grid[r+1][c] = cell;
            grid[r+1][c+1] = right;
            grid[r][c] = null;
            grid[r][c+1] = null;
            moved = true;
          }
        }
      }
    }
  } while(moved);
}

    

    function resolve(){
      let chain = 0;
      while(true){
        const clears = findClears();
        if(clears.length===0) break;
        chain++;

        let virusCleared = 0;
        for(const {r,c} of clears){
          const cell = grid[r][c];
          breakLinksAround(r,c);

          if(!cell) continue;
          if(cell.kind==="virus") virusCleared++;
          score += (cell.kind==="virus") ? SCORE_VIRUS : SCORE_CAP;
          grid[r][c] = null;
        }

        if(chain>=2) score += SCORE_CHAIN_BONUS * (chain-1);
        applyGravity();

        virusCount = countViruses();
        virusEl.textContent = String(virusCount);
        scoreEl.textContent = String(score);

        if(virusCount<=0) break;
      }
    }

    // ===== ロック =====
    function lockPiece(){
      const cs = cellsOf(piece);

      // 画面外で固定が発生する＝詰み
      for(const s of cs){
        if(s.y < 0) return false;
      }

      for(const s of cs){
        grid[s.y][s.x] = { kind:"cap", ci: s.ci };
      }
      return true;
    }

    // ===== 描画 =====
    function drawRoundedRect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawCell(px,py,size,cell){
      const {fill, name} = COLORS[cell.ci];
      const r = Math.floor(size*0.22);

      // body
      drawRoundedRect(px+2, py+2, size-4, size-4, r);
      ctx.fillStyle = fill;
      ctx.fill();

      // highlight
      ctx.globalAlpha = 0.25;
      drawRoundedRect(px+5, py+5, size*0.42, size*0.28, r);
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.globalAlpha = 1;

      // virus face / capsule letter
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `900 ${Math.floor(size*0.34)}px system-ui, -apple-system, sans-serif`;

      if(cell.kind==="virus"){
        ctx.fillStyle = "rgba(0,0,0,.45)";
        ctx.fillText("×", px+size/2, py+size/2+1);
      }else{
        ctx.fillStyle = "rgba(0,0,0,.40)";
        ctx.fillText(name, px+size/2, py+size/2+1);
      }
    }

    function draw(){
      const rect = cv.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      ctx.clearRect(0,0,W,H);

      const pad = 12;
      const bw = W - pad*2;
      const bh = H - pad*2;

      const cell = Math.floor(Math.min(bw / COLS, bh / ROWS));
      const boardW = cell * COLS;
      const boardH = cell * ROWS;
      const ox = Math.floor((W - boardW)/2);
      const oy = Math.floor((H - boardH)/2);

      // frame
      drawRoundedRect(ox-8, oy-8, boardW+16, boardH+16, 18);
      ctx.fillStyle = "rgba(0,0,0,.18)";
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 1;
      ctx.stroke();

      // grid backdrop
      ctx.save();
      ctx.translate(ox, oy);
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          drawRoundedRect(c*cell+2, r*cell+2, cell-4, cell-4, Math.floor(cell*0.22));
          ctx.fillStyle = "rgba(255,255,255,.04)";
          ctx.fill();
        }
      }

      // fixed
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const cellObj = grid[r][c];
          if(!cellObj) continue;
          drawCell(c*cell, r*cell, cell, cellObj);
        }
      }

      // falling
      if(piece){
        const cs = cellsOf(piece);
        for(const s of cs){
          if(s.y < 0) continue;
          drawCell(s.x*cell, s.y*cell, cell, {kind:"cap", ci:s.ci});
        }
      }

      ctx.restore();
      return {cell, ox, oy};
    }

    // ===== ゲーム管理 =====
    function reset(){
      grid = emptyGrid();
      score = 0;
      virusCount = 0;
      timeLeft = START_TIME;
      fallAcc = 0;
      lockAcc = 0;
      softDrop = false;

      seedViruses();
      piece = newPiece();

      scoreEl.textContent = "0";
      timeEl.textContent = timeLeft.toFixed(1);
      virusEl.textContent = String(virusCount);
    }

    function end(reason){
      running = false;
      btnStart.disabled = false;
      btnStart.textContent = "▶ START";
      showResult(reason);
    }

    function showResult(reason){
      resScore.textContent = String(score);
      resVirus.textContent = String(virusCount);

      if(reason==="win"){
        resTitle.textContent = "勝ち！";
        resMsg.textContent = "ウイルス全消し。健康になりました。";
      }else if(reason==="time"){
        resTitle.textContent = "タイムアップ";
        resMsg.textContent = virusCount===0 ? "ギリ勝ち！" : "残ウイルスを減らしてもう一回。";
      }else{
        resTitle.textContent = "詰み";
        resMsg.textContent = "上で詰まりました。置き方を変えて再挑戦。";
      }
      ov.classList.add("on");
    }

    function step(ts){
      if(!running) return;
      if(!lastT) lastT = ts;
      const dt = Math.min(0.033, (ts-lastT)/1000);
      lastT = ts;

      // timer
      timeLeft -= dt;
      if(timeLeft <= 0){
        timeLeft = 0;
        timeEl.textContent = timeLeft.toFixed(1);
        end("time");
        return;
      }
      timeEl.textContent = timeLeft.toFixed(1);

      // input continuous
      softDrop = keyDown;

      // gravity (piece fall in cells)
      const cps = FALL_CPS * (softDrop ? SOFT_MULT : 1);
      fallAcc += dt * cps;

      // draw each frame
      draw();

      // fall by whole cells (classic feel)
      while(fallAcc >= 1){
        fallAcc -= 1;

        if(tryMove(0,1)){
          lockAcc = 0;
        }else{
          // can't move down => start lock
          lockAcc += 1; // lock in "cell ticks"
          break;
        }
      }

      // lock delay in real time
      if(piece){
        if(!canPlaceCells(cellsOf({ ...piece, y: piece.y+1 }))){
          lockAcc += dt;
          if(lockAcc >= LOCK_DELAY){
            const ok = lockPiece();
            piece = null;

            if(!ok){
              end("over");
              return;
            }

            // resolve clears (chains)
            resolve();

            if(virusCount<=0){
              end("win");
              return;
            }

            // next
            piece = newPiece();
            lockAcc = 0;
            fallAcc = 0;

            // spawn collision immediate => over
            if(!canPlaceCells(cellsOf(piece))){
              end("over");
              return;
            }
          }
        }else{
          lockAcc = 0;
        }
      }

      requestAnimationFrame(step);
    }

    // ===== 入力（PC） =====
    window.addEventListener("keydown", (e)=>{
      if(!running) return;
      if(e.key==="ArrowLeft"){ e.preventDefault(); keyLeft=true; tryMove(-1,0); }
      if(e.key==="ArrowRight"){ e.preventDefault(); keyRight=true; tryMove(1,0); }
      if(e.key==="ArrowDown"){ e.preventDefault(); keyDown=true; }
      if(e.key==="ArrowUp"){ e.preventDefault(); tryRotate(1); }
      if(e.key===" "){ e.preventDefault(); hardDrop(); }
    }, {passive:false});

    window.addEventListener("keyup", (e)=>{
      if(e.key==="ArrowLeft") keyLeft=false;
      if(e.key==="ArrowRight") keyRight=false;
      if(e.key==="ArrowDown") keyDown=false;
    });

    // ===== 入力（ボタン） =====
    leftBtn.addEventListener("click", ()=>{ if(running) tryMove(-1,0); });
    rightBtn.addEventListener("click", ()=>{ if(running) tryMove(1,0); });
    rotBtn.addEventListener("click", ()=>{ if(running) tryRotate(1); });

    // ===== 入力（タッチ：スワイプ移動／タップ回転／下スワイプで落下） =====
    let sx=null, sy=null, st=0, swiped=false;
    cv.addEventListener("pointerdown", (e)=>{
      if(!running) return;
      cv.setPointerCapture(e.pointerId);
      sx = e.clientX; sy = e.clientY; st = performance.now();
      swiped = false;
    });
    cv.addEventListener("pointermove", (e)=>{
      if(!running || sx==null) return;
      const dx = e.clientX - sx;
      const dy = e.clientY - sy;

      // 横スワイプで移動（段階的）
      if(Math.abs(dx) > 26 && Math.abs(dx) > Math.abs(dy)){
        swiped = true;
        tryMove(dx>0 ? 1 : -1, 0);
        sx = e.clientX; sy = e.clientY;
      }

      // 下スワイプでソフトドロップON
      if(dy > 40 && Math.abs(dy) > Math.abs(dx)){
        swiped = true;
        softDrop = true;
        keyDown = true;
      }
    });
    cv.addEventListener("pointerup", (e)=>{
      if(!running) return;
      if(sx==null) return;

      const dt = performance.now() - st;
      const dx = e.clientX - sx;
      const dy = e.clientY - sy;

      // 短タップなら回転
      if(!swiped && dt < 260 && Math.abs(dx) < 10 && Math.abs(dy) < 10){
        tryRotate(1);
      }

      // スワイプ終わりでソフト解除
      keyDown = false;
      softDrop = false;

      sx=null; sy=null;
    });

    // ===== UI =====
    btnStart.addEventListener("click", ()=>{
      ov.classList.remove("on");
      how.classList.remove("on");
      reset();
      running = true;
      btnStart.disabled = true;
      btnStart.textContent = "PLAYING…";
      lastT = 0;
      resize();
      draw();
      requestAnimationFrame(step);
    });

    btnRetry.addEventListener("click", ()=>{
      ov.classList.remove("on");
      reset();
      running = true;
      btnStart.disabled = true;
      btnStart.textContent = "PLAYING…";
      lastT = 0;
      resize();
      draw();
      requestAnimationFrame(step);
    });

    btnClose.addEventListener("click", ()=> ov.classList.remove("on"));

    btnHow.addEventListener("click", ()=> how.classList.add("on"));
    btnHowClose.addEventListener("click", ()=> how.classList.remove("on"));
    how.addEventListener("click", (e)=>{ if(e.target===how) how.classList.remove("on"); });
    ov.addEventListener("click", (e)=>{ if(e.target===ov) ov.classList.remove("on"); });

    // 初期
    resize();
    grid = emptyGrid();
    seedViruses();
    piece = null;
    draw();
  </script>
</body>
</html>
