<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Halloween Photo Frame</title>
<style>
  :root{ --bg:#0b1017; --fg:#e9f1f7; --muted:#9fb0c0; --acc:#ff9ed1; }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent }
  html,body{ height:100%; margin:0 }
  body{
    background:radial-gradient(1200px 900px at 70% -10%,#101826 0%,#0b1017 60%,#070a11 100%);
    color:var(--fg);
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif;
    overflow:hidden; touch-action:manipulation;
  }
  #wrap{ position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr }
  header{ text-align:center; padding:10px 16px; opacity:.9 }
  header h1{ margin:0; font-size:18px; letter-spacing:.06em; font-weight:800; text-transform:uppercase; }

  .main{ position:relative; display:grid; place-items:center; padding:10px }
  .panel{
    width:min(94vw,680px); aspect-ratio:9/16;
    max-height: calc(100dvh - 100px); /* ← 上下余白を確保（ボタン分） */
    background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.08);
    border-radius:18px; box-shadow:0 10px 28px rgba(0,0,0,.45);
    position:relative; overflow:hidden;
  }

  canvas{ position:absolute; inset:0; width:100%; height:100%; display:block }

  /* 🎃 フレーム画像 */
  .hw-frame{
    position:absolute; bottom:40px; left:50%;
    width:80%; height:auto; transform:translateX(-50%);
    pointer-events:none; opacity:1; transition:opacity .25s ease;
  }
  .hw-frame.hide{ opacity:0 }

  /* 🎮 ボタン */
  .controls{
    position:absolute; left:0; right:0; bottom:24px;
    display:flex; justify-content:center; gap:14px; z-index:10;
  }
  .btn{
    appearance:none; border:0; border-radius:14px;
    padding:14px 22px; font-size:16px; font-weight:700;
    background:linear-gradient(#ffb7dd,#ff86c1); color:#3b0b1f;
    box-shadow:0 6px 14px rgba(0,0,0,.35);
  }
  .btn.secondary{ background:linear-gradient(#c1d7ff,#8bb7ff); color:#0b1633 }
  .btn.ghost{ background:rgba(255,255,255,.12); color:#fff }
  input[type="file"]{ display:none } /* 既定のファイル入力は隠す */

  /* 👻演出 */
  .stinger{
    position:absolute; inset:0; display:grid; place-items:center;
    color:#fff; font-weight:900; font-size:30px; letter-spacing:.08em;
    opacity:0; pointer-events:none; transition:opacity .25s ease;
    text-shadow:0 0 18px rgba(255,0,50,.9);
  }
  .stinger.show{ opacity:1 }
  .glitch{
    position:absolute; inset:auto auto 52px 14px;
    font-size:12px; letter-spacing:.12em; opacity:0;
    mix-blend-mode:screen; text-shadow:0 0 6px rgba(255,0,80,.9);
    transition:opacity .25s ease;
  }
  .glitch.on{ opacity:.9 }

  .flash{ position:absolute; inset:0; background:#fff; opacity:0; pointer-events:none }
  .flash.on{ animation:flashBlink .18s ease }
  @keyframes flashBlink{ 0%{opacity:.95} 100%{opacity:0} }

  .noise{
    position:absolute; inset:0; pointer-events:none; opacity:0; mix-blend-mode:screen;
    background-image:
      repeating-linear-gradient(0deg,rgba(255,255,255,.05)0,rgba(255,255,255,.05)1px,rgba(0,0,0,0)2px),
      repeating-linear-gradient(90deg,rgba(255,255,255,.03)0,rgba(255,255,255,.03)1px,rgba(0,0,0,0)2px);
    filter:contrast(150%) brightness(120%) saturate(140%);
    transition:opacity .08s ease;
  }
  .noise.on{ opacity:.8; animation:flicker .3s steps(4,end) infinite }
  @keyframes flicker{
    0%{transform:translate(0,0)}25%{transform:translate(1px,-1px)}
    50%{transform:translate(-1px,1px)}75%{transform:translate(2px,0)}100%{transform:translate(0,0)}
  }
  .shake{ animation:shake .28s cubic-bezier(.36,.07,.19,.97) both }
  @keyframes shake{
    10%,90%{ transform:translate3d(-1px,0,0) }
    20%,80%{ transform:translate3d(2px,0,0) }
    30%,50%,70%{ transform:translate3d(-4px,0,0) }
    40%,60%{ transform:translate3d(4px,0,0) }
  }
  /* iOSなどでアドレスバーを除いた高さを使う */
html, body {
  height: 100%;
}

body {
  height: 100dvh; /* ← 「動的vh」でバー分を除外 */
}

</style>
</head>
<body>
<div id="wrap">
  <header><h1>HALLOWEEN PHOTO FRAME</h1></header>
  <div class="main">
    <div class="panel" id="panel">
      <canvas id="canvas"></canvas>
      <img id="hwFrame" class="hw-frame" alt="" />
      <div class="stinger" id="stinger"></div>
      <div class="glitch" id="glitch">…もう後ろにいる</div>
      <div class="flash" id="flash"></div>
      <div class="noise" id="noise"></div>

      <div class="controls">
        <label class="btn secondary" for="pick">写真を選ぶ</label>
        <button class="btn" id="shoot">撮る</button>
        <button class="btn ghost" id="save">保存</button>
        <input id="pick" type="file" accept="image/*" />
      </div>
    </div>
  </div>
</div>

<script type="module">
/* -------- util / state -------- */
// 動的アセット解決（Vercel/ローカル両対応）
const asset = (fileName) => {
  try{
    const p = location.pathname;
    // /YYYY-MM-DD または /YYYY-MM-DD/... の先頭ディレクトリを抽出
    const m = p.match(/^\/(\d{4}-\d{2}-\d{2})(?:\/.*)?$/);
    const base = m ? `/${m[1]}` : '';
    return `${base}/assets/${fileName.replace(/^\/+/, '')}`;
  }catch(e){
    // フォールバック（相対）
    return `assets/${fileName}`;
  }
};
const panel=document.getElementById('panel');
const cvs=document.getElementById('canvas');
const ctx=cvs.getContext('2d',{willReadFrequently:true});
const hwFrame=document.getElementById('hwFrame');
const pick=document.getElementById('pick');
const btnShoot=document.getElementById('shoot');
const btnSave=document.getElementById('save');
const stinger=document.getElementById('stinger');
const glitch=document.getElementById('glitch');
const noise=document.getElementById('noise');
const flash=document.getElementById('flash');

let basePhoto=null;
let currentZombie=null;
let cuteMode=true;
let lastComposedDataURL=null;

// ★ 背景専用オフスクリーン（背景だけにグリッチを掛ける）
const bg = document.createElement('canvas');
const bgCtx = bg.getContext('2d',{willReadFrequently:true});

const happyImg = new Image();
happyImg.src = asset('happy_halloween.png');

const zombieList=[
  asset('zombie_1.png'),
  asset('zombie_2.png'),
  asset('zombie_3.png'),
  asset('zombie_4.png'),
];

/* -------- assets -------- */
hwFrame.src=asset('hw_frame.png');

const se={
  shutter:new Audio(asset('se_shutter.m4a')),
  laugh:new Audio(asset('se_laugh_rev.m4a')),
  burst:new Audio(asset('se_noise_burst.m4a')),
};
function playSE(key,vol=1){
  const s=se[key]?.cloneNode(true);
  if(!s) return;
  s.volume=vol;
  s.play().catch(()=>{});
}

/* -------- layout -------- */
function fitCanvas(){
  const r = panel.getBoundingClientRect();
  cvs.width = 1080;
  cvs.height = Math.round(1080 * (r.height / r.width));
  // ★ オフスクリーン側も同サイズに
  bg.width = cvs.width;
  bg.height = cvs.height;
}

fitCanvas();
addEventListener('resize',fitCanvas);

/* -------- helpers -------- */
const loadImage=(src)=>new Promise((res,rej)=>{const i=new Image();i.onload=()=>res(i);i.onerror=rej;i.src=src;});
function updateFrameVisibility(){ hwFrame.classList.toggle('hide',!cuteMode); }
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
const randRange=(a,b)=>Math.random()*(b-a)+a;
const randFrom=(arr)=>arr[Math.floor(Math.random()*arr.length)];
function showNoise(on){ noise.classList.toggle('on',on); }
function screenFlash(){ flash.classList.remove('on'); void flash.offsetWidth; flash.classList.add('on'); }
let stT=null;
function flashStinger(text){ stinger.textContent=text; stinger.classList.add('show'); clearTimeout(stT); stT=setTimeout(()=>stinger.classList.remove('show'),1000); }

/* -------- drawing -------- */
// 背景（オフスクリーン）を描いてから本キャンバスへ貼る
function renderBackground(glitched=false){
  // 背景下地
  bgCtx.fillStyle = '#0b1017';
  bgCtx.fillRect(0,0,bg.width,bg.height);

  if(basePhoto){
    const fw=bg.width, fh=bg.height, pw=basePhoto.width, ph=basePhoto.height;
    const s=Math.max(fw/pw, fh/ph);
    const dw=pw*s, dh=ph*s, dx=(fw-dw)/2, dy=(fh-dh)/2;
    bgCtx.drawImage(basePhoto, dx, dy, dw, dh);
  }
  if(glitched){
    glitchSlices(8,6,bgCtx,bg.width,bg.height);
    chromaSplit(bgCtx,bg.width,bg.height);
  }
  // 本キャンバスへ背景を反映
  ctx.drawImage(bg,0,0);
}

// withGlitch: 背景にだけグリッチを適用、zombieAlpha: ゾンビの透明度
function drawScene(withGlitch=false, zombieAlpha=1){
  renderBackground(withGlitch);

  if(currentZombie && !cuteMode){
    const zW=currentZombie.width, zH=currentZombie.height;
    const targetW = randRange(cvs.width*0.9, cvs.width*1.2);  // 大きめ
    const scale = targetW / zW, targetH = zH * scale;
    const x = randRange(cvs.width*0.15, cvs.width*0.4);
    const y = randRange(cvs.height*0.05, cvs.height*0.25);

    ctx.save();
    ctx.globalAlpha = zombieAlpha * 0.97;  // フェード時にも効く
    ctx.drawImage(currentZombie, x, y, targetW, targetH);
    ctx.restore();
  }
}
/* グリッチ処理（背景用・任意のctxに適用できる版） */
function glitchSlices(n, strength, anyCtx, w, h){
  for(let i=0;i<n;i++){
    const hh = Math.floor(randRange(8, Math.max(10, h/10)));
    const y  = Math.floor(randRange(0, h - hh));
    const sh = Math.floor(randRange(-w/20, w/20)) * strength/4;
    const d  = anyCtx.getImageData(0, y, w, hh);
    anyCtx.putImageData(d, sh, y);
  }
}

function chromaSplit(anyCtx, w, h){
  const img = anyCtx.getImageData(0,0,w,h);
  const off = Math.floor(randRange(1,3));
  for(let y=0;y<h;y++){
    const row = y*w*4;
    for(let x=0;x<w-off;x++){
      const i=row+x*4, j=row+(x+off)*4, k=row+Math.max(0,x-off)*4;
      img.data[i]   = img.data[j];     // Rを右へ
      img.data[i+2] = img.data[k+2];   // Bを左へ
    }
  }
  anyCtx.putImageData(img,0,0);
}



/* -------- interactions -------- */
pick.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0];
  if(!f) return;
  basePhoto=await createImageBitmap(f,{resizeQuality:'high'});
  cuteMode=true;
  updateFrameVisibility();
  drawScene();
});

btnShoot.addEventListener('click', async ()=>{
  if(!basePhoto){ pick.click(); return; }

  cuteMode=true; updateFrameVisibility(); drawScene();
  playSE('shutter', .9); screenFlash();

  await sleep(300);
  panel.classList.add('shake'); showNoise(true); glitch.classList.add('on');
  playSE('burst', .8);

  // 4秒間、背景だけをグリッチ
  let tick=0;
  const timer=setInterval(()=>{
    panel.style.transform=`translate(${randRange(-6,6)}px,${randRange(-4,4)}px) rotate(${randRange(-1,1)}deg)`;
    panel.style.filter=`contrast(180%) hue-rotate(${randRange(-25,25)}deg) saturate(200%)`;
    drawScene(true);
    tick++;
  },100);

  await sleep(4000);
  clearInterval(timer);
  panel.style.transform=''; panel.style.filter='';

  await triggerZombie();
});

async function triggerZombie(){
  showNoise(true);
  currentZombie = await loadImage(randFrom(zombieList));
  cuteMode = false;
  updateFrameVisibility();

  // 🧟‍♂️ ゾンビをフェードイン（背景グリッチON）
  for(let a = 0; a <= 1.0; a += 0.1){
    await sleep(80);
    drawScene(true, a);
  }

  // 👻 笑い声のみ（テキスト表示は削除）
  playSE('laugh', .9);

  // 余韻：背景グリッチを0.5秒維持
  await sleep(500);
  drawScene(true, 1);

  // 🎃 ハロウィン画像を最前面に描画（フェードなし、固定）
  if (happyImg.complete) {
    drawScene(true, 1);
    ctx.save();
    const w = cvs.width * 0.8;
    const h = happyImg.height * (w / happyImg.width);
    const x = (cvs.width - w) / 2;
    const y = (cvs.height - h) / 2;
    ctx.drawImage(happyImg, x, y, w, h);
    ctx.restore();
  }

  // ✨ 最終フレームを保存対象に
  await sleep(300);
  showNoise(false);
  glitch.classList.remove('on');
  panel.classList.remove('shake');

  // 最後に静止した状態で保存
  drawScene(true, 1);
  if (happyImg.complete) {
    ctx.save();
    const w = cvs.width * 0.8;
    const h = happyImg.height * (w / happyImg.width);
    const x = (cvs.width - w) / 2;
    const y = (cvs.height - h) / 2;
    ctx.drawImage(happyImg, x, y, w, h);
    ctx.restore();
  }

  lastComposedDataURL = cvs.toDataURL('image/png', 0.92);
}

btnSave.addEventListener('click', ()=>{
  if(!lastComposedDataURL){ flashStinger('先に撮ってね📸'); return; }
  const a=document.createElement('a');
  a.href=lastComposedDataURL;
  a.download=`halloween_${Date.now()}.png`;
  a.click();
});

/* 初期描画 */
drawScene();
</script>
</body>
</html>
