<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b1020" />
  <title>冥王星発見（ブリンクコンパレータ）</title>
  <style>
    :root{
      --bg:#070b18;
      --ink:#eef3ff;
      --muted:rgba(238,243,255,.7);
      --panel:rgba(255,255,255,.08);
      --line:rgba(255,255,255,.14);
      --accent:#7cc0ff;
      --danger:#ff6b6b;
      --r:16px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:var(--bg);color:var(--ink);overflow:hidden}
    body{font-family: ui-sans-serif, system-ui, -apple-system, "Hiragino Sans", "Noto Sans JP", "Segoe UI", sans-serif;}
    .app{height:100%;display:flex;flex-direction:column}
    header{
      padding:12px 14px 10px;
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      border-bottom:1px solid var(--line);
      background:linear-gradient(to bottom, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .title{
      display:flex;flex-direction:column;gap:2px;
      min-width:0;
    }
    .title h1{font-size:14px;letter-spacing:.02em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .title p{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .hud{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .pill{
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background:rgba(255,255,255,.05);
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      display:flex;gap:6px;align-items:center;
    }
    .pill b{font-weight:700}
    .btn{
      appearance:none;border:1px solid var(--line);
      background:rgba(255,255,255,.07);
      color:var(--ink);
      border-radius:999px;
      padding:8px 12px;
      font-size:12px;
      cursor:pointer;
      touch-action:manipulation;
    }
    .btn:active{transform:translateY(1px)}
    main{flex:1;display:flex;align-items:stretch;justify-content:center;padding:12px}
    .stage{
      width:min(520px, 100%);
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }
    canvas{display:block;width:100%;height:100%;}
    .overlay{
      position:absolute;inset:0;
      display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.45), rgba(0,0,0,.75));
      padding:18px;
    }
    .card{
      width:min(420px, 100%);
      border:1px solid var(--line);
      background:rgba(8,12,28,.78);
      border-radius:18px;
      padding:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.6);
      backdrop-filter: blur(8px);
    }
    .card h2{font-size:16px;margin-bottom:8px}
    .card p{font-size:13px;color:var(--muted);line-height:1.6}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .row .btn{flex:1;min-width:140px}
    .hint{
      position:absolute;left:10px;bottom:10px;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(255,255,255,.05);
      font-size:12px;color:var(--muted);
      max-width:calc(100% - 20px);
    }
    .toast{
      position:absolute;top:10px;left:50%;transform:translateX(-50%);
      padding:8px 12px;border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid var(--line);
      font-size:12px;color:var(--ink);
      opacity:0;pointer-events:none;
      transition:opacity .18s ease;
    }
    .toast.show{opacity:1}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <h1>冥王星発見：ブリンクコンパレータ</h1>
        <p>切替で“動いた点”を見つけてタップ</p>
      </div>
      <div class="hud">
        <div class="pill">面 <b id="lv">1</b>/3</div>
        <div class="pill">残り <b id="life">3</b></div>
        <div class="pill">時間 <b id="time">0.0</b>s</div>
        <button class="btn" id="toggle">切替: 自動</button>
        <button class="btn" id="restartTop">リスタート</button>
      </div>
    </header>

    <main>
      <div class="stage" id="stage">
        <canvas id="c"></canvas>
        <div class="toast" id="toast"></div>
        <div class="hint" id="hint">自動点滅中。見つけたらその点をタップ。</div>

        <div class="overlay" id="overlay">
          <div class="card">
            <h2>ルール</h2>
            <p>
              星空が2枚の写真のように切り替わります。<br/>
              <b>1つだけ位置がズレる点</b>（冥王星）を見つけてタップしてください。<br/>
              面が進むほど星が増え、ズレ幅が小さくなります。
            </p>
            <div class="row">
              <button class="btn" id="start">開始</button>
              <button class="btn" id="how">操作：手動切替にする</button>
            </div>
          </div>
        </div>

      </div>
    </main>
  </div>

<script type="module">
  // 1日1アプリ ルール（今回は素材未使用）
  const asset = (p) => new URL(p, import.meta.url).toString();

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const elLv = document.getElementById('lv');
  const elLife = document.getElementById('life');
  const elTime = document.getElementById('time');
  const overlay = document.getElementById('overlay');
  const btnStart = document.getElementById('start');
  const btnHow = document.getElementById('how');
  const btnToggle = document.getElementById('toggle');
  const btnRestartTop = document.getElementById('restartTop');
  const hint = document.getElementById('hint');
  const toast = document.getElementById('toast');

  const DPR = Math.max(1, Math.min(3, devicePixelRatio || 1));

  const levels = [
    { stars: 200, jitter: 2.2, blinkMs: 220, timeLimit: 16, pickRadius: 10 },
    { stars: 320, jitter: 1.6, blinkMs: 190, timeLimit: 18, pickRadius: 9  },
    { stars: 460, jitter: 1.2, blinkMs: 170, timeLimit: 20, pickRadius: 8  },
  ];

  let W=0, H=0;
  let running=false;

  // state
  let levelIndex=0;
  let life=3;
  let t0=0;
  let elapsed=0;

  let autoBlink=true;
  let blinkPhase=0; // 0 or 1
  let lastBlink=0;

  // starfield data
  let stars=[]; // base positions
  let plutoBase=null; // base pos
  let plutoOffset=null; // offset vector used in phase 1
  let solved=false;

  function resize(){
    const rect = canvas.getBoundingClientRect();
    W = Math.floor(rect.width * DPR);
    H = Math.floor(rect.height * DPR);
    canvas.width = W;
    canvas.height = H;
  }
  new ResizeObserver(resize).observe(document.getElementById('stage'));
  resize();

  function rnd(min,max){ return min + Math.random()*(max-min); }

  function setupLevel(i){
    levelIndex = i;
    const cfg = levels[levelIndex];

    // generate stars (avoid too-close to edges)
    stars = [];
    for(let k=0;k<cfg.stars;k++){
      stars.push({
        x: rnd(14, W-14),
        y: rnd(14, H-14),
        r: rnd(0.7*DPR, 1.2*DPR),
        a: rnd(0.35, 0.95),
        wiggle: (Math.random() < 0.06) ? rnd(0.4*DPR, 0.8*DPR) : 0, // 6%だけ揺れる
        wiggleAng: rnd(0, Math.PI*2),
      });
    }

    // choose pluto point (hard): place near a brighter star to blend in
    const bright = stars
      .slice()
      .sort((a,b)=> (b.a*b.r) - (a.a*a.r))
      .slice(0, Math.max(8, Math.floor(stars.length * 0.08))); // top ~8%

    const anchor = bright[Math.floor(Math.random() * bright.length)];
    const nearR = rnd(6*DPR, 14*DPR);      // place nearby
    const nearA = rnd(0, Math.PI*2);
    plutoBase = {
      x: Math.max(40, Math.min(W-40, anchor.x + Math.cos(nearA)*nearR)),
      y: Math.max(40, Math.min(H-40, anchor.y + Math.sin(nearA)*nearR)),
    };
    // random offset direction with magnitude "jitter"
    const ang = rnd(0, Math.PI*2);
    const mag = cfg.jitter * DPR;
    plutoOffset = { x: Math.cos(ang)*mag, y: Math.sin(ang)*mag };

    blinkPhase = 0;
    lastBlink = performance.now();
    solved = false;

    elLv.textContent = (levelIndex+1);
    hint.textContent = autoBlink
      ? "自動点滅中。見つけたらその点をタップ。"
      : "手動切替。右上の「切替」でパカパカして見つける。";
  }

  function draw(){
    // bg
    ctx.clearRect(0,0,W,H);

    // subtle vignette
    const g = ctx.createRadialGradient(W*0.5,H*0.45,0, W*0.5,H*0.5, Math.max(W,H)*0.7);
    g.addColorStop(0, 'rgba(255,255,255,0.06)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // stars
    for(const s of stars){
      const dx = (blinkPhase===1 && s.wiggle) ? Math.cos(s.wiggleAng)*s.wiggle : 0;
      const dy = (blinkPhase===1 && s.wiggle) ? Math.sin(s.wiggleAng)*s.wiggle : 0;

      ctx.globalAlpha = s.a;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(s.x + dx, s.y + dy, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // pluto
    const phasePos = getPlutoPos(blinkPhase);
    // draw as slightly larger crisp dot
    ctx.fillStyle = solved ? 'rgba(124,192,255,1)' : 'rgba(230,236,255,0.85)';
    ctx.beginPath();
    ctx.arc(phasePos.x, phasePos.y, 1.1*DPR, 0, Math.PI*2);
    ctx.fill();

    // if solved, draw ring pulse
    if(solved){
      const r = (12 + 6*Math.sin(performance.now()/120)) * DPR;
      ctx.strokeStyle = 'rgba(124,192,255,0.55)';
      ctx.lineWidth = 2*DPR;
      ctx.beginPath();
      ctx.arc(phasePos.x, phasePos.y, r, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function getPlutoPos(phase){
    if(phase===0) return plutoBase;
    return { x: plutoBase.x + plutoOffset.x, y: plutoBase.y + plutoOffset.y };
  }

  function tick(now){
    if(!running){ return; }

    // time
    elapsed = (now - t0) / 1000;
    elTime.textContent = elapsed.toFixed(1);

    const cfg = levels[levelIndex];
    if(elapsed >= cfg.timeLimit){
      miss("時間切れ");
      if(life <= 0) return;
      // time reset for same level
      t0 = performance.now();
    }

    // blink
    if(autoBlink){
      if(now - lastBlink >= cfg.blinkMs){
        blinkPhase = 1 - blinkPhase;
        lastBlink = now;
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  function showToast(text, danger=false){
    toast.textContent = text;
    toast.style.borderColor = danger ? 'rgba(255,107,107,.45)' : 'rgba(255,255,255,.14)';
    toast.style.background = danger ? 'rgba(255,107,107,.12)' : 'rgba(255,255,255,.08)';
    toast.classList.add('show');
    setTimeout(()=>toast.classList.remove('show'), 700);
  }

  function hit(){
    solved = true;
    showToast("冥王星発見！", false);

    // advance after short delay
    setTimeout(()=>{
      solved = false;
      if(levelIndex < levels.length - 1){
        setupLevel(levelIndex + 1);
        t0 = performance.now();
      }else{
        finish();
      }
    }, 650);
  }

  function miss(reason){
    life -= 1;
    elLife.textContent = String(life);
    showToast("ミス："+reason, true);

    if(life <= 0){
      gameOver();
    }
  }

  function finish(){
    running=false;
    overlay.querySelector('h2').textContent = "クリア";
    overlay.querySelector('p').innerHTML =
      `全3面クリア。<br/>計測時間：<b>${elapsed.toFixed(1)}秒</b><br/>（最後の面の経過表示です）`;
    overlay.style.display = 'flex';
  }

  function gameOver(){
    running=false;
    overlay.querySelector('h2').textContent = "ゲームオーバー";
    overlay.querySelector('p').innerHTML =
      `残機がなくなりました。<br/>もう一度挑戦できます。`;
    overlay.style.display = 'flex';
  }

  function startGame(){
    overlay.style.display = 'none';
    life = 3;
    elLife.textContent = String(life);
    elTime.textContent = "0.0";
    setupLevel(0);
    t0 = performance.now();
    running=true;
    requestAnimationFrame(tick);
  }

  function manualToggle(){
    autoBlink = !autoBlink;
    btnToggle.textContent = autoBlink ? "切替: 自動" : "切替: 手動";
    hint.textContent = autoBlink
      ? "自動点滅中。見つけたらその点をタップ。"
      : "手動切替。右上の「切替」でパカパカして見つける。";
  }

  // input: click/touch on canvas -> check distance to BOTH phase positions
  function onPointer(e){
    if(!running) return;

    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * DPR;
    const y = (e.clientY - rect.top) * DPR;

    const cfg = levels[levelIndex];
    // forgiving: accept tap near either phase position
    const p0 = getPlutoPos(0);
    const p1 = getPlutoPos(1);
    const r = cfg.pickRadius * DPR;

    const d0 = (x-p0.x)**2 + (y-p0.y)**2;
    const d1 = (x-p1.x)**2 + (y-p1.y)**2;

    if(d0 <= r*r || d1 <= r*r){
      hit();
    }else{
      miss("違う星");
    }
  }

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    onPointer(e);
  }, {passive:false});

  btnToggle.addEventListener('click', ()=>{
    if(!running){
      autoBlink = !autoBlink;
      btnToggle.textContent = autoBlink ? "切替: 自動" : "切替: 手動";
      return;
    }
    if(autoBlink){
      // if auto, treat as "switch mode" (not frame)
      manualToggle();
    }else{
      // if manual, toggle phase
      blinkPhase = 1 - blinkPhase;
      lastBlink = performance.now();
      draw();
    }
  });

  btnRestartTop.addEventListener('click', ()=>{
    overlay.querySelector('h2').textContent = "ルール";
    overlay.querySelector('p').innerHTML =
      `星空が2枚の写真のように切り替わります。<br/>
       <b>1つだけ位置がズレる点</b>（冥王星）を見つけてタップしてください。<br/>
       面が進むほど星が増え、ズレ幅が小さくなります。`;
    overlay.style.display = 'flex';
    running=false;
  });

  btnStart.addEventListener('click', startGame);
  btnHow.addEventListener('click', ()=>{
    // set manual mode from title screen
    autoBlink = false;
    btnToggle.textContent = "切替: 手動";
    hint.textContent = "手動切替。右上の「切替」でパカパカして見つける。";
    showToast("手動切替にしました", false);
  });

  // initial
  btnToggle.textContent = "切替: 自動";
  overlay.style.display = 'flex';
  draw();
</script>
</body>
</html>
