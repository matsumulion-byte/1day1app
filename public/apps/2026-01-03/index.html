<!doctype html>
<html lang="ja">
<head>
  <!-- OGP AUTO-GENERATED START (do not edit by hand) -->
  <meta property="og:title" content="書き初め（1/3）">
  <meta name="twitter:title" content="書き初め（1/3）">
  <meta property="og:description" content="書き初め 1/3 指でもマウスでも書けます。筆圧は 速度 でそれっぽく変わります。 保存（PNG） 消す ひとつ戻す PC: Ctrl/⌘+S 保存 / Ctrl/⌘+Z 戻す / Esc 全消し">
  <meta name="twitter:description" content="書き初め 1/3 指でもマウスでも書けます。筆圧は 速度 でそれっぽく変わります。 保存（PNG） 消す ひとつ戻す PC: Ctrl/⌘+S 保存 / Ctrl/⌘+Z 戻す / Esc 全消し">
  <meta property="og:image" content="/2026-01-03/assets/hanshi.png">
  <meta name="twitter:image" content="/2026-01-03/assets/hanshi.png">
  <meta property="og:url" content="/2026-01-03/">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <!-- OGP AUTO-GENERATED END -->

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>書き初め（1/3）</title>
  <meta name="theme-color" content="#070a14" />
  <style>
    :root{
      --bg:#070a14;
      --ink:#f3f6ff;
      --muted:rgba(243,246,255,.72);
      --line:rgba(255,255,255,.14);
      --panel:rgba(255,255,255,.08);
      --good:#34d399;
      --danger:#fb7185;
      --r:18px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box;margin:0;padding:0;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;}
    html,body{
      height:100%;
      background:
        radial-gradient(1200px 700px at 30% 20%, rgba(96,165,250,.14), transparent 60%),
        radial-gradient(900px 600px at 70% 80%, rgba(52,211,153,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Sans","Noto Sans JP";
      overflow:hidden;
    }

    .wrap{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:14px;
    }

    .card{
      width:100%;
      max-width:980px;
      height:100%;
      max-height:980px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border-radius:calc(var(--r) + 8px);
      box-shadow:var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      position:relative;
    }
    .card:before{
      content:"";
      position:absolute;inset:-2px;
      background:
        radial-gradient(520px 280px at 20% 0%, rgba(96,165,250,.22), transparent 60%),
        radial-gradient(560px 300px at 80% 100%, rgba(52,211,153,.16), transparent 60%);
      pointer-events:none;
      filter:blur(2px);
      opacity:.9;
    }

    header{
      position:relative;
      padding:16px 16px 12px;
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:12px;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .title{font-weight:800;font-size:15px;letter-spacing:.02em;color:rgba(243,246,255,.92);}
    .badge{
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      padding:6px 10px;
      border-radius:999px;
      white-space:nowrap;
    }
    .sub{
      position:relative;
      padding:10px 16px 0;
      color:var(--muted);
      font-size:12px;
      line-height:1.5;
    }

    .stage{
      position:relative;
      flex:1;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
    }

    /* ★ここが肝：PCでも必ず縦長に固定（横に広がらない） */
    .paper{
      position:relative;
      width:min(520px, 92vw);     /* まず幅を縛る（横に広がる原因を潰す） */
      aspect-ratio: 1 / 1.414;    /* A系縦比率（縦長） */
      height:auto;                /* 高さは比率から算出 */
      max-height:100%;            /* 画面が低いときは潰れない */
      border-radius:calc(var(--r) + 10px);
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      background:transparent;
    }

    .tools{
      position:relative;
      padding:12px 12px 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      border-top:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(0,0,0,.00), rgba(0,0,0,.20));
    }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--ink);
      padding:12px 14px;
      border-radius:14px;
      font-weight:800;
      letter-spacing:.01em;
      cursor:pointer;
      transition:transform .06s ease, background .2s ease, border-color .2s ease;
      flex:1 1 200px;
      min-width:160px;
    }
    button:hover{background:rgba(255,255,255,.11);border-color:rgba(255,255,255,.22);}
    button:active{transform:translateY(1px) scale(.99);}
    button.primary{
      background:linear-gradient(180deg, rgba(52,211,153,.22), rgba(52,211,153,.10));
      border-color:rgba(52,211,153,.35);
    }
    button.danger{
      background:linear-gradient(180deg, rgba(251,113,133,.18), rgba(251,113,133,.08));
      border-color:rgba(251,113,133,.30);
    }
    button.ghost{background:rgba(255,255,255,.06);}

    .hint{
      flex:2 1 360px;
      min-width:240px;
      color:rgba(243,246,255,.62);
      font-size:12px;
      line-height:1.4;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      text-align:right;
      padding:2px 6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .toast{
      position:fixed;
      left:50%;bottom:18px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.70);
      border:1px solid rgba(255,255,255,.18);
      color:rgba(243,246,255,.92);
      padding:10px 12px;
      border-radius:999px;
      font-size:12px;
      opacity:0;
      pointer-events:none;
      transition:opacity .22s ease, transform .22s ease;
      box-shadow:0 12px 40px rgba(0,0,0,.55);
      max-width:min(92vw, 520px);
      text-align:center;
      z-index:10;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-2px);
    }

    @media (max-width: 520px){
      header{padding:14px 14px 10px}
      .sub{padding:10px 14px 0}
      .stage{padding:10px}
      .tools{padding:10px 10px 12px}
      button{min-width:140px}
      .paper{width:100%;} /* SPは横幅いっぱい→比率で縦長になる */
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="書き初め">
      <header>
        <div class="title">書き初め</div>
        <div class="badge">1/3</div>
      </header>

      <div class="sub">
        指でもマウスでも書けます。筆圧は<strong>速度</strong>でそれっぽく変わります。<br>
      </div>

      <div class="stage">
        <div class="paper" aria-label="書き初めキャンバス">
          <canvas id="c"></canvas>
        </div>
      </div>

      <div class="tools">
        <button id="save" class="primary" type="button">保存（PNG）</button>
        <button id="clear" class="danger" type="button">消す</button>
        <button id="undo" class="ghost" type="button">ひとつ戻す</button>
        <div class="hint">PC: Ctrl/⌘+S 保存 / Ctrl/⌘+Z 戻す / Esc 全消し</div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script type="module">
    // Vercel用のパス解決
    const DATE_SEGMENT = (location.pathname.match(/\d{4}-\d{2}-\d{2}/) || [""])[0];
    const DATE_BASE = DATE_SEGMENT ? `/${DATE_SEGMENT}/` : "/";
    const asset = (p) => {
      const clean = String(p || "").replace(/^\.?\//, "");
      return `${DATE_BASE}${clean}`;
    };

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: true });

    const $toast = document.getElementById("toast");
    const $save = document.getElementById("save");
    const $clear = document.getElementById("clear");
    const $undo = document.getElementById("undo");

    const bgImg = new Image();
    bgImg.decoding = "async";
    bgImg.src = asset("./assets/hanshi.png");
    let bgReady = false;

    function showToast(msg){
      $toast.textContent = msg;
      $toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> $toast.classList.remove("show"), 1100);
    }

    bgImg.onload = () => { bgReady = true; redrawFromStrokes(); };
    bgImg.onerror = () => { showToast("背景画像の読み込みに失敗しました"); };

    function resize(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);

      // 以降の描画座標はCSS px基準
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      redrawFromStrokes();
    }

    function setInkStyle(width){
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "rgba(16, 18, 24, 0.92)";
      ctx.lineWidth = width;
    }

    const strokes = [];
    let current = null;
    let isDown = false;
    let last = null;
    let lastT = 0;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function pointerPos(e){
      const r = canvas.getBoundingClientRect();
      return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
    }

    function drawBackground(){
      const rect = canvas.getBoundingClientRect();
      if(bgReady){
        ctx.drawImage(bgImg, 0, 0, rect.width, rect.height);
      }else{
        ctx.fillStyle = "rgba(0,0,0,.10)";
        ctx.fillRect(0,0,rect.width,rect.height);
      }
    }

    function redrawFromStrokes(){
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);

      drawBackground();

      for(const s of strokes){
        const pts = s.points;
        if(pts.length === 1){
          const p = pts[0];
          ctx.fillStyle = "rgba(16, 18, 24, 0.92)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, Math.max(2.2, p.w*0.28), 0, Math.PI*2);
          ctx.fill();
          continue;
        }

        for(let i=1;i<pts.length;i++){
          const a = pts[i-1], b = pts[i];
          const w = (a.w + b.w) * 0.5;

          setInkStyle(w);
          ctx.globalAlpha = 1;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();

          setInkStyle(w + 6);
          ctx.globalAlpha = 0.12;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();

          ctx.globalAlpha = 1;
        }
      }
    }

    function startStroke(e){
      isDown = true;
      canvas.setPointerCapture?.(e.pointerId);

      const p = pointerPos(e);
      const now = performance.now();
      last = p;
      lastT = now;

      const w0 = 8;
      current = { points: [{...p, w: w0}] };

      // 点
      ctx.fillStyle = "rgba(16, 18, 24, 0.92)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2);
      ctx.fill();
    }

    function moveStroke(e){
      if(!isDown || !current) return;

      const p = pointerPos(e);
      const now = performance.now();

      const dx = p.x - last.x;
      const dy = p.y - last.y;
      const dist = Math.hypot(dx, dy);
      const dt = Math.max(8, now - lastT);
      const speed = dist / dt;

      const w = clamp(14 - speed * 18, 3.5, 14);

      const pts = current.points;
      const prev = pts[pts.length - 1];
      pts.push({...p, w});

      const ww = (prev.w + w) * 0.5;

      setInkStyle(ww);
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.moveTo(prev.x, prev.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();

      setInkStyle(ww + 6);
      ctx.globalAlpha = 0.12;
      ctx.beginPath();
      ctx.moveTo(prev.x, prev.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();

      ctx.globalAlpha = 1;

      last = p;
      lastT = now;
    }

    function endStroke(){
      if(!isDown) return;
      isDown = false;

      if(current && current.points.length){
        strokes.push(current);
      }
      current = null;
      last = null;
    }

    function clearAll(){
      strokes.length = 0;
      redrawFromStrokes();
      showToast("消しました");
    }

    function undoOne(){
      if(!strokes.length){
        showToast("戻すものがありません");
        return;
      }
      strokes.pop();
      redrawFromStrokes();
      showToast("ひとつ戻しました");
    }

    function savePng(){
      const url = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      const ts = new Date();
      const pad = (n)=> String(n).padStart(2,"0");
      a.download = `kakizome_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.png`;
      a.href = url;
      document.body.appendChild(a);
      a.click();
      a.remove();
      showToast("保存しました");
    }

    canvas.addEventListener("pointerdown", (e)=>{ e.preventDefault(); startStroke(e); }, {passive:false});
    canvas.addEventListener("pointermove", (e)=>{ e.preventDefault(); moveStroke(e); }, {passive:false});
    window.addEventListener("pointerup", ()=> endStroke(), {passive:true});
    window.addEventListener("pointercancel", ()=> endStroke(), {passive:true});

    $clear.addEventListener("click", clearAll);
    $undo.addEventListener("click", undoOne);
    $save.addEventListener("click", savePng);

    window.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if((e.ctrlKey || e.metaKey) && k === "z"){ e.preventDefault(); undoOne(); }
      if((e.ctrlKey || e.metaKey) && k === "s"){ e.preventDefault(); savePng(); }
      if(k === "escape"){ e.preventDefault(); clearAll(); }
    }, {passive:false});

    // 初期化
    const ro = new ResizeObserver(()=> resize());
    ro.observe(canvas);
    window.addEventListener("orientationchange", ()=> setTimeout(resize, 120));
    window.addEventListener("resize", ()=> setTimeout(resize, 60));
    setTimeout(resize, 0);
  </script>
</body>
</html>
