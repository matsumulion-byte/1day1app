<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>松村スロット（モバイル対応）</title>
<style>
  /* 基本スケールを画面幅で調整 */
  :root{
    --reel-size: clamp(84px, 26vw, 140px);
    --gap: clamp(8px, 3vw, 16px);
    --speed: .9s;
  }
  html,body{margin:0;height:100%;background:#0b0c10;color:#fff;-webkit-tap-highlight-color:transparent}
  body{font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif}
  .wrap{max-width:680px;margin:0 auto;padding:24px 16px calc(24px + env(safe-area-inset-bottom));display:flex;flex-direction:column;gap:18px}
  h1{font-size:clamp(16px,4vw,20px);font-weight:700;margin:0;opacity:.9}
  .machine{display:flex;flex-direction:column;align-items:center;gap:14px;background:#12141a;border:1px solid #2a2f3a;border-radius:16px;padding:16px 12px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .reels{display:flex;gap:var(--gap);align-items:center;justify-content:center;touch-action:manipulation}
  .reel{
    width:var(--reel-size);height:var(--reel-size);overflow:hidden;position:relative;
    border-radius:12px;background:linear-gradient(180deg,#181b22,#12141a);border:1px solid #2a2f3a;
    box-shadow: inset 0 6px 20px rgba(0,0,0,.45);
  }
  .strip{position:absolute;left:0;top:0;width:100%}
  .cell{display:flex;align-items:center;justify-content:center;height:var(--reel-size);font-size:clamp(22px,6.5vw,28px);font-weight:800;letter-spacing:.02em}
  .controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;width:100%}
  button{
    appearance:none;border:0;border-radius:14px;padding:16px 18px;font-weight:800;font-size:clamp(15px,4.2vw,16px);
    background:#ffd400;color:#121212;cursor:pointer;transition:filter .15s ease, transform .06s ease;width:min(100%, 420px)
  }
  button:hover{filter:brightness(1.05)}
  button:active{transform:translateY(1px)}
  .muted{background:#2a2f3a;color:#d6d6d6}
  .panel{display:flex;flex-direction:column;gap:6px;align-items:center;padding:2px 8px}
  .result{min-height:28px;font-size:clamp(16px,4.2vw,18px);opacity:.95;text-align:center}
  .badge,.odds,.hint{font-size:clamp(10px,3.2vw,12px)}
  .hint{text-align:center;opacity:.6}
  .odds{opacity:.7}
  .badge{opacity:.7}
  .lightbar{
    height:6px;background:linear-gradient(90deg,#ffcf00,#ff7a00,#ff1f1f,#ff7a00,#ffcf00);
    background-size:200% 100%;border-radius:999px;animation:flow 2.6s linear infinite;opacity:.9;align-self:stretch
  }
  @keyframes flow{0%{background-position:0%}100%{background-position:200%}}
  .win{color:#7cffb3}
  .near{color:#ffd66e}
  .miss{color:#b6c0cd}

  /* 片手操作しやすいよう、画面が狭い時は縦の余白を詰める */
  @media (max-width:420px){
    .machine{padding:14px 10px}
  }

  /* 動きが苦手な人向け */
  @media (prefers-reduced-motion: reduce){
    .lightbar{animation:none}
    *{scroll-behavior:auto;transition:none!important}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>松村スロット</h1>
  <div class="machine">
    <div class="lightbar" aria-hidden="true"></div>
    <div class="reels" id="reels" aria-label="リール（タップで回転）" role="button"></div>
    <div class="controls">
      <button id="spinBtn">SPIN（タップ / スペース）</button>
      <button id="muteBtn" class="muted">読み上げ ON/OFF</button>
    </div>
    <div class="panel">
      <div class="result" id="result"></div>
      <div class="odds" id="odds"></div>
      <div class="hint">狙え：「松」「村」「です！」｜どこでもタップで回るよ</div>
    </div>
  </div>
  <div class="badge">© 1日1アプリ｜音量は端末のサイドボタンで調整</div>
</div>

<script>
/** ========= 設定 ========= */
const REELS = [
  ["松","村"],
  ["村","松","でしょう"],
  ["です！","ですか？","でしょう！"]
];

const PATTERNS = [
  { match: ["松","村","です！"],  label:"大当たり", class:"win",  say:"松村です！", weight: 3 },
  { match: ["松","村","ですか？"], label:"ニアミス", class:"near", say:"松村ですか？", weight:10 },
  { match: ["村","松","でしょう!"], label:"ニアミス", class:"near", say:"村松でしょう！", weight: 8 },
  { match: ["村","松","でしょう！"], label:"ニアミス", class:"near", say:"村松でしょう！", weight: 8 },
  { matchPrefix: ["松","村"], label:"惜しい！", class:"near", say:"惜しい！最後は『です！』！", weight: 15 },
  { matchSuffix: ["村","です！"], label:"惜しい！", class:"near", say:"最初は『松』が欲しい！",   weight: 12 }
];

const MISS_LINES = [
  "村、松、でしょう…？",
  "今日は“村松”の日？",
  "次こそ“松村です！”で！",
  "うーん、ちょい違う！"
];
const BIASED_DRAW = true;

/** ========= 内部実装 ========= */
const reelsEl = document.getElementById("reels");
const spinBtn = document.getElementById("spinBtn");
const muteBtn = document.getElementById("muteBtn");
const resultEl = document.getElementById("result");
const oddsEl = document.getElementById("odds");
let isSpinning = false;
let speechMuted = false;
const canVibrate = "vibrate" in navigator;

// DOM構築
const reelEls = REELS.map((symbols) => {
  const reel = document.createElement("div");
  reel.className = "reel";
  const strip = document.createElement("div");
  strip.className = "strip";
  reel.appendChild(strip);
  reelsEl.appendChild(reel);
  const many = [...symbols, ...symbols, ...symbols];
  many.forEach(t => {
    const cell = document.createElement("div");
    cell.className = "cell";
    const span = document.createElement("span");
    span.textContent = t;
    cell.appendChild(span);
    strip.appendChild(cell);
  });
  return { reel, strip, symbols: symbols, cellsCount: many.length };
});

const state = { indices: REELS.map(() => 0) };

function speak(text){
  if (speechMuted) return;
  // iOSはユーザー操作後のみ再生可：最初のタップで有効化される想定
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "ja-JP"; u.rate = 1.05;
  try { speechSynthesis.cancel(); speechSynthesis.speak(u); } catch(e){}
}

function vibro(pattern){ if (canVibrate) navigator.vibrate(pattern); }
function randomInt(n){ return Math.floor(Math.random()*n); }
function weightedChoice(arr) {
  const sum = arr.reduce((s,a)=>s+(a.weight??5),0);
  let r = Math.random()*sum;
  for (const a of arr){ r -= (a.weight??5); if (r<=0) return a; }
  return arr[arr.length-1];
}
function decideTargets(){
  if (BIASED_DRAW && Math.random() < 0.55){
    const candidates = PATTERNS.filter(p => p.match || p.matchPrefix || p.matchSuffix);
    const chosen = weightedChoice(candidates);
    if (chosen.match){
      return chosen.match.map((token,i)=> Math.max(0,REELS[i].indexOf(token)));
    }
    if (chosen.matchPrefix){
      const t = [];
      chosen.matchPrefix.forEach((tok,i)=> t[i] = Math.max(0, REELS[i].indexOf(tok)));
      t[2] = (REELS[2].indexOf("です！") === 0) ? 1 : 0; // あえて外す
      return t;
    }
    if (chosen.matchSuffix){
      const t = [];
      t[1] = REELS[1].indexOf(chosen.matchSuffix[0]);
      t[2] = REELS[2].indexOf(chosen.matchSuffix[1]);
      t[0] = REELS[0].indexOf("村"); // わざと外す
      return t.map(i=>i<0?0:i);
    }
  }
  return REELS.map(list => randomInt(list.length));
}

async function spin(){
  if (isSpinning) return;
  isSpinning = true;
  spinBtn.disabled = true;
  resultEl.textContent = "回転中…";
  resultEl.className = "result";
  vibro(10);

  const targets = decideTargets();
  const promises = reelEls.map((r,i)=> animateReelTo(r, targets[i], i));
  await Promise.all(promises);

  const visible = targets.map((idx,i)=> REELS[i][idx]);
  showOutcome(visible);
  spinBtn.disabled = false;
  isSpinning = false;
}

function animateReelTo(r, targetIndex, reelIndex){
  const symbols = r.symbols;
  const per = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--reel-size')) || 120;
  const cycles = 5 + reelIndex * 2; // 後ろのリールほど長い
  const targetRow = (symbols.length + targetIndex); // 2周目で止める
  const distanceRows = cycles * symbols.length + targetRow;
  const y = distanceRows * per;
  return new Promise(res=>{
    r.strip.style.transition = `transform var(--speed) cubic-bezier(.25,.9,.2,1)`;
    setTimeout(()=>{
      r.strip.style.transform = `translateY(-${y}px)`;
      setTimeout(()=>{
        r.strip.style.transition = 'none';
        r.strip.style.transform = `translateY(-${targetRow * per}px)`;
        state.indices[reelIndex] = targetIndex;
        res();
      }, 1000);
    }, reelIndex*120);
  });
}

function showOutcome(visible){
  const asText = visible.join(" / ");
  const hit = judge(visible);
  resultEl.textContent = hit.message;
  resultEl.className = `result ${hit.class}`;
  oddsEl.textContent = `結果: ${asText}`;

  if (hit.say) speak(hit.say);
  // 触覚：当たり>ニアミス>ハズレ でパターンを変える
  if (hit.class === "win") vibro([30,50,30]);
  else if (hit.class === "near") vibro([20,30,20]);
  else vibro(12);
}

function eqArr(a,b){ return a.length===b.length && a.every((v,i)=>v===b[i]); }
function judge(visible){
  for (const p of PATTERNS){
    if (p.match && eqArr(visible, p.match)){ return { message:`${p.label}｜${p.say}`, class:p.class, say:p.say }; }
    if (p.matchPrefix){
      const ok = p.matchPrefix.every((v,i)=> visible[i]===v);
      if (ok) return { message:`${p.label}｜${p.say}`, class:p.class, say:p.say };
    }
    if (p.matchSuffix){
      const ok = p.matchSuffix.every((v,i)=> visible[i+visible.length - p.matchSuffix.length]===v);
      if (ok) return { message:`${p.label}｜${p.say}`, class:p.class, say:p.say };
    }
  }
  const line = MISS_LINES[Math.floor(Math.random()*MISS_LINES.length)];
  return { message:`ハズレ｜${line}`, class:"miss", say: line };
}

// 操作系：タップ/クリック/キー
spinBtn.addEventListener("click", spin, { passive:true });
reelsEl.addEventListener("click", spin, { passive:true }); // どこでもタップで回す
document.addEventListener("keydown", e=>{
  if (e.code === "Space" || e.key === "Enter"){ e.preventDefault(); spin(); }
});

// 初回ヒント（iOSは操作後のみ可）
let hinted=false;
window.addEventListener("pointerdown", ()=>{
  if (!hinted && !speechMuted){ hinted=true; speak("狙え、松、村、です！"); }
},{once:true});

// ミュート切替
muteBtn.addEventListener("click", ()=>{
  speechMuted = !speechMuted;
  muteBtn.classList.toggle("muted", speechMuted);
  muteBtn.textContent = speechMuted ? "読み上げ：OFF" : "読み上げ：ON";
}, { passive:true });

// iOSのズーム誤爆対策（連続タップでのダブルタップズームを抑制）
let lastTouch=0;
document.addEventListener("touchend",(e)=>{
  const now = Date.now();
  if (now - lastTouch < 350){ e.preventDefault(); }
  lastTouch = now;
},{passive:false});
</script>
</body>
</html>
