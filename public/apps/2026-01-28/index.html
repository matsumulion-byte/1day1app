<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b0b0c" />
  <title>ダイイングメッセージ｜血文字メーカー</title>
  <style>
    :root{
      --bg:#0b0b0c;
      --panel:rgba(255,255,255,.08);
      --panel2:rgba(255,255,255,.12);
      --ink:#f3f4f6;
      --muted:rgba(243,244,246,.72);
      --line:rgba(255,255,255,.14);
      --accent:#ef4444;
      --r:16px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:var(--bg);color:var(--ink);overflow:hidden}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      touch-action:none; /* iOSのスクロール/ズーム抑制 */
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }

    header{
      padding:14px 14px 10px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .title{
      display:flex;flex-direction:column;gap:4px;
      min-width:0;
    }
    .title h1{
      font-size:15px;
      letter-spacing:.02em;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .title p{
      font-size:12px;color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .toolbar{
      display:flex; gap:8px; flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, .chip{
      border:1px solid var(--line);
      background:var(--panel);
      color:var(--ink);
      border-radius:999px;
      padding:9px 12px;
      font-size:12px;
      line-height:1;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
    }
    button:active{transform:translateY(1px)}
    button.primary{
      background:rgba(239,68,68,.18);
      border-color:rgba(239,68,68,.4);
    }

    .stage{
      position:relative;
      flex:1;
      padding:12px 12px 14px;
      min-height:0;
    }

    .paper{
      position:relative;
      height:100%;
      border-radius:24px;
      overflow:hidden;
      box-shadow:var(--shadow);
      border:1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(1200px 800px at 40% 10%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 600px at 80% 70%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    }
    .paper.paperLight{
      background:
        radial-gradient(1200px 800px at 40% 10%, rgba(0,0,0,.08), transparent 60%),
        radial-gradient(900px 600px at 80% 70%, rgba(0,0,0,.06), transparent 60%),
        linear-gradient(180deg, rgba(245,245,245,1), rgba(232,232,232,1));
      border-color:rgba(0,0,0,.10);
    }

    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    .hint{
      position:absolute;
      left:14px; right:14px; bottom:14px;
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      pointer-events:none;
    }
    .hint .badge{
      pointer-events:none;
      font-size:12px;
      color:var(--muted);
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.14);
      padding:8px 10px;
      border-radius:999px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .paperLight .hint .badge{
      background:rgba(255,255,255,.55);
      color:rgba(0,0,0,.65);
      border-color:rgba(0,0,0,.12);
    }

    .panel{
      padding:10px 14px 14px;
      border-top:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.06));
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
    }

    .controls{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }

    .slider{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      background:var(--panel);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
    }
    .slider input{ width:140px; accent-color: var(--accent); }

    .toggle{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      background:var(--panel);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
    }
    .toggle input{ width:18px; height:18px; accent-color: var(--accent); }

    .toast{
      position:absolute; top:14px; left:14px; right:14px;
      display:flex; justify-content:center;
      pointer-events:none;
    }
    .toast .t{
      max-width:520px;
      width:100%;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      color:var(--ink);
      padding:10px 12px;
      border-radius:14px;
      font-size:12px;
      line-height:1.35;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      opacity:0;
      transform:translateY(-6px);
      transition:.22s ease;
      text-align:center;
    }
    .toast .t.show{opacity:1; transform:translateY(0)}
    .paperLight .toast .t{
      background:rgba(255,255,255,.65);
      border-color:rgba(0,0,0,.12);
      color:rgba(0,0,0,.75);
    }
  </style>
</head>

<body>
  <div class="app" id="app">
    <header>
      <div class="title">
        <h1>ダイイングメッセージ</h1>
        <p>指で“血文字”を描く（にじみ・飛沫・垂れあり）</p>
      </div>
      <div class="toolbar">
        <button id="btnRandom" class="chip" type="button">例文</button>
        <button id="btnUndo" class="chip" type="button">1手戻す</button>
        <button id="btnClear" class="chip" type="button">全消し</button>
        <button id="btnSave" class="primary" type="button">画像保存</button>
      </div>
    </header>

    <div class="stage">
      <div class="paper" id="paper">
        <canvas id="c"></canvas>
        <canvas id="fx"></canvas>

        <div class="toast"><div class="t" id="toast"></div></div>

        <div class="hint">
          <div class="badge">指で書く／右下で太さ・垂れ調整</div>
          <div class="badge" id="badgeText">…</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <div class="controls">
          <div class="slider">
            <span>太さ</span>
            <input id="size" type="range" min="4" max="48" value="22" />
            <span id="sizeVal">22</span>
          </div>
          <div class="slider">
            <span>にじみ</span>
            <input id="blur" type="range" min="0" max="14" value="6" />
            <span id="blurVal">6</span>
          </div>
          <label class="toggle">
            <input id="drip" type="checkbox" checked />
            <span>垂れる</span>
          </label>
          <label class="toggle">
            <input id="splatter" type="checkbox" checked />
            <span>飛沫</span>
          </label>
          <label class="toggle">
            <input id="light" type="checkbox" />
            <span>白背景</span>
          </label>
        </div>

        <div class="controls">
          <button id="btnEraser" class="chip" type="button">消しゴム:OFF</button>
          <button id="btnFinish" class="chip" type="button">“遺言”確定</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ✅ 1日1アプリのルール：動的アセットは import.meta.url 経由
    const asset = (p) => new URL(p, import.meta.url).toString();

    const c = document.getElementById('c');
    const fx = document.getElementById('fx');
    const paper = document.getElementById('paper');

    const ctx = c.getContext('2d', { alpha: true });
    const fctx = fx.getContext('2d', { alpha: true });

    const sizeEl = document.getElementById('size');
    const blurEl = document.getElementById('blur');
    const dripEl = document.getElementById('drip');
    const splatterEl = document.getElementById('splatter');
    const lightEl = document.getElementById('light');

    const sizeVal = document.getElementById('sizeVal');
    const blurVal = document.getElementById('blurVal');

    const btnUndo = document.getElementById('btnUndo');
    const btnClear = document.getElementById('btnClear');
    const btnSave = document.getElementById('btnSave');
    const btnRandom = document.getElementById('btnRandom');
    const btnEraser = document.getElementById('btnEraser');
    const btnFinish = document.getElementById('btnFinish');

    const badgeText = document.getElementById('badgeText');
    const toast = document.getElementById('toast');

    // ---- state
    let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    let W = 0, H = 0;

    let drawing = false;
    let last = null;
    let lastT = 0;
    let eraser = false;

    // 履歴（軽量：ImageDataで数手分）
    const history = [];
    const HISTORY_MAX = 14;

    // 滴り（粒子）
    const drops = [];
    let raf = 0;

    const examples = [
      'まつむらは…',
      'あいつが…やった…',
      '犯人は…右の…',
      '冷蔵庫に…プリン…',
      'Wi-Fiのパスは…',
      '会議は…やめろ…',
      'ねこは…無事…',
      '先に…帰る…',
      'それ…違う…',
      '助けて…（※助けない）'
    ];

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1400);
    }

    function resize(){
      const r = paper.getBoundingClientRect();
      W = Math.max(1, Math.floor(r.width));
      H = Math.max(1, Math.floor(r.height));

      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      c.width = Math.floor(W * DPR);
      c.height = Math.floor(H * DPR);
      fx.width = Math.floor(W * DPR);
      fx.height = Math.floor(H * DPR);

      c.style.width = W + 'px';
      c.style.height = H + 'px';
      fx.style.width = W + 'px';
      fx.style.height = H + 'px';

      ctx.setTransform(DPR,0,0,DPR,0,0);
      fctx.setTransform(DPR,0,0,DPR,0,0);

      // 背景はCSS側。ここでは既存内容維持のため、再描画しない（必要なら最後の履歴を復元）
      if(history.length){
        const snap = history[history.length - 1];
        ctx.putImageData(snap, 0, 0);
      }
    }

    function pushHistory(){
      try{
        const snap = ctx.getImageData(0, 0, c.width, c.height);
        history.push(snap);
        if(history.length > HISTORY_MAX) history.shift();
      }catch(e){
        // iOSで稀に例外：無視
      }
    }

    function undo(){
      if(history.length <= 1){
        clearAll(false);
        return;
      }
      history.pop();
      const prev = history[history.length - 1];
      ctx.putImageData(prev, 0, 0);
      showToast('1手戻しました');
    }

    function clearAll(withToast=true){
      ctx.clearRect(0,0,W,H);
      fctx.clearRect(0,0,W,H);
      drops.length = 0;
      history.length = 0;
      pushHistory();
      if(withToast) showToast('全消ししました');
    }

    function setBadge(){
      const mode = eraser ? '消しゴム' : '血ペン';
      badgeText.textContent = `${mode}｜垂れ:${dripEl.checked?'ON':'OFF'}｜飛沫:${splatterEl.checked?'ON':'OFF'}`;
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function bloodColor(){
      // 黒背景/白背景で少し色を変える
      // ベース：暗赤＋少し茶色
      const base = lightEl.checked ? [120, 6, 14] : [160, 18, 24];
      return base;
    }

    function drawStamp(x, y, r, pressure, vx, vy){
      // “血”っぽい滲み：中心濃く、外側に薄い
      const [R,G,B] = bloodColor();

      const blur = Number(blurEl.value);
      ctx.save();
      ctx.globalCompositeOperation = eraser ? 'destination-out' : 'source-over';

      if(!eraser){
        ctx.shadowColor = `rgba(${R},${G},${B},${0.55})`;
        ctx.shadowBlur = blur * 1.6;
      }else{
        ctx.shadowBlur = 0;
      }

      const rad = r * (0.92 + pressure*0.12);
      const g = ctx.createRadialGradient(x, y, 0, x, y, rad);
      if(eraser){
        g.addColorStop(0, 'rgba(0,0,0,1)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
      }else{
        const a0 = 0.92;
        const a1 = 0.18;
        g.addColorStop(0, `rgba(${R},${G},${B},${a0})`);
        g.addColorStop(0.55, `rgba(${R},${G},${B},${0.55})`);
        g.addColorStop(1, `rgba(${R},${G},${B},${a1})`);
      }

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(x, y, rad, rad*(0.88 + clamp(Math.hypot(vx,vy)/160,0,0.45)), Math.atan2(vy, vx), 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function maybeSplatter(x,y,vx,vy){
      if(!splatterEl.checked || eraser) return;
      const speed = Math.hypot(vx,vy);
      const chance = clamp((speed - 80) / 240, 0, 0.35);
      if(Math.random() > chance) return;

      const [R,G,B] = bloodColor();
      const n = 3 + Math.floor(Math.random()*7);
      for(let i=0;i<n;i++){
        const a = Math.random()*Math.PI*2;
        const d = 6 + Math.random()*28 + speed*0.05;
        const px = x + Math.cos(a)*d;
        const py = y + Math.sin(a)*d;
        const rr = 1 + Math.random()*3.5;

        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowColor = `rgba(${R},${G},${B},0.35)`;
        ctx.shadowBlur = Number(blurEl.value) * 0.9;
        ctx.fillStyle = `rgba(${R},${G},${B},${0.55})`;
        ctx.beginPath();
        ctx.arc(px, py, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    function spawnDrip(x,y,r,vx,vy){
      if(!dripEl.checked || eraser) return;

      // 下向き成分が少ないときは出にくく
      const down = clamp((vy + 40) / 180, 0, 1);
      if(Math.random() > 0.25*down) return;

      const [R,G,B] = bloodColor();
      const w = clamp(r*(0.18 + Math.random()*0.22), 1.2, 7);
      drops.push({
        x, y,
        vx: (Math.random()*0.8-0.4) + vx*0.001,
        vy: 0.2 + Math.random()*0.8,
        w,
        life: 900 + Math.random()*1200,
        col: [R,G,B]
      });
    }

    function dripTick(dt){
      if(!drops.length) return;
      fctx.clearRect(0,0,W,H);

      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        d.life -= dt;
        if(d.life <= 0){ drops.splice(i,1); continue; }

        d.vy += 0.0016 * dt; // gravity
        d.x += d.vx * dt;
        d.y += d.vy * dt;

        if(d.y > H + 30){
          drops.splice(i,1);
          continue;
        }

        // trail: fxに描いてから本体へ焼き込み
        const a = clamp(d.life/1600, 0, 1);
        const [R,G,B] = d.col;
        fctx.save();
        fctx.globalCompositeOperation = 'source-over';
        fctx.strokeStyle = `rgba(${R},${G},${B},${0.25*a})`;
        fctx.lineWidth = d.w;
        fctx.lineCap = 'round';
        fctx.shadowColor = `rgba(${R},${G},${B},${0.25*a})`;
        fctx.shadowBlur = Number(blurEl.value) * 1.2;

        fctx.beginPath();
        fctx.moveTo(d.x, d.y - Math.min(20, d.vy*6));
        fctx.lineTo(d.x, d.y);
        fctx.stroke();

        fctx.fillStyle = `rgba(${R},${G},${B},${0.55*a})`;
        fctx.beginPath();
        fctx.arc(d.x, d.y, d.w*0.9, 0, Math.PI*2);
        fctx.fill();
        fctx.restore();

        // たまに本体へ焼き込み（定着）
        if(Math.random() < 0.18){
          ctx.drawImage(fx, 0, 0, W, H);
          fctx.clearRect(0,0,W,H);
        }
      }
    }

    function step(t){
      if(!lastT) lastT = t;
      const dt = Math.min(40, t - lastT);
      lastT = t;
      dripTick(dt);
      raf = requestAnimationFrame(step);
    }

    function getPos(e){
      const r = paper.getBoundingClientRect();
      const x = (e.clientX - r.left);
      const y = (e.clientY - r.top);
      return { x: clamp(x,0,W), y: clamp(y,0,H) };
    }

    function startDraw(e){
      e.preventDefault();
      drawing = true;
      last = getPos(e);
      pushHistory(); // ストローク単位で戻せるように
      drawStamp(last.x, last.y, Number(sizeEl.value)*0.5, 0.9, 0, 0);
      setBadge();
    }

    function moveDraw(e){
      if(!drawing) return;
      e.preventDefault();

      const p = getPos(e);
      const now = performance.now();
      const dt = Math.max(8, now - (moveDraw._t || now));
      moveDraw._t = now;

      const vx = (p.x - last.x) / (dt/16);
      const vy = (p.y - last.y) / (dt/16);

      const base = Number(sizeEl.value);
      const speed = Math.hypot(vx,vy);
      const pressure = clamp(1 - speed/260, 0.25, 1);

      // 線分をスタンプで補間
      const dist = Math.hypot(p.x-last.x, p.y-last.y);
      const stepLen = clamp(base*0.28, 3.5, 16);
      const n = Math.max(1, Math.ceil(dist/stepLen));

      for(let i=1;i<=n;i++){
        const t = i/n;
        const x = last.x + (p.x-last.x)*t;
        const y = last.y + (p.y-last.y)*t;

        const r = (base*0.5) * (0.65 + pressure*0.55);
        drawStamp(x, y, r, pressure, vx, vy);
        maybeSplatter(x, y, vx*16, vy*16);
        spawnDrip(x, y, r, vx*18, vy*18);
      }

      last = p;
    }

    function endDraw(e){
      if(!drawing) return;
      e.preventDefault();
      drawing = false;
      last = null;

      // 滴りのfxを本体へ軽く焼き込み
      if(drops.length){
        ctx.drawImage(fx, 0, 0, W, H);
        fctx.clearRect(0,0,W,H);
      }
      showToast('書きました');
    }

    function saveImage(){
      // 合成（キャンバス2枚＋背景）
      const out = document.createElement('canvas');
      out.width = c.width;
      out.height = c.height;
      const o = out.getContext('2d');

      // 背景（CSSを再現：簡易）
      if(lightEl.checked){
        o.fillStyle = '#efefef';
        o.fillRect(0,0,out.width,out.height);
      }else{
        o.fillStyle = '#0b0b0c';
        o.fillRect(0,0,out.width,out.height);
      }

      o.drawImage(c, 0, 0);
      o.drawImage(fx, 0, 0);

      const a = document.createElement('a');
      const ts = new Date();
      const pad = (n)=>String(n).padStart(2,'0');
      const name = `dying-message_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.png`;
      a.download = name;
      a.href = out.toDataURL('image/png');
      a.click();
      showToast('画像を保存しました');
    }

    function setRandom(){
      const s = examples[Math.floor(Math.random()*examples.length)];
      showToast(`例文:「${s}」`);
    }

    function toggleEraser(){
      eraser = !eraser;
      btnEraser.textContent = `消しゴム:${eraser?'ON':'OFF'}`;
      btnEraser.classList.toggle('primary', eraser);
      setBadge();
      showToast(eraser ? '消しゴムに切替' : '血ペンに戻しました');
    }

    function finish(){
      const lines = [
        '遺言、確定しました。',
        'スクショして共有してください（責任は取りません）。'
      ];
      showToast(lines.join(' '));
    }

    function updateUI(){
      sizeVal.textContent = sizeEl.value;
      blurVal.textContent = blurEl.value;
      paper.classList.toggle('paperLight', lightEl.checked);
      setBadge();
    }

    // ---- events
    const onPointerDown = (e)=>{ if(e.isPrimary) startDraw(e); };
    const onPointerMove = (e)=>{ if(e.isPrimary) moveDraw(e); };
    const onPointerUp = (e)=>{ endDraw(e); };
    const onPointerCancel = (e)=>{ endDraw(e); };

    paper.addEventListener('pointerdown', onPointerDown, { passive:false });
    paper.addEventListener('pointermove', onPointerMove, { passive:false });
    paper.addEventListener('pointerup', onPointerUp, { passive:false });
    paper.addEventListener('pointercancel', onPointerCancel, { passive:false });
    paper.addEventListener('contextmenu', (e)=>e.preventDefault());

    // iOSのダブルタップ拡大/長押し選択を抑制
    document.addEventListener('gesturestart', (e)=>e.preventDefault());
    document.addEventListener('selectstart', (e)=>e.preventDefault());

    sizeEl.addEventListener('input', updateUI);
    blurEl.addEventListener('input', updateUI);
    dripEl.addEventListener('change', updateUI);
    splatterEl.addEventListener('change', updateUI);
    lightEl.addEventListener('change', updateUI);

    btnUndo.addEventListener('click', undo);
    btnClear.addEventListener('click', ()=>clearAll(true));
    btnSave.addEventListener('click', saveImage);
    btnRandom.addEventListener('click', setRandom);
    btnEraser.addEventListener('click', toggleEraser);
    btnFinish.addEventListener('click', finish);

    // ---- init
    window.addEventListener('resize', ()=>{ resize(); }, { passive:true });
    updateUI();
    clearAll(false);
    resize();
    raf = requestAnimationFrame(step);
    showToast('指で書いてください');
  </script>
</body>
</html>
