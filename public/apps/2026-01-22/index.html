<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b1020" />
  <title>カレー診断｜松村が聞く</title>
  <style>
    :root{
      --bg:#0b1020;
      --ink:#f3f6ff;
      --muted:rgba(243,246,255,.72);
      --line:rgba(255,255,255,.14);
      --panel:rgba(255,255,255,.08);
      --panel2:rgba(255,255,255,.12);
      --accent:#fbbf24;
      --good:#34d399;
      --bad:#fb7185;
      --r:18px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --safeT: env(safe-area-inset-top);
      --safeB: env(safe-area-inset-bottom);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{
      height:100%;
      min-height:100vh;
      min-height:100dvh;
      background:var(--bg); 
      color:var(--ink); 
      overflow:hidden;
    }
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      position:relative;
    }
    .app{
      height:100%;
      min-height:100vh;
      min-height:100dvh;
      display:flex;
      flex-direction:column;
      padding: calc(16px + var(--safeT)) 14px calc(14px + var(--safeB));
      gap:12px;
      max-width: 860px;
      margin: 0 auto;
      position:relative;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .brand{
      display:flex; align-items:baseline; gap:10px;
    }
    .brand h1{font-size:16px; letter-spacing:.04em}
    .brand .sub{font-size:12px; color:var(--muted)}
    .chip{
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      color:var(--muted);
      background: rgba(255,255,255,.03);
      user-select:none;
      white-space:nowrap;
    }
    .card{
      flex:1;
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:12px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 0;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.12);
    }
    .progress{
      flex:1;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .progress > i{
      display:block;
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(251,191,36,.95), rgba(251,191,36,.45));
      border-radius:999px;
      transition: width .25s ease;
    }
    .qcount{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }

    .stage{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      padding: 14px;
      min-height:0;
      align-items:stretch;
      overflow:visible;
      position:relative;
    }
    @media (max-width: 720px){
      .stage{ 
        grid-template-columns: 1fr; 
        grid-template-rows: auto auto;
      }
      .bubbleArea{
        order: 1;
        grid-row: 1;
      }
      .matsumura{
        order: 2;
        grid-row: 2;
        min-height: 140px;
        max-height: 140px;
        height: 140px;
      }
      .matsumura .imgWrap{
        max-height: 100px;
        height: 100px;
        flex: 0 0 100px;
      }
      .matsumura img{
        max-width: 120px;
        max-height: 100px;
        width:auto;
        height:auto;
        margin: 0 auto;
      }
    }

    .bubbleArea{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      position:relative;
      z-index:10;
    }
    .bubble{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      border-radius: 18px;
      padding: 14px 14px;
      position: relative;
    }
    .bubble:after{
      content:"";
      position:absolute;
      left:18px; bottom:-8px;
      width:16px; height:16px;
      background: rgba(255,255,255,.06);
      border-left:1px solid var(--line);
      border-bottom:1px solid var(--line);
      transform: rotate(45deg);
      border-bottom-left-radius: 4px;
    }
    .question{
      font-size: 20px;
      line-height: 1.35;
      letter-spacing: .02em;
    }
    .lead{
      margin-top:8px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }
    .choices{
      display:grid;
      gap:10px;
      margin-top: 12px;
      position:relative;
      z-index:10;
    }
    .btn{
      width:100%;
      text-align:left;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color:var(--ink);
      padding: 14px 14px;
      border-radius: 16px;
      font-size: 16px;
      line-height: 1.2;
      user-select:none;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      position:relative;
      z-index:10;
    }
    .btn:hover{ background: rgba(255,255,255,.075); border-color: rgba(255,255,255,.22); }
    .btn:active{ transform: translateY(1px) scale(.995); }
    .btn small{ display:block; margin-top:6px; color:var(--muted); font-size:12px; }

    .matsumura{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 18px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 240px;
      position:relative;
      z-index:0;
    }
    .matsumura .imgWrap{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px;
      background: radial-gradient(circle at 30% 20%, rgba(251,191,36,.18), rgba(0,0,0,0) 55%);
      position:relative;
      overflow:hidden;
      contain: layout style paint;
    }
    .matsumura img{
      max-width:100%;
      max-height:100%;
      width:auto;
      height:auto;
      object-fit:contain;
      filter: drop-shadow(0 14px 28px rgba(0,0,0,.45));
      transform: translateY(2px);
      pointer-events:none;
    }
    .matsumura .caption{
      padding: 10px 12px;
      border-top:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: rgba(0,0,0,.12);
    }
    .matsumura .caption b{ font-size:12px; letter-spacing:.08em }
    .matsumura .caption span{ font-size:12px; color:var(--muted); }

    .footer{
      display:flex;
      gap:10px;
      padding: 12px 14px;
      border-top:1px solid var(--line);
      background: rgba(0,0,0,.12);
      align-items:center;
      justify-content:space-between;
    }
    .ghost{
      border:1px solid var(--line);
      background: transparent;
      color: var(--muted);
      padding:10px 12px;
      border-radius: 14px;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
    }
    .ghost:active{ transform: translateY(1px); }
    .hint{ font-size:12px; color:var(--muted); }

    /* Result */
    .result{
      padding: 16px 14px;
      display:grid;
      gap:12px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      max-height: 100%;
    }
    .resultCard{
      border:1px solid var(--line);
      border-radius: 20px;
      background: rgba(255,255,255,.06);
      padding: 14px;
    }
    .resultTitle{
      display:flex;
      gap:10px;
      align-items:baseline;
      flex-wrap:wrap;
    }
    .resultTitle h2{ font-size: 22px; line-height:1.15; }
    .badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(251,191,36,.16);
      border:1px solid rgba(251,191,36,.35);
      color: rgba(255,255,255,.92);
    }
    .reasons{
      margin-top:10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.65;
    }
    .reasons li{ margin-left: 18px; margin-top: 4px; }
    .oneLiner{
      margin-top:10px;
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top: 12px;
    }
    .primary{
      border:1px solid rgba(251,191,36,.45);
      background: rgba(251,191,36,.18);
      color: var(--ink);
      padding: 12px 14px;
      border-radius: 16px;
      font-size: 14px;
      cursor:pointer;
      user-select:none;
    }
    .primary:active{ transform: translateY(1px); }
    .note{
      font-size:12px;
      color: var(--muted);
      margin-top: 4px;
    }

    /* toast */
    .toast{
      position:fixed;
      left:50%;
      bottom: calc(16px + var(--safeB));
      transform: translateX(-50%);
      background: rgba(0,0,0,.72);
      color: #fff;
      border: 1px solid rgba(255,255,255,.18);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      transform-origin:center;
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="brand">
        <h1>カレー診断</h1>
        <div class="sub">1/22｜松村が聞く</div>
      </div>
      <div class="chip" id="chip">全6問 / 3択</div>
    </header>

    <section class="card" id="card">
      <div class="topbar">
        <div class="progress" aria-label="progress"><i id="bar"></i></div>
        <div class="qcount" id="qcount">Q1 / 6</div>
      </div>

      <!-- question stage -->
      <div class="stage" id="stage">
        <div class="bubbleArea">
          <div class="bubble">
            <div class="question" id="question">読み込み中…</div>
            <div class="lead" id="lead">直感で選べ。悩むほどカレーは濁る。</div>
          </div>

          <div class="choices" id="choices"></div>
        </div>

        <aside class="matsumura" aria-label="matsumura">
          <div class="imgWrap">
            <!-- ファイル名は自由。assetsに置いて差し替えてください -->
            <img id="mimg" alt="インド人風松村" />
          </div>
          <div class="caption">
            <b>松村</b>
            <span id="mline">「質問に答えろ」</span>
          </div>
        </aside>
      </div>

      <!-- footer -->
      <div class="footer">
        <button class="ghost" id="resetBtn" type="button">最初から</button>
      </div>
    </section>
  </div>

  <div class="toast" id="toast">コピーしました</div>

  <script type="module">
    // Vercel用：相対パスを使用
    const asset = (p) => {
      const pathname = window.location.pathname;
      const basePath = pathname.endsWith('/') ? pathname : pathname + '/';
      return basePath + p.replace(/^\.\//, '');
    };

    // ====== 設定：画像ファイル名を合わせる ======
    // 例：/2026-01-22/assets/matsumura-india.png
    const MATSUMURA_IMG = asset("./assets/matsumura-india.png");

    // ====== 質問データ ======
    // 6問 / 3択。各択はカテゴリに1〜2個だけ加点（バグりにくい）
    const CATS = [
      "バターチキン",
      "キーマ",
      "欧風ビーフ",
      "スープカレー",
      "スパイスカレー",
      "グリーンカレー",
      "シーフードカレー",
      "カツカレー",
    ];

    // 同点時の決め打ち（乱数不要）
    const TIE_BREAK = [
      "スパイスカレー",
      "欧風ビーフ",
      "キーマ",
      "バターチキン",
      "スープカレー",
      "グリーンカレー",
      "カツカレー",
      "シーフードカレー",
    ];

    const Q = [
      {
        q: "辛さはどれが気分？",
        lead: "正直、気分で決まる。",
        a: [
          { t: "マイルド", s: { "バターチキン":2, "欧風ビーフ":1 } },
          { t: "中辛",     s: { "キーマ":2, "欧風ビーフ":1 } },
          { t: "辛口",     s: { "グリーンカレー":2, "スパイスカレー":1 } },
        ]
      },
      {
        q: "今日は時間ある？",
        lead: "工程は裏切らない。だが最短も正義。",
        a: [
          { t: "ない（最速）", s: { "キーマ":2, "カツカレー":1 } },
          { t: "そこそこ",     s: { "欧風ビーフ":2, "バターチキン":1 } },
          { t: "作り込みたい", s: { "スパイスカレー":2, "スープカレー":1 } },
        ]
      },
      {
        q: "テンションの欲しい方向は？",
        lead: "カレーは感情のハンドル。",
        a: [
          { t: "元気出したい",   s: { "カツカレー":2, "欧風ビーフ":1 } },
          { t: "落ち着きたい",   s: { "バターチキン":2, "シーフードカレー":1 } },
          { t: "上げ切りたい",   s: { "スパイスカレー":2, "グリーンカレー":1 } },
        ]
      },
      {
        q: "具の好み、どれ？",
        lead: "具で人格が出る（出ない）。",
        a: [
          { t: "ゴロゴロ肉", s: { "欧風ビーフ":2, "カツカレー":1 } },
          { t: "野菜多め",   s: { "スープカレー":2, "スパイスカレー":1 } },
          { t: "魚介",       s: { "シーフードカレー":2, "グリーンカレー":1 } },
        ]
      },
      {
        q: "外食するならどれ？",
        lead: "攻めるか、安定か、近さか。",
        a: [
          { t: "王道の店",   s: { "欧風ビーフ":2, "バターチキン":1 } },
          { t: "新規開拓",   s: { "スパイスカレー":2, "スープカレー":1 } },
          { t: "近場最優先", s: { "キーマ":2, "カツカレー":1 } },
        ]
      },
      {
        q: "食後に残したいのは？",
        lead: "余韻で選べ。",
        a: [
          { t: "コク",     s: { "欧風ビーフ":2, "バターチキン":1 } },
          { t: "香り",     s: { "スパイスカレー":2, "キーマ":1 } },
          { t: "爽快感",   s: { "グリーンカレー":2, "スープカレー":1 } },
        ]
      },
    ];

    // ====== 結果文（最小：カテゴリごとに固定） ======
    const RESULT_TEXT = {
      "バターチキン": {
        badge: "安心の甘コク",
        reasons: [
          "“落ち着き”を求める選択が多い。",
          "攻めより安定。今日は守りの勝ち。",
          "ミルキーなコクで回復が早い。",
        ],
        one: "迷ったらバター。だいたい救う。"
      },
      "キーマ": {
        badge: "最速でうまい",
        reasons: [
          "最短ルートを選べるタイプ。",
          "香りは欲しいが、工程は増やしたくない。",
          "粒感で満足度を稼げる。",
        ],
        one: "刻め。炒めろ。勝ちだ。"
      },
      "欧風ビーフ": {
        badge: "濃厚ど真ん中",
        reasons: [
          "コク重視の選択が多い。",
          "王道志向が強め。外さない判断。",
          "“元気”をドンと上げる方向。",
        ],
        one: "茶色は正義。"
      },
      "スープカレー": {
        badge: "軽やかに整う",
        reasons: [
          "野菜や爽快感に寄る傾向。",
          "作り込みたい欲が出ている。",
          "重すぎないのに満足できる。",
        ],
        one: "さらっとしてるのに、ちゃんと強い。"
      },
      "スパイスカレー": {
        badge: "攻めの香り",
        reasons: [
          "新規開拓・香り重視が強い。",
          "気分を上げ切りたい日。",
          "工程が増えても納得できるタイプ。",
        ],
        one: "香りで殴れ。"
      },
      "グリーンカレー": {
        badge: "辛×爽の暴走",
        reasons: [
          "辛口方面を選びがち。",
          "上げ切りたい気分が濃い。",
          "後味の抜けが必要な日。",
        ],
        one: "辛いのに涼しい、情緒。"
      },
      "シーフードカレー": {
        badge: "うま味で勝つ",
        reasons: [
          "落ち着き・うま味方向が多い。",
          "重すぎるパンチより余韻派。",
          "魚介の旨みで満足度が伸びる。",
        ],
        one: "海は裏切らない。"
      },
      "カツカレー": {
        badge: "脳が喜ぶ",
        reasons: [
          "元気を“即”取りに行くタイプ。",
          "工程より結果。潔い。",
          "満腹＝正解の日。",
        ],
        one: "勝ちたいならカツ。"
      }
    };

    // ====== DOM ======
    const $ = (s)=>document.querySelector(s);
    const questionEl = $("#question");
    const leadEl = $("#lead");
    const choicesEl = $("#choices");
    const qcountEl = $("#qcount");
    const barEl = $("#bar");
    const resetBtn = $("#resetBtn");
    const mlineEl = $("#mline");
    const stageEl = $("#stage");
    const cardEl = $("#card");
    const toastEl = $("#toast");
    const mimg = $("#mimg");

    // set image
    mimg.src = MATSUMURA_IMG;

    // ====== State ======
    let idx = 0;
    const scores = new Map(CATS.map(c=>[c,0]));
    const picked = []; // store chosen index for simple "理由"に使うなら拡張可

    // ====== Render ======
    const setProgress = ()=>{
      const total = Q.length;
      qcountEl.textContent = `Q${idx+1} / ${total}`;
      const pct = Math.round((idx)/total*100);
      barEl.style.width = `${pct}%`;
    };

    const setMLine = (t)=>{ mlineEl.textContent = t; };

    function renderQuestion(){
      const item = Q[idx];
      setProgress();
      questionEl.textContent = item.q;
      leadEl.textContent = item.lead ?? "直感で選べ。";

      choicesEl.innerHTML = "";
      item.a.forEach((opt, i)=>{
        const b = document.createElement("button");
        b.type = "button";
        b.className = "btn";
        b.innerHTML = `${["A","B","C"][i]}：${opt.t}`;
        b.addEventListener("click", ()=>choose(i), {passive:true});
        choicesEl.appendChild(b);
      });

      // ちょいセリフ（状態バグらない範囲）
      const lines = [
        "「答えろ」",
        "「迷うな」",
        "「カレーは逃げない」",
        "「直感でいけ」",
        "「それでいい」"
      ];
      setMLine(lines[idx % lines.length]);
    }

    function choose(choiceIndex){
      const item = Q[idx];
      const opt = item.a[choiceIndex];
      picked.push(choiceIndex);

      // 加点
      for (const [k,v] of Object.entries(opt.s)){
        scores.set(k, (scores.get(k) || 0) + v);
      }

      // 次へ
      idx++;
      if (idx >= Q.length){
        showResult();
      } else {
        renderQuestion();
      }
    }

    function decideCategory(){
      let max = -Infinity;
      let best = [];
      for (const c of CATS){
        const v = scores.get(c) || 0;
        if (v > max){ max = v; best = [c]; }
        else if (v === max){ best.push(c); }
      }
      if (best.length === 1) return best[0];
      // tie-break
      for (const t of TIE_BREAK){
        if (best.includes(t)) return t;
      }
      return best[0];
    }

    function showResult(){
      // progress full
      barEl.style.width = "100%";
      qcountEl.textContent = `結果 / ${Q.length}問`;
      setMLine("「お前のカレーは決まった」");

      const cat = decideCategory();
      const pack = RESULT_TEXT[cat] ?? {
        badge:"今日の気分",
        reasons:["直感がそう言ってる。","今日はそれでいい。","細かいことはいい。"],
        one:"カレーはすべてを許す。"
      };

      // 結果文（コピー用）
      const text =
`【カレー診断】「${cat}」
・${pack.reasons[0]}
・${pack.reasons[1]}
・${pack.reasons[2]}
ひとこと：${pack.one}`;

      // stage を結果に差し替え（DOM単純化）
      stageEl.innerHTML = `
        <div class="result">
          <div class="resultCard">
            <div class="resultTitle">
              <h2>「${escapeHtml(cat)}」</h2>
              <span class="badge">${escapeHtml(pack.badge)}</span>
            </div>
            <ul class="reasons">
              <li>${escapeHtml(pack.reasons[0])}</li>
              <li>${escapeHtml(pack.reasons[1])}</li>
              <li>${escapeHtml(pack.reasons[2])}</li>
            </ul>
            <div class="oneLiner">松村：${escapeHtml(pack.one)}</div>

            <div class="row">
              <button class="primary" id="copyBtn" type="button">結果をコピー</button>
              <button class="ghost" id="againBtn" type="button">もう一回</button>
            </div>
          </div>

          <div class="resultCard">
            <div class="brand" style="gap:8px">
              <h1 style="font-size:14px">コピー内容</h1>
              <div class="sub" style="font-size:12px;color:var(--muted)">そのまま貼れる</div>
            </div>
            <pre id="copyText" style="white-space:pre-wrap;word-break:break-word;margin-top:10px;font-size:13px;line-height:1.6;color:var(--muted)">${escapeHtml(text)}</pre>
          </div>
        </div>

        <aside class="matsumura" aria-label="matsumura">
          <div class="imgWrap">
            <img alt="インド人風松村" src="${MATSUMURA_IMG}" />
          </div>
          <div class="caption">
            <b>松村</b>
            <span>「異論は認めない」</span>
          </div>
        </aside>
      `;

      // bind buttons
      const copyBtn = $("#copyBtn");
      const againBtn = $("#againBtn");
      copyBtn?.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(text);
          toast("コピーしました");
        }catch(e){
          // フォールバック：選択させる
          const pre = $("#copyText");
          selectText(pre);
          toast("手動でコピーして");
        }
      }, {passive:true});

      againBtn?.addEventListener("click", reset, {passive:true});
    }

    function reset(){
      idx = 0;
      picked.length = 0;
      for (const c of CATS) scores.set(c, 0);

      // stage を元の質問構造に戻す（HTMLを再構築）
      stageEl.innerHTML = `
        <div class="bubbleArea">
          <div class="bubble">
            <div class="question" id="question"></div>
            <div class="lead" id="lead"></div>
          </div>
          <div class="choices" id="choices"></div>
        </div>

        <aside class="matsumura" aria-label="matsumura">
          <div class="imgWrap">
            <img id="mimg" alt="インド人風松村" />
          </div>
          <div class="caption">
            <b>松村</b>
            <span id="mline"></span>
          </div>
        </aside>
      `;

      // DOM参照を取り直し
      questionElRefetch();
      mimg.src = MATSUMURA_IMG;

      renderQuestion();
    }

    function questionElRefetch(){
      // stage内が差し替わるので参照を更新
      window._q = document.querySelector("#question");
      window._l = document.querySelector("#lead");
      window._c = document.querySelector("#choices");
      window._ml = document.querySelector("#mline");
      window._mi = document.querySelector("#mimg");

      // 参照を上書き
      questionEl = window._q; // eslint-disable-line no-func-assign
      leadEl = window._l;     // eslint-disable-line no-func-assign
      choicesEl = window._c;  // eslint-disable-line no-func-assign
      mlineEl = window._ml;   // eslint-disable-line no-func-assign
      mimg = window._mi;      // eslint-disable-line no-func-assign
    }

    // JSのconstを再代入できないので、参照を持ち直すために let にする
    // ↑が気になるなら最初から let にすればOK（下で再宣言）
  </script>

  <script type="module">
    // 上のscript内でconst再代入が出るのを避けるため、DOM参照はこのscriptで管理する
    // Vercel用：相対パスを使用
    const asset = (p) => {
      const pathname = window.location.pathname;
      const basePath = pathname.endsWith('/') ? pathname : pathname + '/';
      return basePath + p.replace(/^\.\//, '');
    };
    const MATSUMURA_IMG = asset("./assets/matsumura-india.png");

    const CATS = [
      "バターチキン","キーマ","欧風ビーフ","スープカレー",
      "スパイスカレー","グリーンカレー","シーフードカレー","カツカレー",
    ];
    const TIE_BREAK = ["スパイスカレー","欧風ビーフ","キーマ","バターチキン","スープカレー","グリーンカレー","カツカレー","シーフードカレー"];
    const Q = [
      { q:"辛さはどれが気分？", lead:"正直、気分で決まる。", a:[
        {t:"マイルド", s:{ "バターチキン":2, "欧風ビーフ":1 }},
        {t:"中辛",     s:{ "キーマ":2, "欧風ビーフ":1 }},
        {t:"辛口",     s:{ "グリーンカレー":2, "スパイスカレー":1 }},
      ]},
      { q:"今日は時間ある？", lead:"工程は裏切らない。だが最短も正義。", a:[
        {t:"ない（最速）", s:{ "キーマ":2, "カツカレー":1 }},
        {t:"そこそこ",     s:{ "欧風ビーフ":2, "バターチキン":1 }},
        {t:"作り込みたい", s:{ "スパイスカレー":2, "スープカレー":1 }},
      ]},
      { q:"テンションの欲しい方向は？", lead:"カレーは感情のハンドル。", a:[
        {t:"元気出したい", s:{ "カツカレー":2, "欧風ビーフ":1 }},
        {t:"落ち着きたい", s:{ "バターチキン":2, "シーフードカレー":1 }},
        {t:"上げ切りたい", s:{ "スパイスカレー":2, "グリーンカレー":1 }},
      ]},
      { q:"具の好み、どれ？", lead:"具で人格が出る（出ない）。", a:[
        {t:"ゴロゴロ肉", s:{ "欧風ビーフ":2, "カツカレー":1 }},
        {t:"野菜多め",   s:{ "スープカレー":2, "スパイスカレー":1 }},
        {t:"魚介",       s:{ "シーフードカレー":2, "グリーンカレー":1 }},
      ]},
      { q:"外食するならどれ？", lead:"攻めるか、安定か、近さか。", a:[
        {t:"王道の店",   s:{ "欧風ビーフ":2, "バターチキン":1 }},
        {t:"新規開拓",   s:{ "スパイスカレー":2, "スープカレー":1 }},
        {t:"近場最優先", s:{ "キーマ":2, "カツカレー":1 }},
      ]},
      { q:"食後に残したいのは？", lead:"余韻で選べ。", a:[
        {t:"コク",   s:{ "欧風ビーフ":2, "バターチキン":1 }},
        {t:"香り",   s:{ "スパイスカレー":2, "キーマ":1 }},
        {t:"爽快感", s:{ "グリーンカレー":2, "スープカレー":1 }},
      ]},
    ];

    const RESULT_TEXT = {
      "バターチキン": { badge:"安心の甘コク", reasons:["“落ち着き”を求める選択が多い。","攻めより安定。今日は守りの勝ち。","ミルキーなコクで回復が早い。"], one:"迷ったらバター。だいたい救う。" },
      "キーマ":       { badge:"最速でうまい", reasons:["最短ルートを選べるタイプ。","香りは欲しいが、工程は増やしたくない。","粒感で満足度を稼げる。"], one:"刻め。炒めろ。勝ちだ。" },
      "欧風ビーフ":   { badge:"濃厚ど真ん中", reasons:["コク重視の選択が多い。","王道志向が強め。外さない判断。","“元気”をドンと上げる方向。"], one:"茶色は正義。" },
      "スープカレー": { badge:"軽やかに整う", reasons:["野菜や爽快感に寄る傾向。","作り込みたい欲が出ている。","重すぎないのに満足できる。"], one:"さらっとしてるのに、ちゃんと強い。" },
      "スパイスカレー": { badge:"攻めの香り", reasons:["新規開拓・香り重視が強い。","気分を上げ切りたい日。","工程が増えても納得できるタイプ。"], one:"香りで殴れ。" },
      "グリーンカレー": { badge:"辛×爽の暴走", reasons:["辛口方面を選びがち。","上げ切りたい気分が濃い。","後味の抜けが必要な日。"], one:"辛いのに涼しい、情緒。" },
      "シーフードカレー": { badge:"うま味で勝つ", reasons:["落ち着き・うま味方向が多い。","重すぎるパンチより余韻派。","魚介の旨みで満足度が伸びる。"], one:"海は裏切らない。" },
      "カツカレー":   { badge:"脳が喜ぶ", reasons:["元気を“即”取りに行くタイプ。","工程より結果。潔い。","満腹＝正解の日。"], one:"勝ちたいならカツ。" },
    };

    const toastEl = document.querySelector("#toast");
    const barEl = document.querySelector("#bar");
    const qcountEl = document.querySelector("#qcount");
    const resetBtn = document.querySelector("#resetBtn");
    const stageEl = document.querySelector("#stage");

    const scores = new Map(CATS.map(c=>[c,0]));
    let idx = 0;

    function esc(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), 900);
    }

    function setProgress(){
      const total = Q.length;
      qcountEl.textContent = `Q${idx+1} / ${total}`;
      barEl.style.width = `${Math.round((idx)/total*100)}%`;
    }

    function renderQuestion(){
      const item = Q[idx];
      setProgress();

      stageEl.innerHTML = `
        <div class="bubbleArea">
          <div class="bubble">
            <div class="question" id="question">${esc(item.q)}</div>
            <div class="lead" id="lead">${esc(item.lead ?? "直感で選べ。")}</div>
          </div>
          <div class="choices" id="choices"></div>
        </div>

        <aside class="matsumura" aria-label="matsumura">
          <div class="imgWrap">
            <img alt="インド人風松村" src="${MATSUMURA_IMG}" />
          </div>
          <div class="caption">
            <b>松村</b>
            <span id="mline">${esc(["「答えろ」","「迷うな」","「カレーは逃げない」","「直感でいけ」","「それでいい」"][idx % 5])}</span>
          </div>
        </aside>
      `;

      const choicesEl = stageEl.querySelector("#choices");
      item.a.forEach((opt, i)=>{
        const b = document.createElement("button");
        b.type = "button";
        b.className = "btn";
        b.textContent = `${["A","B","C"][i]}：${opt.t}`;
        b.addEventListener("click", ()=>choose(i), {passive:true});
        choicesEl.appendChild(b);
      });
    }

    function choose(choiceIndex){
      const item = Q[idx];
      const opt = item.a[choiceIndex];
      for (const [k,v] of Object.entries(opt.s)){
        scores.set(k, (scores.get(k)||0) + v);
      }
      idx++;
      if (idx >= Q.length) showResult();
      else renderQuestion();
    }

    function decideCategory(){
      let max = -Infinity;
      let best = [];
      for (const c of CATS){
        const v = scores.get(c) || 0;
        if (v > max){ max = v; best = [c]; }
        else if (v === max){ best.push(c); }
      }
      if (best.length === 1) return best[0];
      for (const t of TIE_BREAK) if (best.includes(t)) return t;
      return best[0];
    }

    function showResult(){
      barEl.style.width = "100%";
      qcountEl.textContent = `結果 / ${Q.length}問`;

      const cat = decideCategory();
      const pack = RESULT_TEXT[cat];
      const text =
`【カレー診断】「${cat}」
・${pack.reasons[0]}
・${pack.reasons[1]}
・${pack.reasons[2]}
ひとこと：${pack.one}`;

      stageEl.innerHTML = `
        <div class="result">
          <div class="resultCard">
            <div class="resultTitle">
              <h2>「${esc(cat)}」</h2>
              <span class="badge">${esc(pack.badge)}</span>
            </div>
            <ul class="reasons">
              <li>${esc(pack.reasons[0])}</li>
              <li>${esc(pack.reasons[1])}</li>
              <li>${esc(pack.reasons[2])}</li>
            </ul>
            <div class="oneLiner">松村：${esc(pack.one)}</div>

            <div class="row">
              <button class="primary" id="copyBtn" type="button">結果をコピー</button>
              <button class="ghost" id="againBtn" type="button">もう一回</button>
            </div>
          </div>

          <div class="resultCard">
            <div class="brand" style="gap:8px">
              <h1 style="font-size:14px">コピー内容</h1>
              <div class="sub" style="font-size:12px;color:rgba(243,246,255,.72)">そのまま貼れる</div>
            </div>
            <pre id="copyText" style="white-space:pre-wrap;word-break:break-word;margin-top:10px;font-size:13px;line-height:1.6;color:rgba(243,246,255,.72)">${esc(text)}</pre>
          </div>
        </div>

        <aside class="matsumura" aria-label="matsumura">
          <div class="imgWrap">
            <img alt="インド人風松村" src="${MATSUMURA_IMG}" />
          </div>
          <div class="caption">
            <b>松村</b>
            <span>「異論は認めない」</span>
          </div>
        </aside>
      `;

      stageEl.querySelector("#copyBtn")?.addEventListener("click", async ()=>{
        try{
          await navigator.clipboard.writeText(text);
          toast("コピーしました");
        }catch{
          const pre = stageEl.querySelector("#copyText");
          const r = document.createRange();
          r.selectNodeContents(pre);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(r);
          toast("手動でコピーして");
        }
      }, {passive:true});

      stageEl.querySelector("#againBtn")?.addEventListener("click", reset, {passive:true});
    }

    function reset(){
      idx = 0;
      for (const c of CATS) scores.set(c, 0);
      renderQuestion();
    }

    resetBtn.addEventListener("click", reset, {passive:true});

    // 初期表示
    renderQuestion();
  </script>
</body>
</html>
