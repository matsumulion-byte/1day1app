<!doctype html>
<html lang="ja">
<head>
  <!-- OGP AUTO-GENERATED START (do not edit by hand) -->
  <meta property="og:title" content="マツジラ - MATSUMURA ATTACK / 2025-11-03">
  <meta name="twitter:title" content="マツジラ - MATSUMURA ATTACK / 2025-11-03">
  <meta property="og:description" content="1日1アプリ / 2025-11-03 マツジラ - MATSUMURA ATTACK 破壊率 0% TIME 45.0 SCORE 000000 前進 HOLD AUTO OFF 音 ON 松村です 松村、上陸す。 マツジラ 巨大な松村となって街を蹂躙せよ。 制限時間 45 秒">
  <meta name="twitter:description" content="1日1アプリ / 2025-11-03 マツジラ - MATSUMURA ATTACK 破壊率 0% TIME 45.0 SCORE 000000 前進 HOLD AUTO OFF 音 ON 松村です 松村、上陸す。 マツジラ 巨大な松村となって街を蹂躙せよ。 制限時間 45 秒">
  <meta property="og:image" content="/apps/2025-11-03/assets/heli.png">
  <meta name="twitter:image" content="/apps/2025-11-03/assets/heli.png">
  <meta property="og:url" content="/apps/2025-11-03/index.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <!-- OGP AUTO-GENERATED END -->

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>マツジラ - MATSUMURA ATTACK / 2025-11-03</title>
<style>
  :root{
    --bg:#090c11; --ink:#e9f1f7; --muted:#9fb0c0; --acc:#ff6b6b; --ok:#9ae6b4;
    --rail:#1a222c; --shadow:0 10px 28px rgba(0,0,0,.4);
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent }
  html,body{ height:100%; margin:0 }
  body{ background:radial-gradient(1200px 900px at 70% -10%, #0b1118 0%, #090c11 60%, #070a0f 100%); color:var(--ink); font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif; overflow:hidden }
  #wrap{ position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto; }

  header{ display:flex; align-items:center; gap:.75rem; padding:calc(8px + var(--safe-top)) 12px 8px 12px; backdrop-filter:saturate(140%) blur(8px); background:linear-gradient(to bottom, rgba(5,8,12,.65), rgba(5,8,12,.05)); border-bottom:1px solid #111620 }
  header h1{ font-size:14px; letter-spacing:.08em; margin:0; opacity:.9 }
  header .badge{ font-size:11px; color:#fff; background:#111c29; border:1px solid #1f2b3b; padding:.15rem .4rem; border-radius:6px }

  #hud{ position:fixed; inset:auto 0 auto 0; top:calc(8px + var(--safe-top)); display:flex; justify-content:center; gap:12px; pointer-events:none }
  .hud-pill{ pointer-events:auto; min-width:110px; text-align:center; background:rgba(15,20,28,.65); border:1px solid rgba(255,255,255,.06); border-radius:999px; box-shadow:var(--shadow); padding:.4rem .75rem; font-weight:700; font-variant-numeric:tabular-nums }
  .hud-pill small{ display:block; font-weight:600; color:var(--muted); font-size:10px; letter-spacing:.08em }

  #canvas{ width:100vw; height:100vh; display:block; touch-action: none; }

  /* Controls */
  #controls{ position:fixed; inset:auto 0 0 0; padding:8px 12px calc(10px + var(--safe-bottom)); display:flex; gap:10px; align-items:flex-end; justify-content:space-between; pointer-events:none }
  .btn{ pointer-events:auto; -webkit-user-select:none; user-select:none; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:.5rem; color:#fff; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:.6rem .9rem; box-shadow:var(--shadow); backdrop-filter:saturate(140%) blur(8px); transition:transform .02s }
  .btn:active{ transform:translateY(1px) }
  .btn .sub{ font-size:10px; color:var(--muted) }
  .btn.big{ height:64px; min-width:64px; border-radius:18px }
  .btn.circle{ width:64px; height:64px; border-radius:50% }
  .btn.warn{ border-color:rgba(255,0,0,.35) }

  #toast{ position:fixed; left:50%; top:18%; transform:translateX(-50%); padding:.6rem .8rem; background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.08); border-radius:12px; box-shadow:var(--shadow); display:none }

  /* Start / Result overlays */
  .overlay{ position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1200px 900px at 70% -10%, rgba(10,14,20,.8) 0%, rgba(10,14,20,.9) 60%, rgba(6,9,14,.95) 100%); color:#fff; z-index:10 }
  .overlay .card{ text-align:center; padding:24px; max-width:680px }
  .overlay h2{ font-size:28px; margin:.2rem 0 .6rem; letter-spacing:.12em }
  .overlay p{ color:var(--muted); margin:.25rem 0 }
  .overlay .katsuban{ font-size:12px; color:#c8d5e6; letter-spacing:.28em }
  .overlay .row{ display:flex; gap:12px; justify-content:center; margin-top:14px }

  .cinema{ position:fixed; inset:0; pointer-events:none; }
  .cinema::before, .cinema::after{ content:""; position:absolute; left:0; right:0; height:8%; background:linear-gradient(to bottom, rgba(0,0,0,.9), rgba(0,0,0,.2)); }
  .cinema::before{ top:0 } .cinema::after{ bottom:0; transform:scaleY(-1) }

  @media (min-width:900px){
    header h1{ font-size:16px }
    .btn.big{ height:72px; min-width:72px }
  }
</style>
</head>
<body>
  <div id="wrap">
    <header>
      <span class="badge">1日1アプリ / 2025-11-03</span>
      <h1>マツジラ - MATSUMURA ATTACK</h1>
    </header>

    <div id="hud">
      <div class="hud-pill" id="rate"><small>破壊率</small><span>0%</span></div>
      <div class="hud-pill" id="timer"><small>TIME</small><span>45.0</span></div>
      <div class="hud-pill" id="score"><small>SCORE</small><span>000000</span></div>
    </div>

    <canvas id="canvas"></canvas>
    <div class="cinema"></div>

    <div id="controls">
      <div style="display:flex; gap:10px; align-items:flex-end">
        <div class="btn big" id="moveBtn">前進<br><span class="sub">HOLD</span></div>
        <div class="btn" id="autoBtn">AUTO <span class="sub">OFF</span></div>
        <div class="btn" id="soundBtn">音 <span class="sub">ON</span></div>
      </div>
      <div style="display:flex; gap:10px; align-items:flex-end">
        <div class="btn circle warn" id="roarBtn" title="咆哮">松村です</div>
      </div>
    </div>

    <div id="toast"></div>

    <div class="overlay" id="start">
      <div class="card">
        <div class="katsuban">松村、上陸す。</div>
        <h2>マツジラ</h2>
        <p>巨大な松村となって街を蹂躙せよ。<br>制限時間 <b>45 秒</b>、破壊しまくってスコアを叩き出せ。</p>
        <div class="row">
          <div class="btn" id="startBtn">▶︎ スタート</div>
          <div class="btn" id="howBtn">？ 操作</div>
        </div>
        <p style="margin-top:8px;font-size:12px;color:#9fb0c0">長押しで前進／松村ですで咆哮（範囲破壊・クールダウンあり）</p>
      </div>
    </div>

    <div class="overlay" id="result" style="display:none">
      <div class="card">
        <div class="katsuban">TOKYO REPORT</div>
        <h2 id="rTitle">東京壊滅率 0%</h2>
        <p id="rDetail">SCORE 000000｜破壊数 0/0</p>
        <div class="row">
          <div class="btn" id="retryBtn">↻ もう一度</div>
          <div class="btn" id="shareBtn">共有用テキスト生成</div>
        </div>
      </div>
    </div>

  </div>

  <script type="module">
    // Vercel本番用に固定パス（public直下）
    const asset = (p)=> '/apps/2025-11-03/' + p.replace(/^\.\//,'');

    // ===== Audio (single definition) =====
    function pickAudio(candidates){
      const tester = new Audio();
      for(const p of candidates){
        const t = p.endsWith('.mp3') ? 'audio/mpeg' : p.endsWith('.m4a') ? 'audio/mp4' : '';
        if(!t || tester.canPlayType(t) !== '') return new Audio(asset(p));
      }
      return new Audio(asset(candidates[0]));
    }
    const sfx = {
      bgm: pickAudio(['./assets/bgm.mp3','./assets/bgm.m4a']),
      roar: pickAudio(['./assets/roar.m4a','./assets/roar.m4a']),
      explosions: [
        new Audio(asset('./assets/explosion1.mp3')),
        new Audio(asset('./assets/explosion2.mp3')),
        new Audio(asset('./assets/explosion3.mp3')),
      ]
    };
    sfx.bgm.loop = true; sfx.bgm.volume = 0.7;
    ['roar'].forEach(k=> sfx[k].volume = 0.85);
    sfx.explosions.forEach(a=>{ a.volume = 0.55; a.preload = 'auto'; });

    let soundOn = true;
    const soundBtn = document.getElementById('soundBtn');
    function play(audio){ if(!soundOn) return; try{ audio.currentTime=0; audio.play(); }catch(e){} }
    soundBtn.addEventListener('click', ()=>{
      soundOn = !soundOn;
      soundBtn.querySelector('.sub').textContent = soundOn ? 'ON':'OFF';
      if(soundOn) play(sfx.bgm); else sfx.bgm.pause();
    });

    // ===== Image assets =====
    const img = { tank: new Image(), heli: new Image() };
    img.tank.src = asset('./assets/tank.png');
    img.heli.src  = asset('./assets/heli.png');

    // === Player image (1枚歩行・特撮スーツ風) ===
    const walkImg = new Image();
    walkImg.src = asset('./assets/matsujira_side.png');

    // ===== Canvas setup =====
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // player must exist before resize uses it
    let player = { x:80, y:0, w:170, h:320, vx:0, speed:140, grounded:true, stepTimer:0 };
    let W=innerWidth, H=innerHeight; let DPR = Math.min(2, devicePixelRatio||1);
    function resize(){
      W=innerWidth; H=innerHeight; DPR=Math.min(2, devicePixelRatio||1);
      canvas.width=W*DPR; canvas.height=H*DPR; canvas.style.width=W+'px'; canvas.style.height=H+'px'; ctx.setTransform(DPR,0,0,DPR,0,0);
      if(player) player.y = H*0.78; // ground baseline
    }
    addEventListener('resize', resize, {passive:true}); resize();
    // iOS系の自動再生対策（初回タップで解放）
    addEventListener('pointerdown', ()=>{ if(soundOn){ play(sfx.bgm); } }, { once:true, passive:true });

    // ===== Game State =====
    const state = { running:false, time:45.0, score:0, destroyed:0, totalTargets:0, roarCD:0 };

    const UI = {
      rate: document.querySelector('#rate span'), timer: document.querySelector('#timer span'), score: document.querySelector('#score span'),
      toast: document.getElementById('toast'), start: document.getElementById('start'), startBtn: document.getElementById('startBtn'), howBtn: document.getElementById('howBtn'),
      result: document.getElementById('result'), rTitle: document.getElementById('rTitle'), rDetail: document.getElementById('rDetail'),
      retry: document.getElementById('retryBtn'), share: document.getElementById('shareBtn'),
      moveBtn: document.getElementById('moveBtn'), roarBtn: document.getElementById('roarBtn')
    };

    function fmt(n){ return n.toString().padStart(6,'0'); }

    // ---- Input (HOLD + AUTO) ----
    let holding = false;
    let marching = false; // default auto walk
    const autoBtn = document.getElementById('autoBtn');

    UI.moveBtn.addEventListener('pointerdown', (e)=>{ holding=true; UI.moveBtn.classList.add('active'); e.preventDefault(); });
    addEventListener('pointerup', ()=>{ holding=false; UI.moveBtn.classList.remove('active'); });
    autoBtn.addEventListener('click', ()=>{ marching=!marching; autoBtn.querySelector('.sub').textContent = marching ? 'ON':'OFF'; });
    addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.code==='ArrowRight') holding=true; if(e.code==='KeyF') triggerRoar(); if(e.code==='KeyA'){ marching=!marching; autoBtn.querySelector('.sub').textContent = marching ? 'ON':'OFF'; }});
    addEventListener('keyup', ()=>{ holding=false; });

    // ===== Parallax backgrounds (camera-follow) =====
    const layers = [
      { draw: ()=>{ // sky + faint glow
          const g = ctx.createLinearGradient(0,0,0,H);
          g.addColorStop(0,'#0a1017'); g.addColorStop(1,'#0a0d13');
          ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
          ctx.globalCompositeOperation='lighter';
          for(let i=0;i<3;i++){
            const x = ((i*400 - camera.x*0.05) % (W+400)) - 200;
            ctx.fillStyle = 'rgba(255,80,80,.08)';
            ctx.beginPath(); ctx.ellipse(x,H*.8,140,40,0,0,Math.PI*2); ctx.fill();
          }
          ctx.globalCompositeOperation='source-over';
        }
      },
      { draw: ()=>{ // mid city silhouettes
          ctx.fillStyle = '#0e1620';
          const baseY = H*.7;
          for(let i=0;i<20;i++){
            const x = ((i*220 - camera.x*0.6) % (W+400)) - 200;
            const w = 140 + (i%3)*40; const h = 120 + (i%4)*60;
            ctx.fillRect(x, baseY-h, w, h);
            ctx.fillStyle = 'rgba(255,230,120,.05)';
            for(let r=0;r<5;r++) for(let c=0;c<4;c++) ctx.fillRect(x+20+c*24, baseY-h+18+r*20, 6,10);
            ctx.fillStyle = '#0e1620';
          }
        }
      }
    ];

    // ===== Entities =====
    class Building{
      constructor(x,w,h){ this.x=x; this.y=H*0.78; this.w=w; this.h=h; this.dead=false; this.fall=0; this.rot=0; this.alpha=1; }
      rect(){ return {x:this.x, y:this.y-this.h, w:this.w, h:this.h}; }
      update(dt){ if(this.dead && this.fall<1){ this.fall += dt*.6; this.rot += dt*1.8; this.alpha = 1-this.fall; } }
      draw(){ ctx.save(); ctx.translate(this.x+this.w/2, this.y-this.h); ctx.rotate(this.rot*0.15); ctx.globalAlpha=Math.max(0,this.alpha); ctx.fillStyle='#1b2433'; ctx.fillRect(-this.w/2,0,this.w,this.h);
        ctx.fillStyle='rgba(255,240,160,.12)'; for(let r=0;r<Math.max(2,Math.floor(this.h/28));r++){ for(let c=0;c<Math.max(2,Math.floor(this.w/28));c++){ ctx.fillRect(-this.w/2+8+c*24, 10+r*22, 8,12); } } ctx.restore(); }
      destroy(){ if(!this.dead){ this.dead=true; state.destroyed++; state.score+=300; camera.shake(12); const cx=this.x+this.w/2; const cy=this.y-this.h*0.3; spawnDust(cx, this.y-12, 36, 1.1); burstAt(cx, cy, 1.1); burstAt(cx+this.w*0.2, cy-18, 0.7); burstAt(cx-this.w*0.2, cy-28, 0.7); } }
    }
    // ===== Destructible Props =====
    class Barrel{ // ドラム缶（連鎖爆発）
      constructor(x){ this.x=x; this.y=H*0.78-10; this.r=12; this.dead=false; }
      rect(){ return {x:this.x-this.r, y:this.y-24, w:this.r*2, h:24}; }
      update(dt){}
      draw(){ /* no visual for hitbox-like placeholder */ }
      destroy(){ if(this.dead) return; this.dead=true; state.destroyed++; state.score+=120; burstAt(this.x, this.y-10, 1.2); // 近傍に連鎖
        props.forEach(p=>{ if(!p.dead && Math.hypot(p.x-this.x, p.y-this.y) < 90) p.destroy?.(); }); }
    }
    class Car{ // 車（小爆発）
      constructor(x){ this.x=x; this.y=H*0.78-12; this.w=34; this.h=16; this.dead=false; }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h, w:this.w, h:this.h}; }
      update(dt){}
      draw(){ /* no visual for hitbox-like placeholder */ }
      destroy(){ if(this.dead) return; this.dead=true; state.destroyed++; state.score+=80; burstAt(this.x, this.y-12, 0.8); }
    }
    class Tank{
  constructor(x){
    this.x = x;
    this.y = H*0.78 - 18;
    this.v = -70 - Math.random()*40;
    this.dead = false;
  }
  update(dt){
    this.x += this.v*dt;
    if (this.x < -300) this.dead = true;
  }
  draw(){
    const s = 0.1; // 画像縮尺
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(s, s);
    ctx.drawImage(img.tank, 0, -img.tank.height*0.5);
    ctx.restore();
  }
}

class Heli{
  constructor(x){
    this.x = x;
    this.y = H*0.45 + (Math.random()*-60);
    this.v = -120 - Math.random()*80;
    this.dead = false;
    this.phase = Math.random()*6.28;
  }
  update(dt){
    this.x += this.v*dt;
    this.y += Math.sin(perf*2 + this.phase)*18*dt;
    if (this.x < -400) this.dead = true;
  }
  draw(){
    const s = 0.1; // 画像縮尺
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(s, s);
    ctx.drawImage(img.heli, 0, -img.heli.height*0.5);
    ctx.restore();
  }
}

    // Particles (dust + sparks + smoke + fireballs + debris)
    const dust = [];
    const sparks = [];
    const smokes = [];
    const fireballs = [];
    const debris = [];
    function spawnDust(x,y, n=24, pow=1){ for(let i=0;i<n;i++) dust.push({x,y,vx:(Math.random()*2-1)*140*pow, vy:(Math.random()*-1)*160*pow, g:520, life:1}); }
    function spawnSparks(x,y, n=16, pow=1){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2; const sp=180+Math.random()*220; sparks.push({x,y,vx:Math.cos(a)*sp*pow, vy:Math.sin(a)*sp*pow, life:.6+Math.random()*.4}); } }
    function spawnSmoke(x,y, n=14, pow=1){
      for(let i=0;i<n;i++){
        const r0 = 12 + Math.random()*20*pow;
        const shade = 0.25 + Math.random()*0.35; // 0=薄,1=濃
        const vy = -18 - Math.random()*28*pow;
        const vx = (Math.random()*2-1) * (8 + Math.random()*16); // 風で流れる
        const wobble = 12 + Math.random()*26; // 横揺れ強度
        const life = 2.2 + Math.random()*1.2*pow;
        const phase = Math.random()*6.28;
        smokes.push({x:x+(Math.random()*24-12), y:y+(Math.random()*12-6), r:r0, a:0.85, vy, vx, wobble, life, t:0, shade});
      }
    }
    function spawnFireball(x,y, pow=1){ fireballs.push({x,y, r:10, vr:220*pow, a:.9}); }
    function spawnDebris(x,y, n=10, pow=1){
      for(let i=0;i<n;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 160 + Math.random()*220*pow;
        debris.push({x,y, w:4+Math.random()*6, h:3+Math.random()*5, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-40, g:900, rot:Math.random()*6.28, vr:(Math.random()*2-1)*8, a:0.95});
      }
    }
    function updateDust(dt){
      for(let i=dust.length-1;i>=0;i--){ const p=dust[i]; p.vy+=p.g*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt; if(p.life<=0) dust.splice(i,1); }
      for(let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.x+=s.vx*dt; s.y+=s.vy*dt; s.vx*=0.98; s.vy*=0.98; s.life-=dt; if(s.life<=0) sparks.splice(i,1); }
      for(let i=smokes.length-1;i>=0;i--){
        const m=smokes[i];
        m.t += dt;
        m.y += m.vy*dt;
        m.x += (m.vx + Math.sin(m.t*1.6 + (m.shade*3)) * m.wobble) * 0.35 * dt;
        m.r += 16*dt;
        m.a -= 0.12*dt; // ゆっくり消える
        m.life -= dt;
        if(m.life<=0 || m.a<=0) smokes.splice(i,1);
      }
      for(let i=fireballs.length-1;i>=0;i--){ const f=fireballs[i]; f.r+=f.vr*dt; f.a-=0.9*dt; if(f.a<=0) fireballs.splice(i,1); }
      for(let i=debris.length-1;i>=0;i--){ const d=debris[i]; d.vy+=d.g*dt; d.x+=d.vx*dt; d.y+=d.vy*dt; d.rot+=d.vr*dt; d.a-=0.8*dt; if(d.a<=0) debris.splice(i,1); }
    }
    function drawDust(){
      ctx.save();
      // fireballs (additive, radial)
      ctx.globalCompositeOperation='lighter';
      for(const f of fireballs){ ctx.globalAlpha=Math.max(0,f.a); const g=ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,f.r); g.addColorStop(0,'rgba(255,200,80,.9)'); g.addColorStop(0.6,'rgba(255,120,60,.4)'); g.addColorStop(1,'rgba(255,80,40,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,Math.PI*2); ctx.fill(); }
      // dust quads
      for(const p of dust){ ctx.globalAlpha=Math.max(0,p.life); ctx.fillStyle='rgba(255,120,80,.22)'; ctx.fillRect(p.x-2,p.y-2,4,4); }
      // debris (dark fragments)
      ctx.globalCompositeOperation='source-over';
      for(const d of debris){ ctx.save(); ctx.globalAlpha=Math.max(0,d.a); ctx.translate(d.x,d.y); ctx.rotate(d.rot); ctx.fillStyle='rgba(50,56,66,.9)'; ctx.fillRect(-d.w/2,-d.h/2,d.w,d.h); ctx.restore(); }
      // sparks
      ctx.globalAlpha=1; ctx.strokeStyle='rgba(255,220,160,.7)'; ctx.lineWidth=2; for(const s of sparks){ ctx.globalAlpha=Math.max(0, s.life); ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x - s.vx*0.03, s.y - s.vy*0.03); ctx.stroke(); }
      // smoke (soft radial gradient, gray scale)
      ctx.globalCompositeOperation='source-over';
      for(const m of smokes){
        const a = Math.max(0, m.a);
        const g = ctx.createRadialGradient(m.x, m.y, m.r*0.1, m.x, m.y, m.r);
        const c0 = `rgba(30,34,42,${a*0.55 + m.shade*0.2})`;
        const c1 = `rgba(70,78,92,${a*0.25})`;
        const c2 = `rgba(70,78,92,0)`;
        g.addColorStop(0, c0);
        g.addColorStop(0.55, c1);
        g.addColorStop(1, c2);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
    }

    // ===== Explosion / burst effect =====
    function burstAt(x,y,pow=1){
      spawnDust(x,y, 32, pow);
      spawnSparks(x,y, 22, pow);
      spawnSmoke(x,y, 10+Math.floor(6*pow), Math.max(1,pow));
      spawnFireball(x,y, pow);
      spawnDebris(x,y, 10+Math.floor(6*pow), pow);
      camera.shake(11*pow);
      flashAlpha = Math.min(0.2*pow + flashAlpha, 0.45);
      // ランダム爆発音
      if (sfx.explosions && sfx.explosions.length) {
        const a = sfx.explosions[Math.floor(Math.random()*sfx.explosions.length)];
        play(a);
      }
      // ショックウェーブは残像防止のため出さない
      // 軽い連鎖（近傍の小物/建物）
      const chainR = 120 * pow;
      props.forEach(p=>{ if(!p.dead){ const r=p.rect(); const cx=r.x+r.w/2, cy=r.y+r.h/2; if(Math.hypot(cx-x, cy-y) < chainR && Math.random()<0.4) p.destroy?.(); }});
      buildings.forEach(b=>{ if(!b.dead){ const r=b.rect(); const cx=r.x+r.w/2, cy=r.y+r.h/2; if(Math.hypot(cx-x, cy-y) < chainR*0.8 && Math.random()<0.15) b.destroy(); }});
    }

    // Camera + shake
    const camera = { x:0, y:0, sx:0, sy:0, t:0, shake(pow=6){ this.t=Math.max(this.t,pow); }, update(dt){ if(this.t>0){ this.t-=dt*60; this.sx=(Math.random()*2-1)*(this.t*.5); this.sy=(Math.random()*2-1)*(this.t*.35); } else { this.sx=this.sy=0; } } };
    let flashAlpha = 0;

    // Player
    player = { x:80, y:H*0.78, w:170, h:320, vx:0, speed:140, grounded:true, stepTimer:0 };

    // World containers
    let buildings=[], enemies=[], props=[];
    let stageEnd = 0;
    function buildStage(){ buildings.length=0; enemies.length=0; props.length=0; dust.length=0; sparks.length=0; smokes.length=0; fireballs.length=0; debris.length=0; state.totalTargets=0; state.destroyed=0; state.score=0; state.roarCD=0; camera.t=0; flashAlpha=0; let x=80; const targetTime=45.0; const end = 80 + player.speed * targetTime + 1600; stageEnd = end; while(x<end){ const w=80+Math.floor(Math.random()*80); const h=90+Math.floor(Math.random()*150); buildings.push(new Building(x,w,h)); // 小物配置
        if(Math.random()<0.6) props.push(new Car(x + w*0.5 + 20 + Math.random()*40));
        if(Math.random()<0.45) props.push(new Barrel(x - 30 - Math.random()*50));
        x += w + (14+Math.random()*20); }
      // フィナーレゾーン（最後の約700px）に密集配置
      const finaleStart = end - 700;
      for(let i=0;i<6;i++){
        const bw = 70 + Math.floor(Math.random()*60);
        const bh = 160 + Math.floor(Math.random()*120);
        const bx = finaleStart + 60 + i*100;
        buildings.push(new Building(bx, bw, bh));
      }
      for(let j=0;j<12;j++){
        const px = finaleStart + 30 + j*50 + Math.random()*12;
        if(Math.random()<0.5) props.push(new Barrel(px)); else props.push(new Car(px));
      }
      recomputeTargets();
    }

    function recomputeTargets(){
      // 45秒で到達できる最大X（余裕を少し抑えて調整）
      const maxReach = 80 + player.speed * 45.0 + 120;
      let total = 0;
      for(const b of buildings){ const r=b.rect(); const centerX = r.x + r.w/2; if(centerX <= maxReach) total++; }
      for(const p of props){ const r=p.rect(); const centerX = r.x + r.w/2; if(centerX <= maxReach) total++; }
      state.totalTargets = total;
    }

    // Roar
    UI.roarBtn.addEventListener('click', triggerRoar);
    const waves=[];
    function triggerRoar(){ if(!state.running) return; if(state.roarCD>0) return; state.roarCD=6; play(sfx.roar); camera.shake(18);
      const radius=220; const cx = player.x + player.w*0.3; const cy = player.y-40;
      // 敵も巻き込んで破壊（サウンドなし）
      enemies.forEach(e=>{ if(Math.hypot(e.x-cx, e.y-cy) < radius){ burstAt(e.x, e.y, 1.1); e.dead = true; state.score += 200; }});
      // 建物・小物破壊
      buildings.forEach(b=>{ const r=b.rect(); const bx=r.x+r.w/2; const by=r.y+r.h/2; if(Math.hypot(bx-cx, by-cy) < radius*0.8) b.destroy(); });
      props.forEach(p=>{ const r=p.rect(); const bx=r.x+r.w/2; const by=r.y+r.h/2; if(Math.hypot(bx-cx, by-cy) < radius*0.9) p.destroy?.(); });
      // ショックウェーブ演出は無し（残像防止）
      // 画面フラッシュ強
      flashAlpha = Math.min(flashAlpha + 0.25, 0.45);
    }
    function spawnShockwave(x,y){ waves.push({x,y,r:8,a:0.5}); }
    function updateWaves(dt){ for(let i=waves.length-1;i>=0;i--){ const w=waves[i]; w.r+=dt*420; w.a-=dt*1.8; if(w.a<=0) waves.splice(i,1); } }
    function drawWaves(){ ctx.save(); ctx.strokeStyle='rgba(255,120,80,.35)'; ctx.lineWidth=4; for(const w of waves){ ctx.globalAlpha=Math.max(0,w.a); ctx.beginPath(); ctx.arc(w.x,w.y,w.r,0,Math.PI*2); ctx.stroke(); } ctx.restore(); }

    // Ground
    function drawGround(){ const y=H*.78; ctx.fillStyle='#0e141d'; ctx.fillRect(0,y,W,H-y); ctx.strokeStyle='rgba(255,120,80,.08)'; ctx.beginPath(); for(let i=0;i<12;i++){ const x=i*(W/12); ctx.moveTo(x,y); ctx.lineTo(x+20,y+8); } ctx.stroke(); }

    // Collision
    function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

    // Game loop
let last = performance.now() / 1000;
let perf = 0;


function loop(now){
  now /= 1000;
  const dt = Math.min(0.033, now - last);
  last = now;
  perf = now;

  if (state.running) {
    state.time -= dt;
    if (state.time < 0) { state.time = 0; endGame(); }
    if (state.roarCD > 0) state.roarCD -= dt;
  }

  camera.update(dt);

  // 移動（HOLD or AUTO）
  const moving = state.running && (holding || marching);
  if (moving) {
    player.vx = player.speed;
    player.stepTimer += dt;
    if (player.stepTimer > 0.28) { camera.shake(5); player.stepTimer = 0; }
  } else {
    player.vx = 0;
  }
  player.x += player.vx * dt;

  // 敵スポーン
  if (state.running) {
    spawnT -= dt;
    if (spawnT <= 0) {
      spawnT = 2.2 + Math.random() * 1.2;
      enemies.push(new Tank(W + Math.random() * 200 + camera.x));
    }
    spawnH -= dt;
    if (spawnH <= 0) {
      spawnH = 3.5 + Math.random() * 2.0;
      enemies.push(new Heli(W + 120 + Math.random() * 200 + camera.x));
    }
  }

  // 更新
  buildings.forEach(b => b.update(dt));
  enemies.forEach(e => e.update(dt));

  // ====== 敵の当たり判定（接触で破壊＋スコア加算）======
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.dead) { enemies.splice(i, 1); continue; }

    // プレイヤーと敵のワールド座標
    const px = player.x + player.w * 0.35;
    const py = player.y - player.h * 0.35;
    const ex = e.x;
    const ey = e.y;
    const dist = Math.hypot(ex - px, ey - py);

    // 半径判定を緩めて確実に接触を拾う
    const playerR = Math.max(player.w, player.h) * 0.33;
    const enemyR = (e.constructor && e.constructor.name === 'Tank') ? 26 : 22;

    // プレイヤーと接触で破壊（サウンドなし、ビジュアルのみ）
    if (dist < playerR + enemyR) {
      burstAt(ex, ey, 1.0);
      e.dead = true;
      enemies.splice(i, 1);
      state.score += 200;
      camera.shake(10);
    }
  }

  // ====== 敵同士の当たり判定（Tank と Heli が衝突で破壊）======
  for (let i = 0; i < enemies.length; i++) {
    const a = enemies[i]; if (a.dead) continue;
    for (let j = i + 1; j < enemies.length; j++) {
      const b = enemies[j]; if (b.dead) continue;
      const isPair = (a.constructor && b.constructor) && (
        (a.constructor.name === 'Tank' && b.constructor.name === 'Heli') ||
        (a.constructor.name === 'Heli' && b.constructor.name === 'Tank')
      );
      if (!isPair) continue;
      const d = Math.hypot(a.x - b.x, a.y - b.y);
      if (d < 70) {
        burstAt((a.x + b.x) * 0.5, (a.y + b.y) * 0.5, 0.9);
        if (!a.dead) { a.dead = true; state.score += 200; }
        if (!b.dead) { b.dead = true; state.score += 200; }
      }
    }
  }
  // dead 敵の一括クリーンアップ
  enemies = enemies.filter(e => !e.dead);

  // 足踏みで破壊（建物＋小物）
  const foot = { x: player.x + player.w * 0.05, y: player.y - 18, w: player.w * 0.6, h: 32 };
  buildings.forEach(b => { if (!b.dead && aabb(foot, { ...b.rect() })) b.destroy(); });
  props.forEach(p => { if (!p.dead && aabb(foot, { ...p.rect() })) p.destroy?.(); });

  // カメラ追従
  camera.x = Math.max(0, player.x - W * 0.35);

  // 描画
  ctx.clearRect(0, 0, W, H);
  layers.forEach(L => { ctx.save(); L.draw(perf); ctx.restore(); });

  ctx.save();
  ctx.translate(-camera.x + camera.sx, camera.sy);
  drawGround();
  buildings.forEach(b => b.draw());
  props.forEach(p => p.draw());
  enemies.forEach(e => e.draw());
  drawPlayer();
  drawDust();
  drawWaves();
  ctx.restore();

  postFilm();

  // UI
  UI.timer.textContent = state.time.toFixed(1);
  const rate = state.totalTargets ? Math.round(state.destroyed / state.totalTargets * 100) : 0;
  UI.rate.textContent = rate + '%';
  UI.score.textContent = fmt(state.score);

  requestAnimationFrame(loop);
}


    function drawPlayer(){
      window.__walkT = (window.__walkT||0) + (state.running? 0.12 : 0.08);
      const bobY = Math.sin(window.__walkT*2) * 3;
      const swayX = Math.sin(window.__walkT*1) * 1.6;
      const iw = walkImg.naturalWidth || 300; const ih = walkImg.naturalHeight || 600; const ratio = ih/iw;
      const targetH = Math.min(H*0.58, 360); const targetW = Math.round(targetH / ratio);
      player.h = targetH; player.w = targetW;
      ctx.save(); ctx.globalAlpha=0.5; ctx.beginPath(); ctx.ellipse(player.x+player.w*.35 + swayX, player.y+10, player.w*.55, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
      ctx.save(); ctx.globalAlpha=1.0; ctx.filter='contrast(115%) brightness(1.02) saturate(95%)'; ctx.drawImage(walkImg, player.x + swayX, player.y - player.h + bobY, player.w, player.h); ctx.filter='none'; ctx.restore();
    }

    function startGame(){ buildStage(); waves.length=0; flashAlpha=0; state.running=true; state.time=45.0; state.score=0; player.x=80; player.stepTimer=0; UI.start.style.display='none'; UI.result.style.display='none'; recomputeTargets(); if(soundOn) play(sfx.bgm); toast('長押しで前進 / 松村ですで咆哮'); }
    function endGame(){ state.running=false; sfx.bgm.pause(); const rate = state.totalTargets? Math.round(state.destroyed/state.totalTargets*100) : 0; UI.rTitle.textContent = `東京壊滅率 ${rate}%`; UI.rDetail.textContent = `SCORE ${fmt(state.score)}｜破壊数 ${state.destroyed}/${state.totalTargets}`; setTimeout(()=>{ UI.result.style.display='grid'; },600); }
    function toast(msg, ms=1400){ UI.toast.textContent=msg; UI.toast.style.display='block'; clearTimeout(toast.t); toast.t=setTimeout(()=>{ UI.toast.style.display='none'; }, ms); }

    UI.startBtn.addEventListener('click', startGame);
    UI.howBtn.addEventListener('click', ()=>toast('長押しで前進 / ROARで咆哮 / Space/→ でも可'));
    UI.retry.addEventListener('click', startGame);
    UI.share.addEventListener('click', ()=>{ const rate = state.totalTargets? Math.round(state.destroyed/state.totalTargets*100) : 0; const text = `#1日1アプリ 11/03 マツジラ
東京壊滅率 ${rate}%｜SCORE ${fmt(state.score)}
逃げろ。松村だ。`; navigator.clipboard?.writeText(text); toast('共有テキストをコピーしました'); });

    // Spawners
    let spawnT=0, spawnH=0;

    // === 特撮フィルム風処理 ===
    function postFilm(){
      // film grain removed to avoid white dots after explosions
      const g = ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*.45, W/2,H/2, Math.max(W,H)*.9); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,.32)'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='rgba(20,30,45,.08)'; ctx.fillRect(0,0,W,H);
      // screen flash for ROAR / explosions
      if (flashAlpha > 0) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, flashAlpha);
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,W,H);
        ctx.restore();
        flashAlpha *= 0.86;
        if (flashAlpha < 0.02) flashAlpha = 0;
      }
    }

    // Debug
    window.$ = { state, buildings, enemies, player, camera };

    // Kick
    requestAnimationFrame(loop);
  </script>
</body>
</html>
