<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>松村セクシーブロック崩し</title>
<style>
  :root{
    color-scheme: light dark;
    --bg:#0b0f14; --fg:#e8eef5; --muted:#8aa0b2;
    --brick:#122032; --brickLine:rgba(255,255,255,.06);
    --paddle:#eab308; --ball:#e5e7eb;
  }
  html,body{height:100%;margin:0}
  body{
    background:var(--bg); color:var(--fg);
    font-family:ui-sans-serif,system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif;
    display:flex; flex-direction:column; align-items:center; gap:10px
  }
  header{padding:10px 12px 0; width:min(720px,100%); box-sizing:border-box}
  header h1{margin:0; font-size:16px}
  header .sub{font-size:12px; color:var(--muted)}
  /* PCで巨大化しないよう幅/高さを制限。スマホは横幅フィット */
  #wrap{
    position:relative;
    width:min(420px, 90vw);
    max-height:90vh;
    aspect-ratio:9 / 16;   /* 縦長前提 */
    background:#0e141a;
    border-radius:16px; overflow:hidden;
    box-shadow:0 10px 30px rgba(0,0,0,.35)
  }
  canvas{width:100%; height:100%; display:block; touch-action:none; background:#080c11}
  .hud{position:absolute; inset:0; pointer-events:none; display:flex; flex-direction:column; padding:10px}
  .hud .top{display:flex; justify-content:space-between; font-weight:700; font-size:13px}
  .btnbar{position:absolute; inset:auto 0 10px; display:flex; justify-content:center; gap:10px; pointer-events:auto}
  .btn{background:#17202a; border:1px solid #1f2b37; color:var(--fg); padding:8px 12px; border-radius:12px; font-size:13px}
  .hint{position:absolute; inset:auto 0 60px; text-align:center; color:#cbd5e1; font-size:12px; opacity:.85}
  .overlay{position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(180deg,rgba(0,0,0,.5),rgba(0,0,0,.72))}
  .overlay.show{display:flex}
  .card{background:#0f1620; border:1px solid #1f2b37; padding:18px; border-radius:16px; width:min(90%,460px); text-align:center}
  .card h2{margin:0 0 8px; font-size:20px}
  .card p{margin:6px 0 14px; color:var(--muted)}
  .card button{all:unset; background:#34d399; color:#052017; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer}
</style>
</head>
<body>
  <header>
    <h1>松村セクシーブロック崩し（1面）</h1>
  </header>

  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="top">
        <div>Score: <span id="sc">0</span></div>
        <div>Lives: <span id="lv">3</span></div>
      </div>
    </div>
    <div class="hint">⏸ 一時停止 / 🔄 リセット は下のボタン</div>
    <div class="btnbar">
      <button class="btn" id="pauseBtn">⏸ 一時停止</button>
      <button class="btn" id="resetBtn">🔄 リセット</button>
    </div>

    <div class="overlay" id="ovl">
      <div class="card">
        <h2 id="ovlTitle">松村です！</h2>
        <p id="ovlMsg">クリアおめでとうございます！</p>
        <button id="againBtn">もう一度あそぶ</button>
      </div>
    </div>
  </div>

<script type="module">
/* 動的アセット（Vercel/ローカル両立） */
const asset = (p) => {
  const currentDir = window.location.pathname.replace(/\/[^\/]*$/, '/');
  return `${currentDir}assets/${p}`;
};
/* ===== 設定 ===== */
const PHOTO_FILE = asset("./assets/matsumura_photo.jpg"); // 差し替えOK

const CFG = {
  /* ブロック粒度：多すぎず少なすぎず */
  cols: 6,
  rows: 4,

  /* ご指定の上下マージン */
  marginTop: 250,     // ← 上マージン（px）
  marginBottom: 200,  // ← 下マージン（px）

  gap: 4,             // ブロックの隙間(px)
  wall: 12,           // 左右の壁マージン(px)

  /* パドル／ボール */
  ballSpeed: 6.0,
  ballRadius: 9,
  ballMax: 14,
  paddleW: 150,
  paddleH: 16,
  paddleBottom: 100,   // ← 画面下からパドルまでの距離（ご指定に合わせて100）
};

/* ===== 参照 ===== */
const wrap = document.getElementById("wrap");
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scEl = document.getElementById("sc");
const lvEl = document.getElementById("lv");
const pauseBtn = document.getElementById("pauseBtn");
const resetBtn = document.getElementById("resetBtn");
const ovl = document.getElementById("ovl");
const againBtn = document.getElementById("againBtn");
const ovlTitle = document.getElementById("ovlTitle");
const ovlMsg = document.getElementById("ovlMsg");

/* ===== 状態 ===== */
let DPR = Math.max(1, window.devicePixelRatio || 1);
let W = 0, H = 0;          // CSSピクセル基準
let photoImg = new Image(), photoReady = false;

let bricks = [];           // {x,y,w,h,hp}
let ball = {x:0,y:0,vx:0,vy:0,r:CFG.ballRadius, stuck:true};
let paddle = {x:0,y:0,w:CFG.paddleW,h:CFG.paddleH};
let score = 0, lives = 3;
let paused = false, gameOver = false, cleared = false;

/* ===== 画像 ===== */
function loadPhoto(src){
  return new Promise((res, rej)=>{
    const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=src;
  });
}

/* ===== リサイズ（DPR正しく）===== */
function fitCanvas(){
  const rect = wrap.getBoundingClientRect();
  const cssW = rect.width, cssH = rect.height;
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width  = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  // 以降の描画はCSSピクセル基準
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = cssW; H = cssH;
}

/* ===== ブロック生成 ===== */
function buildBricks(){
  bricks = [];
  const {cols,rows,gap,wall} = CFG;
  const gridW = (W - wall*2);
  const gridH = (H - CFG.marginTop - CFG.marginBottom);
  const bw = Math.floor((gridW - gap*(cols-1)) / cols);
  const bh = Math.floor((gridH - gap*(rows-1)) / rows);

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x = wall + c*(bw+gap);
      const y = CFG.marginTop + r*(bh+gap);
      bricks.push({x,y,w:bw,h:bh,hp:1});
    }
  }
}

/* ===== 初期化 ===== */
async function reset(all=false){
  if(all){ score=0; lives=3; }
  paused=false; gameOver=false; cleared=false; hideOverlay();

  if(!photoReady){ photoImg = await loadPhoto(PHOTO_FILE); photoReady = true; }
  fitCanvas(); buildBricks();

  // パドル／ボール初期位置
  paddle.w = Math.min(CFG.paddleW, W*0.20);
  paddle.h = CFG.paddleH;
  paddle.x = (W - paddle.w)/2;
  paddle.y = H - CFG.paddleBottom;

  ball.r = CFG.ballRadius;
  ball.x = paddle.x + paddle.w/2;
  ball.y = paddle.y - 14;
  ball.vx = 0; ball.vy = 0; ball.stuck = true;

  scEl.textContent = score; lvEl.textContent = lives;
}

/* ===== 入力（PC:移動だけで追従／クリックで発射） ===== */
function toCanvasX(clientX){
  const rect = canvas.getBoundingClientRect();
  const ratio = canvas.width / rect.width;
  return (clientX - rect.left) * ratio / DPR;
}
canvas.addEventListener("pointermove",(e)=>{
  // マウス移動だけで追従（スマホでもOK）
  paddle.x = Math.min(Math.max(toCanvasX(e.clientX) - paddle.w/2, 0), W - paddle.w);
});
canvas.addEventListener("pointerdown",()=>{
  if(ball.stuck) launchBall();
});
// 2本指で一時停止
canvas.addEventListener("touchstart",(e)=>{ if(e.touches?.length>=2) paused=!paused; },{passive:true});

window.addEventListener("resize", ()=>{
  const px = (paddle.x || 0) / (W || 1);
  const bx = (ball.x || 0) / (W || 1), by = (ball.y || 0) / (H || 1);
  fitCanvas(); buildBricks();
  paddle.x = (W - paddle.w)*px;
  ball.x = W*bx; ball.y = H*by;
});

/* ===== ボタン ===== */
pauseBtn.addEventListener("click", ()=> paused = !paused);
resetBtn.addEventListener("click", ()=> reset(true));
againBtn.addEventListener("click", ()=> reset(true));

/* ===== 発射 ===== */
function effectiveBallSpeed(){ return CFG.ballSpeed; }
function launchBall(){
  const base = (Math.random()<0.5? -1:1) * 0.38;  // 左右ランダム
  const angle = (-Math.PI/2) + base;
  const speed = effectiveBallSpeed();
  ball.vx = speed*Math.cos(angle);
  ball.vy = speed*Math.sin(angle);
  ball.stuck = false;
}

/* ===== 衝突ユーティリティ ===== */
function rectHitCircle(rx,ry,rw,rh,cx,cy,cr){
  const nx = Math.max(rx, Math.min(cx, rx+rw));
  const ny = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - nx, dy = cy - ny;
  return (dx*dx + dy*dy) <= cr*cr;
}

/* ===== 更新 ===== */
function update(){
  if(paused || gameOver || cleared) return;

  // パドル追従中
  if(ball.stuck){
    ball.x = Math.max(ball.r, Math.min(W - ball.r, paddle.x + paddle.w/2));
    ball.y = paddle.y - 14;
  }else{
    // ボール移動
    ball.x += ball.vx; ball.y += ball.vy;

    // 壁
    if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
    if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; }
    if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }
// 反射後に追加
const minVy = 2.5; // 下方向の最小スピード
if (Math.abs(ball.vy) < minVy) {
  ball.vy = (ball.vy < 0 ? -1 : 1) * minVy;
}

    // パドル
    if(rectHitCircle(paddle.x,paddle.y,paddle.w,paddle.h, ball.x,ball.y,ball.r)){
      // 反射角：ヒット位置依存
      const hitPos = (ball.x - paddle.x) / paddle.w; // 0..1
      const angle = (Math.PI * (0.9 * (hitPos - 0.5))) - Math.PI/2;
      const speed = Math.min(CFG.ballMax, Math.max(effectiveBallSpeed(), Math.hypot(ball.vx,ball.vy)));
      ball.x = Math.max(ball.r, Math.min(W-ball.r, ball.x));
      ball.y = paddle.y - ball.r;      // めり込み防止
      ball.vx = speed*Math.cos(angle);
      ball.vy = -Math.abs(speed*Math.sin(angle));
    }

    // 落下ミス
    if(ball.y - ball.r > H){
      lives--; lvEl.textContent = lives;
      if(lives<=0){ gameOver = true; showOverlay("ゲームオーバー","また挑戦してね！"); return; }
      // パドル上に復帰
      ball.stuck = true; ball.vx = 0; ball.vy = 0;
    }
  }

  // ブロック衝突
  let breakables = 0;
  for(const b of bricks){
    if(b.hp>0) breakables++;
    if(b.hp<=0) continue;

    if(rectHitCircle(b.x,b.y,b.w,b.h, ball.x,ball.y,ball.r)){
      // どの面に当たったか（＋押し出しでハマり防止）
      const dx = (ball.x - (b.x + b.w/2)) / (b.w/2);
      const dy = (ball.y - (b.y + b.h/2)) / (b.h/2);
      if(Math.abs(dx)*1.1 > Math.abs(dy)){
        // 横側
        if(dx > 0) ball.x = b.x + b.w + ball.r;
        else       ball.x = b.x - ball.r;
        ball.vx *= -1;
      }else{
        // 上下側
        if(dy > 0) ball.y = b.y + b.h + ball.r;
        else       ball.y = b.y - ball.r;
        ball.vy *= -1;
      }

      // 壊す
      b.hp = 0;
      score += 100; scEl.textContent = score;
    }
  }

  if(breakables === 0){
    cleared = true;
    showOverlay("松村です！","クリアおめでとうございます！");
  }
}

/* ===== 描画 ===== */
function render(){
  // 背景に写真（cover）
  if(photoReady){
    const cw=W, ch=H, iw=photoImg.width, ih=photoImg.height;
    const cr=cw/ch, ir=iw/ih; let dw, dh, dx, dy;
    if(ir>cr){ const s=ch/ih; dw=iw*s; dh=ih*s; } else { const s=cw/iw; dw=iw*s; dh=ih*s; }
    dx=(cw-dw)/2; dy=(ch-dh)/2;
    ctx.drawImage(photoImg, dx, dy, dw, dh);
  }else{
    ctx.fillStyle="#0a0f14"; ctx.fillRect(0,0,W,H);
  }

  // 壊れていないブロックだけ描画（覆い）
  for(const b of bricks){
    if(b.hp<=0) continue;
    ctx.fillStyle= getComputedStyle(document.documentElement).getPropertyValue('--brick') || "#122032";
    ctx.fillRect(b.x,b.y,b.w,b.h);
    ctx.strokeStyle= getComputedStyle(document.documentElement).getPropertyValue('--brickLine') || "rgba(255,255,255,.06)";
    ctx.strokeRect(b.x+.5,b.y+.5,b.w-1,b.h-1);
  }

  // パドル
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--paddle')||"#eab308";
  ctx.fillRect(paddle.x,paddle.y,paddle.w,paddle.h);
  // ボール
  ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--ball')||"#e5e7eb"; ctx.fill();
}

/* ===== ループ ===== */
function loop(){ update(); render(); requestAnimationFrame(loop); }

/* ===== オーバーレイ ===== */
function showOverlay(t,m){ ovlTitle.textContent=t; ovlMsg.textContent=m; ovl.classList.add("show"); }
function hideOverlay(){ ovl.classList.remove("show"); }

/* ===== 起動 ===== */
await reset(true);
requestAnimationFrame(loop);
</script>
</body>
</html>
