<!doctype html>
<html lang="ja">
<head>
  <!-- OGP AUTO-GENERATED START (do not edit by hand) -->
  <meta property="og:title" content="æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ»ãƒãƒ©ãƒ³ã‚¹ãƒ„ãƒªãƒ¼ - 12/7 ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ„ãƒªãƒ¼ã®æ—¥">
  <meta name="twitter:title" content="æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ»ãƒãƒ©ãƒ³ã‚¹ãƒ„ãƒªãƒ¼ - 12/7 ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ„ãƒªãƒ¼ã®æ—¥">
  <meta property="og:description" content="ğŸ„ æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ»ãƒãƒ©ãƒ³ã‚¹ãƒ„ãƒªãƒ¼ 12/7 ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ„ãƒªãƒ¼ã®æ—¥ - å€’ã•ãšã«ä½•äººã¶ã‚‰ä¸‹ã’ã‚‰ã‚Œã‚‹ï¼Ÿ ãƒ„ãƒªãƒ¼ã«æ¾æ‘ã‚’é£¾ã‚ã† æ­´ä»£æ¾æ‘ã‚ªãƒ¼ãƒ«ã‚¹ã‚¿ãƒ¼ãŒã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆã«ãªã£ã¦ç™»å ´ï¼ å·¦å³ã«å‹•ã‹ã—ã¦ã€å€’ã‚Œãªã„ã‚ˆã†ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãã¶ã‚‰ä¸‹ã’ã‚ˆã†ã€‚ â–¶ ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ åŠã‚‹ã—ãŸæ¾æ‘ 0äºº ãƒ™ã‚¹">
  <meta name="twitter:description" content="ğŸ„ æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ»ãƒãƒ©ãƒ³ã‚¹ãƒ„ãƒªãƒ¼ 12/7 ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ„ãƒªãƒ¼ã®æ—¥ - å€’ã•ãšã«ä½•äººã¶ã‚‰ä¸‹ã’ã‚‰ã‚Œã‚‹ï¼Ÿ ãƒ„ãƒªãƒ¼ã«æ¾æ‘ã‚’é£¾ã‚ã† æ­´ä»£æ¾æ‘ã‚ªãƒ¼ãƒ«ã‚¹ã‚¿ãƒ¼ãŒã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆã«ãªã£ã¦ç™»å ´ï¼ å·¦å³ã«å‹•ã‹ã—ã¦ã€å€’ã‚Œãªã„ã‚ˆã†ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãã¶ã‚‰ä¸‹ã’ã‚ˆã†ã€‚ â–¶ ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ åŠã‚‹ã—ãŸæ¾æ‘ 0äºº ãƒ™ã‚¹">
  <meta property="og:image" content="/apps/2025-12-07/assets/bike.png">
  <meta name="twitter:image" content="/apps/2025-12-07/assets/bike.png">
  <meta property="og:url" content="/apps/2025-12-07/index.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <!-- OGP AUTO-GENERATED END -->

<meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1.0,minimum-scale=1.0,viewport-fit=cover,user-scalable=no"
  />
  <title>æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ»ãƒãƒ©ãƒ³ã‚¹ãƒ„ãƒªãƒ¼ - 12/7 ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ„ãƒªãƒ¼ã®æ—¥</title>
  <style>
    :root {
      --bg: #020617;
      --bg-soft: #02081a;
      --accent: #f97316;
      --accent-soft: rgba(248, 171, 70, 0.18);
      --danger: #fb7185;
      --ink: #f9fafb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      touch-action: manipulation;
    }

    html, body {
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      min-height: 100vh;
      background:
        radial-gradient(circle at top, #0b1120 0, #020617 55%);
      color: var(--ink);
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: env(safe-area-inset-top, 16px)
        env(safe-area-inset-right, 16px)
        env(safe-area-inset-bottom, 16px)
        env(safe-area-inset-left, 16px);
    }

    .shell {
      margin: auto;
      width: 100%;
      max-width: 480px;
      background: linear-gradient(
        145deg,
        rgba(15, 23, 42, 0.96),
        rgba(15, 23, 42, 0.88)
      );
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow:
        0 24px 80px rgba(15, 23, 42, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      padding: 16px 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    header h1 span.emoji {
      font-size: 1.3rem;
    }

    header .sub {
      font-size: 0.7rem;
      color: var(--muted);
    }

    #game-wrap {
      background: radial-gradient(circle at top, #0f172a 0, #020617 70%);
      border-radius: 20px;
      padding: 12px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #game-canvas {
      width: 100%;
      max-width: 100%;
      border-radius: 16px;
      background: linear-gradient(
        180deg,
        #020617 0,
        #020617 55%,
        #052e16 56%,
        #166534 100%
      );
      touch-action: none;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
    }

    .hud-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .label {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .value {
      font-weight: 600;
    }

    .status-pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 0.7rem;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .status-pill.safe {
      border-color: rgba(52, 211, 153, 0.8);
      color: #6ee7b7;
    }

    .status-pill.danger {
      border-color: rgba(248, 113, 113, 0.9);
      color: #fecaca;
    }

    .controls {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }

    .controls button {
      flex: 1;
      border-radius: 999px;
      border: none;
      padding: 8px 10px;
      font-size: 0.8rem;
      font-weight: 600;
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.12s ease,
        background 0.12s ease;
    }

    .controls button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.9),
        0 6px 18px rgba(15, 23, 42, 0.9);
      background: rgba(30, 64, 175, 0.8);
    }

    .controls button.main {
      background: radial-gradient(
        circle at top left,
        #f97316,
        #ea580c 45%,
        #9a3412 100%
      );
      box-shadow:
        0 0 0 1px rgba(251, 146, 60, 0.9),
        0 10px 28px rgba(248, 171, 70, 0.8);
    }

    .controls button.main:active {
      background: radial-gradient(
        circle at top left,
        #fb923c,
        #ea580c 45%,
        #7c2d12 100%
      );
    }

    .footer-text {
      font-size: 0.7rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .footer-text strong {
      color: #facc15;
      font-weight: 600;
    }

    .overlay {
      position: absolute;
      inset: 8px;
      border-radius: 16px;
      background: radial-gradient(
        circle at top,
        rgba(15, 23, 42, 0.95),
        rgba(15, 23, 42, 0.98)
      );
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      gap: 10px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay h2 {
      font-size: 1rem;
      margin-bottom: 2px;
    }

    .overlay p {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .overlay button {
      margin-top: 4px;
      border-radius: 999px;
      border: none;
      padding: 8px 18px;
      font-size: 0.85rem;
      font-weight: 600;
      background: radial-gradient(
        circle at top left,
        #22c55e,
        #16a34a 50%,
        #166534 100%
      );
      color: #f9fafb;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(34, 197, 94, 0.9),
        0 10px 30px rgba(22, 163, 74, 0.8);
      transition: transform 0.08s ease, box-shadow 0.12s ease;
    }

    .overlay button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow:
        0 0 0 1px rgba(34, 197, 94, 1),
        0 6px 20px rgba(21, 128, 61, 0.9);
    }

    @media (min-width: 540px) {
      .shell {
        padding: 18px 18px 22px;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <header>
      <div>
        <h1>
          <span class="emoji">ğŸ„</span>
          æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ»ãƒãƒ©ãƒ³ã‚¹ãƒ„ãƒªãƒ¼
        </h1>
        <div class="sub">12/7 ã‚¯ãƒªã‚¹ãƒã‚¹ãƒ„ãƒªãƒ¼ã®æ—¥ - å€’ã•ãšã«ä½•äººã¶ã‚‰ä¸‹ã’ã‚‰ã‚Œã‚‹ï¼Ÿ</div>
      </div>
    </header>

    <section id="game-wrap">
      <canvas id="game-canvas" width="360" height="520"></canvas>

      <div class="overlay visible" id="overlay">
        <h2 id="overlay-title">ãƒ„ãƒªãƒ¼ã«æ¾æ‘ã‚’é£¾ã‚ã†</h2>
        <p id="overlay-text">
          æ­´ä»£æ¾æ‘ã‚ªãƒ¼ãƒ«ã‚¹ã‚¿ãƒ¼ãŒã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆã«ãªã£ã¦ç™»å ´ï¼<br />
          å·¦å³ã«å‹•ã‹ã—ã¦ã€å€’ã‚Œãªã„ã‚ˆã†ã«ãƒãƒ©ãƒ³ã‚¹ã‚ˆãã¶ã‚‰ä¸‹ã’ã‚ˆã†ã€‚
        </p>
        <button id="btn-start">â–¶ ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      </div>

      <div class="hud">
        <div class="hud-left">
          <div>
            <span class="label">åŠã‚‹ã—ãŸæ¾æ‘</span>
            <span class="value" id="score">0äºº</span>
          </div>
          <div>
            <span class="label">ãƒ™ã‚¹ãƒˆ</span>
            <span class="value" id="best">0äºº</span>
          </div>
        </div>
        <div>
          <span class="status-pill safe" id="status-pill">
            <span>ğŸŸ¢</span><span id="status-text">å®‰å®šã—ã¦ã„ã¾ã™</span>
          </span>
        </div>
      </div>

      <div class="controls">
        <button id="btn-left" aria-label="å·¦ã¸">
          â† å·¦
        </button>
        <button id="btn-hang" class="main">
          åŠã‚‹ã™ï¼
        </button>
        <button id="btn-right" aria-label="å³ã¸">
          å³ â†’
        </button>
      </div>
    </section>

    <p class="footer-text">
      ç”»é¢ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚‚æ¾æ‘ã®ä½ç½®ã‚’å‹•ã‹ã›ã¾ã™ã€‚<br />
      PCã®æ–¹ã¯ <strong>â† â†’ ã‚­ãƒ¼</strong> ã§ç§»å‹•ã€
      <strong>ã‚¹ãƒšãƒ¼ã‚¹ / Enter</strong> ã§åŠã‚‹ã›ã¾ã™ã€‚
    </p>
  </main>

  <script type="module">
    // Vercelç”¨ã®ãƒ‘ã‚¹è§£æ±ºãƒ˜ãƒ«ãƒ‘ãƒ¼
    const DATE_SEGMENT = (location.pathname.match(/\d{4}-\d{2}-\d{2}/) || [""])[0];
    const DATE_BASE = DATE_SEGMENT ? `/${DATE_SEGMENT}/` : "/";
    const asset = (p) => {
      const clean = String(p || "").replace(/^\.?\//, "");
      return `${DATE_BASE}${clean}`;
    };

    // æ­´ä»£æ¾æ‘ãŸã¡ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
    const ORNAMENT_SPRITES = [
      asset("./assets/shiki.png"),   // æŒ‡æ®è€…æ¾æ‘
      asset("./assets/bushi.png"),   // æ­¦å£«æ¾æ‘
      asset("./assets/zombie.png"),  // ã‚¾ãƒ³ãƒ“æ¾æ‘
      asset("./assets/jiyu.png"),    // è‡ªç”±ã®æ¾æ‘
      asset("./assets/yokai.png"),   // å¦–æ€ªæ¾æ‘
      asset("./assets/kimono.png"),  // ç€ç‰©æ¾æ‘
      asset("./assets/bike.png"),    // ãƒãƒ£ãƒªæ¾æ‘
      asset("./assets/space.png"),   // å®‡å®™æ¾æ‘
    ];
// BGM èª­ã¿è¾¼ã¿ï¼ˆ1æ—¥1ã‚¢ãƒ—ãƒªç”¨ã® asset() ã‚’ä½¿ç”¨ï¼‰
const bgm = new Audio(asset("./assets/bgm.mp3"));
bgm.loop = true;
bgm.volume = 0.8; // éŸ³é‡ã¯å¥½ã¿ã§èª¿æ•´ï¼ˆ0.0ã€œ1.0ï¼‰

    // ãƒ„ãƒªãƒ¼ç”»åƒï¼ˆè‡ªä½œã®æœ¨ã®ç”»åƒï¼‰ ./assets/tree.png ã‚’æƒ³å®š
    const TREE_IMG_SRC = asset("./assets/tree.png");
    const treeImg = new Image();
    let treeImgLoaded = false;
    treeImg.onload = () => {
      treeImgLoaded = true;
    };
    treeImg.src = TREE_IMG_SRC;

    // ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆç”»åƒãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
    const ornamentImages = [];
    let imagesLoaded = 0;
    let imagesReady = false;

    ORNAMENT_SPRITES.forEach((src) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        imagesLoaded++;
        if (imagesLoaded >= ORNAMENT_SPRITES.length) {
          imagesReady = true;
        }
      };
      ornamentImages.push(img);
    });

    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");

    // DPRå¯¾å¿œ
    const dpr = window.devicePixelRatio || 1;
    const baseWidth = canvas.width;
    const baseHeight = canvas.height;
    canvas.width = baseWidth * dpr;
    canvas.height = baseHeight * dpr;
    ctx.scale(dpr, dpr);

    // UIè¦ç´ 
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlay-title");
    const overlayText = document.getElementById("overlay-text");
    const btnStart = document.getElementById("btn-start");
    const btnLeft = document.getElementById("btn-left");
    const btnRight = document.getElementById("btn-right");
    const btnHang = document.getElementById("btn-hang");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const statusPill = document.getElementById("status-pill");
    const statusText = document.getElementById("status-text");

    // ã‚²ãƒ¼ãƒ å®šæ•°
    const PIVOT_X = baseWidth / 2;
    const PIVOT_Y = baseHeight * 0.78;
    const TREE_HEIGHT = 260;
    const TREE_WIDTH = 220;

    // ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆã®åŸºæœ¬ã‚µã‚¤ã‚º
    const BASE_ORNAMENT_SIZE = 60;
    const MOVE_STEP = 22;

    // ãƒ„ãƒªãƒ¼ã®å·¦å³ã€å¯å‹•ç¯„å›²
    const LEFT_LIMIT = PIVOT_X - TREE_WIDTH * 0.5;
    const RIGHT_LIMIT = PIVOT_X + TREE_WIDTH * 0.5;

    // æãƒ•ãƒƒã‚¯ï¼ˆçœŸã‚“ä¸­ãªã—ï¼‰
    const HOOK_COLUMNS = [-0.9, -0.55, -0.25, 0.25, 0.55, 0.9];
    const HOOK_POSITIONS = HOOK_COLUMNS.map(
      (c) => PIVOT_X + c * (TREE_WIDTH / 2)
    );

    const BASE_MASS = 8;
    const MAX_TILT_RAD = 0.65;
    // å®ŸåŠ¹é‡å¿ƒã‚ºãƒ¬ãŒã“ã‚Œã‚’è¶…ãˆãŸã‚‰å€’ã‚Œã‚‹ï¼ˆã¡ã‚‡ã£ã¨å³ã—ã‚ï¼‰
    const FAIL_OFFSET_X = 30;
    // ã‚ºãƒ¬ â†’ è§’åº¦å¤‰æ›ï¼ˆå°ã•ã„ã»ã©ã‚ˆãæºã‚Œã‚‹ï¼‰
    const BALANCE_SCALE = 100;

    // çŠ¶æ…‹
    let gameState = "ready";
    let score = 0;
    let best = Number(localStorage.getItem("matsuTreeBest") || "0");
    bestEl.textContent = `${best}äºº`;

    let placedOrnaments = [];
    let activeOrnament = null;

    let currentAngle = 0;
    let targetAngle = 0;

    let isPointerDown = false;

    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    function snapToHook(x) {
      let best = HOOK_POSITIONS[0];
      let bestDist = Math.abs(x - best);
      for (let i = 1; i < HOOK_POSITIONS.length; i++) {
        const fx = HOOK_POSITIONS[i];
        const d = Math.abs(x - fx);
        if (d < bestDist) {
          best = fx;
          bestDist = d;
        }
      }
      return best;
    }

    function randomOrnamentImage() {
      if (!imagesReady) {
        return ornamentImages[0] || null;
      }
      const idx = Math.floor(Math.random() * ornamentImages.length);
      return ornamentImages[idx];
    }

    function createNewActiveOrnament() {
      const img = randomOrnamentImage();
      const size = BASE_ORNAMENT_SIZE * (0.85 + Math.random() * 0.4);
      const weight = 1 * (size / BASE_ORNAMENT_SIZE);

      activeOrnament = {
        img,
        x: PIVOT_X,
        y: baseHeight * 0.18,
        size,
        weight,
        wobblePhase: Math.random() * Math.PI * 2,
      };
    }

    function resetGame() {
      score = 0;
      placedOrnaments = [];
      scoreEl.textContent = "0äºº";
      currentAngle = 0;
      targetAngle = 0;
      updateStatus("safe");
      createNewActiveOrnament();
    }

    function updateStatus(mode) {
      if (mode === "danger") {
        statusPill.classList.remove("safe");
        statusPill.classList.add("danger");
        statusText.textContent = "ã‹ãªã‚Šå‚¾ã„ã¦ã„ã¾ã™â€¦ï¼";
      } else {
        statusPill.classList.remove("danger");
        statusPill.classList.add("safe");
        statusText.textContent = "å®‰å®šã—ã¦ã„ã¾ã™";
      }
    }

    function startGame() {
  if (gameState === "playing") return;

  gameState = "playing";
  overlay.classList.remove("visible");
  resetGame();

  // â–¶ BGM å†ç”Ÿï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œãªã®ã§è‡ªå‹•å†ç”ŸOKï¼‰
  bgm.currentTime = 0;
  bgm.play().catch(()=>{});
}


function endGame() {
  if (gameState !== "playing") return;
  gameState = "gameover";

  // â—€ BGM åœæ­¢
  bgm.pause();

  if (score > best) {
    best = score;
    localStorage.setItem("matsuTreeBest", String(best));
    bestEl.textContent = `${best}äºº`;
  }

  overlayTitle.textContent = "ãƒ„ãƒªãƒ¼ãŒå€’ã‚Œã¦ã—ã¾ã£ãŸï¼";
  overlayText.innerHTML = `ä»Šå›ã¯ <strong>${score}äºº</strong> ã®æ¾æ‘ã‚’é£¾ã‚Šã¾ã—ãŸã€‚<br/>ã‚‚ã†ä¸€åº¦ãƒãƒ©ãƒ³ã‚¹ã«æŒ‘æˆ¦ã—ã‚ˆã†ã€‚`;
  btnStart.textContent = "âŸ³ ã‚‚ã†ä¸€åº¦éŠã¶";
  overlay.classList.add("visible");
}

    function moveActive(dx) {
      if (gameState !== "playing" || !activeOrnament) return;
      activeOrnament.x = clamp(
        activeOrnament.x + dx,
        LEFT_LIMIT,
        RIGHT_LIMIT
      );
    }

    function handlePointerMove(evt) {
      if (!isPointerDown || gameState !== "playing" || !activeOrnament) return;
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      activeOrnament.x = clamp(x, LEFT_LIMIT, RIGHT_LIMIT);
    }

    function placeOrnament() {
      if (gameState !== "playing" || !activeOrnament) return;

      // ãƒ„ãƒªãƒ¼ã®ä¸­è…¹ã€œä¸Šéƒ¨ãã‚‰ã„ã®ãƒ©ãƒ³ãƒ€ãƒ ä½ç½®ã«ã¶ã‚‰ä¸‹ã’ã‚‹
      const minOffset = TREE_HEIGHT * 0.25;
      const maxOffset = TREE_HEIGHT * 0.9;
      const offset = minOffset + Math.random() * (maxOffset - minOffset);
      const dropY = PIVOT_Y - offset;

      // ã„ã¡ã°ã‚“è¿‘ã„æãƒ•ãƒƒã‚¯ã«ã‚¹ãƒŠãƒƒãƒ—
      const snappedX = snapToHook(activeOrnament.x);
      activeOrnament.x = snappedX;

      const localX = snappedX - PIVOT_X;
      const localY = dropY - PIVOT_Y;

      placedOrnaments.push({
        img: activeOrnament.img,
        localX,
        localY,
        size: activeOrnament.size,
        weight: activeOrnament.weight,
      });

      score += 1;
      scoreEl.textContent = `${score}äºº`;

      // é‡å¿ƒè¨ˆç®—
      let totalWeight = BASE_MASS;
      let sumX = 0;

      placedOrnaments.forEach((o) => {
        totalWeight += o.weight;
        sumX += o.weight * o.localX;
      });

      const offsetX = sumX / totalWeight;

      // ã€Œã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãŒå¢—ãˆã‚‹ã»ã©å€’ã‚Œã‚„ã™ããªã‚‹ã€ä¿‚æ•°ï¼ˆã¡ã‚‡ã„å¼·ã‚ï¼‰
      const tiltFactor = 1 + placedOrnaments.length * 0.3;
      const effectiveOffsetX = offsetX * tiltFactor;

      let angle = effectiveOffsetX / BALANCE_SCALE;
      angle = clamp(angle, -MAX_TILT_RAD, MAX_TILT_RAD);
      targetAngle = angle;

      if (Math.abs(effectiveOffsetX) > FAIL_OFFSET_X) {
        updateStatus("danger");
        targetAngle =
          effectiveOffsetX > 0
            ? MAX_TILT_RAD * 1.1
            : -MAX_TILT_RAD * 1.1;
        setTimeout(() => endGame(), 380);
      } else {
        if (Math.abs(effectiveOffsetX) > FAIL_OFFSET_X * 0.7) {
          updateStatus("danger");
        } else {
          updateStatus("safe");
        }
        createNewActiveOrnament();
      }
    }

    // èƒŒæ™¯
    function drawBackground() {
      const g = ctx.createLinearGradient(0, 0, 0, baseHeight);
      g.addColorStop(0, "#020617");
      g.addColorStop(0.55, "#020617");
      g.addColorStop(0.56, "#052e16");
      g.addColorStop(1, "#166534");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, baseWidth, baseHeight);

      ctx.fillStyle = "rgba(248, 250, 252, 0.9)";
      for (let i = 0; i < 30; i++) {
        const x = (i * 79) % baseWidth;
        const y = 20 + ((i * 53) % (baseHeight * 0.4));
        const r = (i % 3) === 0 ? 1.2 : 0.7;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = "rgba(226, 232, 240, 0.45)";
      for (let i = 0; i < 26; i++) {
        const x = (i * 41 + 23) % baseWidth;
        const y = baseHeight * 0.45 + ((i * 67) % (baseHeight * 0.25));
        ctx.beginPath();
        ctx.arc(x, y, 0.8, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = "#052e16";
      ctx.fillRect(0, PIVOT_Y + 8, baseWidth, baseHeight - PIVOT_Y - 8);
      ctx.fillStyle = "#022c22";
      ctx.beginPath();
      ctx.arc(
        baseWidth / 2,
        PIVOT_Y + 18,
        baseWidth * 0.6,
        Math.PI,
        0
      );
      ctx.fill();
    }

    // ãƒ„ãƒªãƒ¼ & åŠã‚‹ã•ã‚ŒãŸæ¾æ‘
    function drawTreeAndOrnaments() {
      ctx.save();
      ctx.translate(PIVOT_X, PIVOT_Y);
      ctx.rotate(currentAngle);

      if (treeImgLoaded) {
        const imgW = TREE_WIDTH;
        const imgH = TREE_HEIGHT + 60;
        ctx.drawImage(
          treeImg,
          -imgW / 2,
          -imgH,
          imgW,
          imgH
        );
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        ctx.fillStyle = "#14532d";
        ctx.beginPath();
        ctx.moveTo(0, -TREE_HEIGHT);
        ctx.lineTo(-TREE_WIDTH / 2, 0);
        ctx.lineTo(TREE_WIDTH / 2, 0);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#16a34a";
        const tiers = 3;
        for (let i = 0; i < tiers; i++) {
          const t = i / tiers;
          const w = TREE_WIDTH * (0.7 - t * 0.25);
          const y = -TREE_HEIGHT * (0.7 - t * 0.25);
          ctx.beginPath();
          ctx.moveTo(0, y - 18);
          ctx.lineTo(-w / 2, y + 12);
          ctx.lineTo(w / 2, y + 12);
          ctx.closePath();
          ctx.fill();
        }

        ctx.fillStyle = "#78350f";
        ctx.fillRect(-12, 0, 24, 40);
      }

      // â˜… ä¸Šã®æ˜Ÿã¯ãªã— â˜…

      placedOrnaments.forEach((o) => {
        if (!o.img) return;
        const size = o.size;
        const x = o.localX;
        const y = o.localY;
        ctx.save();
        ctx.translate(x, y);
        ctx.shadowColor = "rgba(15,23,42,0.9)";
        ctx.shadowBlur = 6;
        ctx.drawImage(
          o.img,
          -size / 2,
          -size / 2,
          size,
          size
        );
        ctx.restore();
      });

      ctx.restore();
    }

    // è½ä¸‹ä¸­ã®æ¾æ‘
    function drawActiveOrnament(time) {
      if (!activeOrnament || !activeOrnament.img) return;
      const { x, y, size } = activeOrnament;

      const t = time * 0.004 + activeOrnament.wobblePhase;
      const bob = Math.sin(t) * 6;

      ctx.save();
      ctx.translate(x, y + bob);
      ctx.shadowColor = "rgba(15,23,42,0.9)";
      ctx.shadowBlur = 8;
      ctx.drawImage(
        activeOrnament.img,
        -size / 2,
        -size / 2,
        size,
        size
      );
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(148, 163, 184, 0.5)";
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y + size / 2);
      ctx.lineTo(
        x,
        PIVOT_Y - TREE_HEIGHT * 0.1
      );
      ctx.stroke();
      ctx.restore();
    }

    function loop(timestamp) {
      requestAnimationFrame(loop);

      currentAngle += (targetAngle - currentAngle) * 0.08;

      // è¦‹ãŸç›®ç”¨ã®å°ã•ãªæºã‚Œï¼ˆã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆå¢—ãˆã‚‹ã»ã©ã‚°ãƒ©ã‚°ãƒ©ï¼‰
      const t = timestamp * 0.001;
      const wobbleBase = gameState === "playing" ? 0.07 : 0.035;
      const wobbleScale = 1 + placedOrnaments.length * 0.04;
      const wobble = Math.sin(t * 1.9) * wobbleBase * wobbleScale;

      const savedAngle = currentAngle;
      currentAngle = currentAngle + wobble;

      drawBackground();
      drawTreeAndOrnaments();
      if (gameState !== "ready") {
        drawActiveOrnament(timestamp);
      }

      currentAngle = savedAngle;

      ctx.save();
      ctx.fillStyle = "rgba(15,23,42,0.45)";
      ctx.font = "700 11px system-ui, -apple-system, BlinkMacSystemFont";
      ctx.textAlign = "center";
      ctx.fillText("MATSUMURA TREE", baseWidth / 2, PIVOT_Y + 52);
      ctx.restore();
    }

    requestAnimationFrame(loop);

    // ã‚¤ãƒ™ãƒ³ãƒˆ
    btnStart.addEventListener("click", () => {
      startGame();
    });

    btnLeft.addEventListener("click", () => moveActive(-MOVE_STEP));
    btnRight.addEventListener("click", () => moveActive(MOVE_STEP));
    btnHang.addEventListener("click", () => placeOrnament());

    canvas.addEventListener("pointerdown", (evt) => {
      isPointerDown = true;
      handlePointerMove(evt);
    });

    canvas.addEventListener("pointermove", handlePointerMove);

    window.addEventListener("pointerup", () => {
      isPointerDown = false;
    });

    window.addEventListener("keydown", (evt) => {
      if (evt.key === "ArrowLeft") {
        evt.preventDefault();
        moveActive(-MOVE_STEP);
      } else if (evt.key === "ArrowRight") {
        evt.preventDefault();
        moveActive(MOVE_STEP);
      } else if (evt.key === " " || evt.key === "Enter") {
        evt.preventDefault();
        placeOrnament();
      }
    });

    overlayTitle.textContent = "æ¾æ‘ã‚ªãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆãƒ„ãƒªãƒ¼ã¸ã‚ˆã†ã“ã";
    overlayText.innerHTML =
      "æŒ‡æ®è€…æ¾æ‘ã€æ­¦å£«æ¾æ‘ã€ã‚¾ãƒ³ãƒ“æ¾æ‘â€¦<br/>æ­´ä»£æ¾æ‘ãŸã¡ã‚’ãƒ„ãƒªãƒ¼ã«ã¶ã‚‰ä¸‹ã’ã‚ˆã†ã€‚<br/>ãŸã ã—ã€å€’ã‚ŒãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼";

    // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§æ‹¡å¤§ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (evt) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        evt.preventDefault();
      }
      lastTouchEnd = now;
    }, false);
  </script>
</body>
</html>
