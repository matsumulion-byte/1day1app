<!doctype html>
<html lang="ja">
<head>
  <!-- OGP AUTO-GENERATED START (do not edit by hand) -->
  <meta property="og:title" content="CIRCUS｜松村">
  <meta name="twitter:title" content="CIRCUS｜松村">
  <meta property="og:description" content="CIRCUS｜松村 左右でシーソー移動 → 空中の松村を端で受けると、反対側の松村が飛ぶ SCORE 0 LIFE 3 BALLOON 0 SOUND: ON START 常に「空中の松村」と「シーソー端で待つ松村」がいます。 空中の松村が端に着地すると、反対側の松村が発射され、">
  <meta name="twitter:description" content="CIRCUS｜松村 左右でシーソー移動 → 空中の松村を端で受けると、反対側の松村が飛ぶ SCORE 0 LIFE 3 BALLOON 0 SOUND: ON START 常に「空中の松村」と「シーソー端で待つ松村」がいます。 空中の松村が端に着地すると、反対側の松村が発射され、">
  <meta property="og:image" content="/2026-01-18/assets/matsumura.png">
  <meta name="twitter:image" content="/2026-01-18/assets/matsumura.png">
  <meta property="og:url" content="/2026-01-18/">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <!-- OGP AUTO-GENERATED END -->

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b1020" />
  <title>CIRCUS｜松村</title>
  <style>
    :root{
      --bg:#0b1020; --ink:#f3f6ff; --muted:rgba(243,246,255,.72);
      --line:rgba(255,255,255,.14); --panel:rgba(255,255,255,.08);
      --accent:#60a5fa; --good:#34d399; --bad:#fb7185; --r:18px;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%; background:var(--bg); color:var(--ink); overflow:hidden}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      touch-action: manipulation; -webkit-user-select:none; user-select:none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    *{touch-action: manipulation;}
    .wrap{height:100%; display:flex; flex-direction:column; padding:max(12px, env(safe-area-inset-top)) 12px max(12px, env(safe-area-inset-bottom)) 12px; gap:10px;}
    header{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .title{display:flex; flex-direction:column; gap:2px; min-width:0}
    .title b{font-size:14px; letter-spacing:.08em}
    .title span{font-size:12px; color:var(--muted)}
    .hud{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px; border:1px solid var(--line);
      background:rgba(255,255,255,.05); font-size:12px; color:var(--muted);
    }
    .pill b{color:var(--ink); font-weight:800}
    button{
      appearance:none; border:1px solid var(--line);
      background:rgba(255,255,255,.06); color:var(--ink);
      border-radius:12px; padding:10px 12px;
      font-weight:800; font-size:12px; letter-spacing:.02em;
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
    }
    button:active{transform: translateY(1px)}
    button.primary{border-color: rgba(96,165,250,.45); background: rgba(96,165,250,.14)}
    button.danger{border-color: rgba(251,113,133,.5); background: rgba(251,113,133,.12)}
    .stage{
      position:relative; flex:1; border-radius: var(--r); border:1px solid var(--line);
      background:
        radial-gradient(1200px 900px at 50% -20%, rgba(96,165,250,.16), transparent 55%),
        radial-gradient(900px 700px at 10% 120%, rgba(52,211,153,.10), transparent 55%),
        rgba(255,255,255,.03);
      box-shadow: var(--shadow); overflow:hidden;
    }
    canvas{width:100%; height:100%; display:block}
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      padding:18px; background: rgba(11,16,32,.62); backdrop-filter: blur(6px);
    }
    .card{
      width:min(560px, 100%); border:1px solid var(--line); border-radius: 22px;
      background: rgba(255,255,255,.08); box-shadow: var(--shadow);
      padding:16px; display:flex; flex-direction:column; gap:12px;
    }
    .card h1{font-size:16px; letter-spacing:.06em}
    .card p{font-size:12.5px; line-height:1.6; color:var(--muted)}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .row > *{flex:1}
    footer{display:flex; gap:10px}
    .half{
      flex:1; height:64px; border-radius: 16px; border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:center;
      font-weight:900; letter-spacing:.08em; position:relative; overflow:hidden;
    }
    .half span{font-size:13px; color:var(--muted)}
    .half b{position:absolute; inset:auto 12px 10px 12px; font-size:11px; color:rgba(243,246,255,.55); font-weight:700}
    .half:active{transform: translateY(1px)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <b>CIRCUS｜松村</b>
        <span>左右でシーソー移動 → 空中の松村を端で受けると、反対側の松村が飛ぶ</span>
      </div>
      <div class="hud">
        <div class="pill">SCORE <b id="score">0</b></div>
        <div class="pill">LIFE <b id="life">3</b></div>
        <div class="pill">BALLOON <b id="left">0</b></div>
        <button id="btnSound" class="primary" type="button">SOUND: ON</button>
      </div>
    </header>

    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div class="overlay" id="overlay">
        <div class="card">
          <h1>START</h1>
          <p>
            常に「空中の松村」と「シーソー端で待つ松村」がいます。<br/>
            空中の松村が端に着地すると、反対側の松村が発射され、風船を割ります。<br/>
            端で受けられないとLIFE減。
          </p>
          <div class="row">
            <button id="startOn" class="primary" type="button">SOUND ONで開始</button>
            <button id="startOff" type="button">SOUND OFFで開始</button>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div class="half" id="leftBtn"><span>LEFT</span><b>左押し</b></div>
      <div class="half" id="rightBtn"><span>RIGHT</span><b>右押し</b></div>
    </footer>
  </div>

  <script type="module">
    // Vercel用のパス解決ヘルパー
    const DATE_SEGMENT = (location.pathname.match(/\d{4}-\d{2}-\d{2}/) || [""])[0];
    const DATE_BASE = DATE_SEGMENT ? `/${DATE_SEGMENT}/` : "/";
    const asset = (p) => {
      const clean = String(p || "").replace(/^\.?\//, "");
      return `${DATE_BASE}${clean}`;
    };

    // ---------- SP判定 ----------
    const isSP = () => window.innerWidth < 768;

    // ---------- Canvas ----------
    const stage = document.getElementById('stage');
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    let W=0,H=0;
    function fit(){
      const r = stage.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      W=r.width; H=r.height;
    }
    new ResizeObserver(fit).observe(stage);

    // ---------- UI ----------
    const overlay = document.getElementById('overlay');
    const scoreEl = document.getElementById('score');
    const lifeEl  = document.getElementById('life');
    const leftEl  = document.getElementById('left');
    const btnSound = document.getElementById('btnSound');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const startOn = document.getElementById('startOn');
    const startOff = document.getElementById('startOff');

    // ---------- Sound ----------
    let audioCtx=null, soundOn=true;
    function ensureAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    function beep(freq=440, dur=0.05, type='square', gain=0.06){
      if (!soundOn) return;
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(audioCtx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.01);
    }
    function setSound(v){
      soundOn=v;
      btnSound.textContent = `SOUND: ${soundOn ? 'ON' : 'OFF'}`;
    }

    // ---------- Assets ----------
    const matsumuraImg = new Image();
    matsumuraImg.src = asset('./apps/2026-01-18/assets/matsumura.png'); // ここに置く

    // ---------- Helpers ----------
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    function roundRect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // ---------- Game model (Circus-ish, deterministic & sane) ----------
    // 重要: 「シーソーに乗ってる」状態を常に持つ
    // - waiting: シーソー端に“立っている松村”（発射される側）
    // - airborne: 空中の松村（落ちてきて着地する側）
    const G = {
      running:false, paused:false, gameOver:false,
      score:0, life:3,

      // seesaw
      cx:0, vx:0, y:0, len:0, moveSpeed:560, // SPでは調整される

      // actors
      waitingEnd: 'R', // 'L' or 'R' : どっち端で待ってるか
      airborne: null,   // {x,y,vx,vy}

      // balloons
      balloons: [],
      balloonLeft: 0,

      // difficulty
      gravity: 950,
      launchVyBase: -640,
      launchVyBonus: -320,
      missCooldown: 0,
    };

    function endX(which){
      const half = G.len/2;
      return which==='L' ? (G.cx-half) : (G.cx+half);
    }
    function otherEnd(which){ return which==='L' ? 'R' : 'L'; }

    function resetBalloons(){
      G.balloons.length=0;
      const cols=6, rows=3;
      const top=50;
      const hGap = clamp(W/7, 52, 86);
      const vGap = 44;
      const totalW = hGap*(cols-1);
      const startX = (W-totalW)/2;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          G.balloons.push({x:startX+c*hGap, y:top+r*vGap, r:15, alive:true});
        }
      }
      G.balloonLeft = G.balloons.length;
    }

    function resetActors(){
      // 空中の松村を「待ってる端の反対側の上」から落とす
      const dropFromEnd = otherEnd(G.waitingEnd);
      const x = endX(dropFromEnd);
      G.airborne = { x, y: 120, vx: 0, vy: 0 };
      // 少し上から開始（“落ちてくる”感）
      G.airborne.y = -30;
      G.airborne.vy = 60;
    }

    function resetGame(){
      G.running=false; G.paused=false; G.gameOver=false;
      G.score=0; G.life=3;
      
      // SP調整
      const sp = isSP();
      const scale = sp ? 0.75 : 1.0; // SPは75%スケール
      
      G.len = clamp(W * (sp ? 0.32 : 0.28), sp ? 140 : 120, sp ? 220 : 200);
      G.cx = W/2; G.vx=0;
      G.y = H - (sp ? 80 : 100);

      G.waitingEnd = 'R';
      resetBalloons();
      resetActors();

      // SPでは速度を調整（遅くする）
      G.gravity = sp ? 800 : 950;
      G.launchVyBase = sp ? -520 : -640;
      G.launchVyBonus = sp ? -260 : -320;
      G.moveSpeed = sp ? 420 : 560;
      G.missCooldown = 0;

      updateHud();
    }

    function updateHud(){
      scoreEl.textContent = String(G.score);
      lifeEl.textContent  = String(G.life);
      leftEl.textContent  = String(G.balloonLeft);
    }

    function startGame(){
      overlay.style.display='none';
      resetGame();
      G.running=true;
      lastT=performance.now();
      requestAnimationFrame(loop);
    }

    function loseLife(){
      if (G.missCooldown > 0) return;
      G.life -= 1;
      G.missCooldown = 0.5;
      updateHud();
      beep(140, 0.10, 'sawtooth', 0.07);
      if (G.life<=0){
        gameOver();
      } else {
        // 同じ状態で再開（待ち松村はそのまま、空中松村をリセット）
        resetActors();
      }
    }

    function gameOver(){
      G.gameOver=true; G.running=false;
      overlay.innerHTML = `
        <div class="card">
          <h1>GAME OVER</h1>
          <p>スコア：<b>${G.score}</b></p>
          <div class="row">
            <button id="retryBtn" class="primary" type="button">RETRY</button>
            <button id="soundToggleBtn" type="button">SOUND: ${soundOn ? 'ON' : 'OFF'}</button>
          </div>
        </div>
      `;
      overlay.style.display='flex';
      overlay.querySelector('#retryBtn').addEventListener('click', ()=>{
        overlay.style.display='none';
        resetGame();
        G.running=true;
        lastT=performance.now();
        requestAnimationFrame(loop);
      });
      overlay.querySelector('#soundToggleBtn').addEventListener('click', (e)=>{
        setSound(!soundOn);
        e.currentTarget.textContent = `SOUND: ${soundOn ? 'ON' : 'OFF'}`;
        beep(660, 0.04);
      });
    }

    function winAndRespawnBalloons(){
      beep(980, 0.06, 'square', 0.08);
      beep(1240, 0.06, 'triangle', 0.06);
      resetBalloons();
      // 少し難しくする（重力/発射強め）
      G.gravity += 60;
      G.launchVyBase -= 20;
      updateHud();
    }

    // landing -> launch
    function tryLanding(){
      const a = G.airborne;
      if (!a) return;

      const landY = G.y - 18; // シーソー板の高さ
      if (a.y < landY) return;

      // 落下してきた側（着地候補）は「待ってる側の反対」
      const landingEnd = otherEnd(G.waitingEnd);
      const ex = endX(landingEnd);
      const catchR = isSP() ? 52 : 46; // SPでは少し広めに

      const dx = a.x - ex;
      const adx = Math.abs(dx);

      if (adx <= catchR){
        // 着地成功：空中松村を「その端に乗せた」扱いにし、反対側を発射
        // パワー：端の中心に近いほど強い
        const power = 1 - clamp(adx / catchR, 0, 1);

        // 着地した松村が今度は待機役になる（landingEndで待つ）
        G.waitingEnd = landingEnd;

        // 発射されるのは反対側の松村（= previous waiting)
        const launchEnd = otherEnd(G.waitingEnd);
        const lx = endX(launchEnd);
        const ly = G.y - 40;

        // 発射直後の空中松村を生成（＝今飛ぶ松村）
        G.airborne = {
          x: lx,
          y: ly,
          vx: (Math.random()*2-1) * (60 + power*60),
          vy: G.launchVyBase + power * G.launchVyBonus
        };

        G.score += 10;
        updateHud();
        beep(720, 0.05, 'square', 0.08);
      } else {
        // シーソーに乗れない＝ミス
        loseLife();
      }
    }

    function step(dt){
      // seesaw
      G.cx += G.vx * dt;
      const half = G.len/2;
      G.cx = clamp(G.cx, 18+half, W-18-half);

      // miss cooldown
      if (G.missCooldown > 0) G.missCooldown = Math.max(0, G.missCooldown - dt);

      // airborne physics
      const a = G.airborne;
      if (a){
        a.vy += G.gravity * dt;
        a.x  += a.vx * dt;
        a.y  += a.vy * dt;

        // walls (soft)
        if (a.x < 18){ a.x=18; a.vx *= -0.5; }
        if (a.x > W-18){ a.x=W-18; a.vx *= -0.5; }

        // balloon hit
        for (const b of G.balloons){
          if (!b.alive) continue;
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const rr = b.r + 16;
          if (dx*dx + dy*dy <= rr*rr){
            b.alive=false;
            G.balloonLeft -= 1;
            G.score += 25;
            updateHud();
            beep(980, 0.05, 'square', 0.09);
            break;
          }
        }

        if (G.balloonLeft <= 0) winAndRespawnBalloons();

        // landing check
        tryLanding();

        // 落ちすぎたらミス（保険）
        if (a.y > H + 120){
          loseLife();
        }
      }
    }

    // ---------- Draw ----------
    function draw(){
      ctx.clearRect(0,0,W,H);

      // scanlines
      ctx.save();
      ctx.globalAlpha=0.06;
      ctx.fillStyle='#fff';
      for(let y=0;y<H;y+=4) ctx.fillRect(0,y,W,1);
      ctx.restore();

      // frame
      ctx.save();
      ctx.globalAlpha=0.65;
      ctx.strokeStyle='rgba(255,255,255,.22)';
      ctx.lineWidth=2;
      ctx.strokeRect(14,14,W-28,H-28);
      ctx.restore();

      // balloons
      for (const b of G.balloons){
        if (!b.alive) continue;
        drawBalloon(b.x,b.y,b.r);
      }

      // seesaw
      drawSeesaw();

      // waiting matsumura (乗ってる)
      drawMatsumura(endX(G.waitingEnd), G.y - 44, 0.95);

      // airborne matsumura
      if (G.airborne){
        drawMatsumura(G.airborne.x, G.airborne.y, 0.95);
      }

      // paused veil
      if (G.paused && !G.gameOver){
        ctx.save();
        ctx.fillStyle='rgba(11,16,32,.55)';
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle='rgba(243,246,255,.92)';
        ctx.font='800 22px ui-sans-serif, system-ui';
        ctx.textAlign='center';
        ctx.fillText('PAUSED', W/2, H/2);
        ctx.restore();
      }
    }

    function drawBalloon(x,y,r){
      ctx.save();
      ctx.globalAlpha=0.96;
      ctx.fillStyle='rgba(96,165,250,.95)';
      ctx.beginPath();
      ctx.ellipse(x,y,r*0.9,r*1.15,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.55)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(x, y + r*1.05);
      ctx.lineTo(x, y + r*1.8);
      ctx.stroke();
      ctx.restore();
    }

    function drawSeesaw(){
      const y=G.y, x=G.cx, half=G.len/2;
      const xL=x-half, xR=x+half;

      ctx.save();
      // base
      ctx.globalAlpha=0.95;
      ctx.fillStyle='rgba(255,255,255,.86)';
      ctx.beginPath();
      ctx.moveTo(x-12, y+22);
      ctx.lineTo(x+12, y+22);
      ctx.lineTo(x, y-6);
      ctx.closePath();
      ctx.fill();

      // plank
      ctx.strokeStyle='rgba(96,165,250,.85)';
      ctx.lineWidth=10;
      ctx.lineCap='round';
      ctx.beginPath();
      ctx.moveTo(xL,y);
      ctx.lineTo(xR,y);
      ctx.stroke();

      // end pads (乗ってる感)
      ctx.fillStyle='rgba(243,246,255,.92)';
      ctx.fillRect(xL-18, y-16, 36, 10);
      ctx.fillRect(xR-18, y-16, 36, 10);

      // ground
      ctx.globalAlpha=0.22;
      ctx.strokeStyle='rgba(255,255,255,.18)';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(18, y+52);
      ctx.lineTo(W-18, y+52);
      ctx.stroke();
      ctx.restore();
    }

    function drawMatsumura(x,y,scale=1){
      const w=40*scale, h=52*scale, r=10*scale;
      ctx.save();
      ctx.globalAlpha=0.98;
      ctx.fillStyle='rgba(255,255,255,.92)';
      roundRect(x-w/2, y-h/2, w,h,r);
      ctx.fill();

      if (matsumuraImg.complete && matsumuraImg.naturalWidth){
        const iw=matsumuraImg.naturalWidth, ih=matsumuraImg.naturalHeight;
        const boxW=w, boxH=h;
        const bx=x-boxW/2, by=y-boxH/2;
        const s=Math.min(boxW/iw, boxH/ih);
        const sw=iw*s, sh=ih*s;
        const sx=bx+(boxW-sw)/2;
        const sy=by+(boxH-sh)/2;
        ctx.save();
        roundRect(bx,by,boxW,boxH,r*0.7);
        ctx.clip();
        ctx.drawImage(matsumuraImg, sx,sy, sw,sh);
        ctx.restore();
      } else {
        ctx.fillStyle='rgba(11,16,32,.85)';
        ctx.fillRect(x-w/2+6*scale, y-h/2+10*scale, w-12*scale, h-18*scale);
      }

      // tiny feet shadow to “stand on seesaw”
      ctx.globalAlpha=0.45;
      ctx.fillStyle='rgba(11,16,32,.8)';
      ctx.beginPath();
      ctx.ellipse(x, y+h/2-6*scale, 10*scale, 3*scale, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // ---------- Loop ----------
    let lastT=0;
    function loop(t){
      if (!G.running) return;
      const dt = Math.min(0.033, (t-lastT)/1000);
      lastT=t;
      if (!G.paused && !G.gameOver){
        step(dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    // ---------- Controls ----------
    function move(dir){
      if (!G.running || G.paused || G.gameOver) return;
      G.vx = dir * G.moveSpeed;
      beep(320 + (dir>0?40:0), 0.02, 'square', 0.04);
    }
    function stop(){ G.vx = 0; }

    function bindHold(el, dir){
      el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); move(dir); }, {passive:false});
      el.addEventListener('pointerup', stop, {passive:true});
      el.addEventListener('pointercancel', stop, {passive:true});
      el.addEventListener('pointerleave', stop, {passive:true});
    }
    bindHold(leftBtn, -1);
    bindHold(rightBtn, +1);

    stage.addEventListener('pointerdown', (e)=>{
      if (!G.running || G.paused || G.gameOver) return;
      const r = stage.getBoundingClientRect();
      const x = e.clientX - r.left;
      move(x < r.width/2 ? -1 : +1);
    }, {passive:true});
    stage.addEventListener('pointerup', stop, {passive:true});
    stage.addEventListener('pointercancel', stop, {passive:true});

    // ---------- Keyboard (Arrow keys) ----------
    // 押しっぱなし対応：keydownで移動開始、keyupで停止
    const keyState = { left:false, right:false };

    function updateFromKeys(){
      if (!G.running || G.paused || G.gameOver) return;
      if (keyState.left && !keyState.right) move(-1);
      else if (keyState.right && !keyState.left) move(+1);
      else stop();
    }

    window.addEventListener('keydown', (e) => {
      // ページスクロール等を防ぐ（左右キー）
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') e.preventDefault();

      if (e.repeat) return; // 押しっぱのリピートでbeep連打しない
      if (e.key === 'ArrowLeft') keyState.left = true;
      if (e.key === 'ArrowRight') keyState.right = true;

      // おまけ：A/Dでも動く（不要なら消してOK）
      if (e.key === 'a' || e.key === 'A') keyState.left = true;
      if (e.key === 'd' || e.key === 'D') keyState.right = true;

      updateFromKeys();
    }, { passive:false });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keyState.left = false;
      if (e.key === 'ArrowRight') keyState.right = false;
      if (e.key === 'a' || e.key === 'A') keyState.left = false;
      if (e.key === 'd' || e.key === 'D') keyState.right = false;

      updateFromKeys();
    });

    // 画面外フォーカス外れで止まるように
    window.addEventListener('blur', () => {
      keyState.left = false;
      keyState.right = false;
      stop();
    });

    btnSound.addEventListener('click', ()=>{
      setSound(!soundOn);
      beep(660, 0.04);
    });

    startOn.addEventListener('click', ()=>{
      setSound(true);
      beep(660, 0.05);
      startGame();
    });
    startOff.addEventListener('click', ()=>{
      setSound(false);
      startGame();
    });

    // prevent double-tap zoom (ボタンやインタラクティブ要素は除外)
    let lastTouch=0;
    let touchCount=0;
    const isInteractive = (e) => {
      const t = e.target;
      return t.tagName === 'BUTTON' || t.tagName === 'A' || 
             t.closest('button') || t.closest('a') || 
             t.closest('.half') || t.closest('#leftBtn') || t.closest('#rightBtn') ||
             t.closest('#stage') || t.closest('#overlay');
    };
    document.addEventListener('touchstart', (e)=>{
      if (isInteractive(e)) return; // ボタンなどは除外
      touchCount++;
      const now=Date.now();
      if (now-lastTouch<=300 && touchCount===2){
        e.preventDefault();
        touchCount=0;
      }
      if (now-lastTouch>300) touchCount=1;
      lastTouch=now;
    }, {passive:false});
    document.addEventListener('touchend', (e)=>{
      if (isInteractive(e)) return; // ボタンなどは除外
      const now=Date.now();
      if (now-lastTouch<=300) e.preventDefault();
      lastTouch=now;
      setTimeout(()=>{touchCount=0;}, 300);
    }, {passive:false});

    // init
    setSound(true);
    fit();
    resetGame();
    draw();
  </script>
</body>
</html>
